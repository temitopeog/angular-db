{"version":3,"sources":["../../projects/splitio/src/lib/utils/constants.ts","../../projects/splitio/src/lib/utils/utils.ts","../../projects/splitio/src/lib/splitio.service.ts","../../projects/splitio/src/lib/splitio.guard.ts"],"names":["CONTROL","INIT_CLIENT_EXISTS","INIT_CLIENT_FIRST","CONTROL_CLIENT","getTreatment","getTreatmentWithConfig","treatment","config","getTreatments","splitNames","result","forEach","splitName","Object","assign","_a","getTreatmentsWithConfig","track","DEFAULT_MANAGER","splits","split","names","buildInstance","key","bucketingKey","matchingKey","parseTreatmentParams","param1","param2","param3","isString","Array","isArray","attributes","undefined","val","String","SplitService","this","clientsMap","Map","emittedEvents","isSDKReady","prototype","init","_this","splitio","console","log","Observable","observer","error","SplitFactory","modules","settings","version","splitClient","client","splitManager","manager","sdkInitEventObservable","instanceKey","core","sdkReady","Event","SDK_READY","on","set","sdkReady$","initClient","getSDKClient","toObservable","getClientObservable","event","isOneTimeEvent","getClient","getClientSDKReady","getClientSDKReadyTimedOut","getClientSDKReadyFromCache","getClientSDKUpdate","mainKey","sdkReadyTimedOut$","SDK_READY_TIMED_OUT","sdkReadyFromCache$","SDK_READY_FROM_CACHE","sdkUpdate$","SDK_UPDATE","ready","isInitialized","get","getSDKFactory","param4","param5","trafficType","eventType","value","properties","parseTrackParams","getManager","getSplits","getSplit","getSplitNames","destroy","mainInstanceKey","delete","from","eventKey","subscriber","Promise","resolve","then","next","once","Injectable","args","providedIn","SplitioGuard","splitService","canActivate","canLoad","canActivateChild"],"mappings":"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","sourcesContent":["/**\n * SDK constant for control treatment\n */\nexport const CONTROL = 'control';\n/**\n * string constant for observable to return when client exists for a key\n */\nexport const INIT_CLIENT_EXISTS = 'init::clientExists';\n/**\n * string constant for observable to return when client is not initialized\n */\nexport const INIT_CLIENT_FIRST = 'init::clientFirst';\n\nexport const VERSION = 'angular-' + 'ANGULAR_SDK_VERSION_NUMBER';\n\n/**\n * client with methods that return default values\n */\nexport const CONTROL_CLIENT = {\n  getTreatment: () => { return CONTROL; },\n  getTreatmentWithConfig: () => { return { treatment: CONTROL, config: null }; },\n  getTreatments: (splitNames: string[]) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n      result = { ...result, [splitName]: CONTROL };\n    });\n    return result;\n  },\n  getTreatmentsWithConfig: (splitNames: string[]) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n      result = { ...result, [splitName]: { treatment: CONTROL, config: null } };\n    });\n    return result;\n  },\n  track: () => { return false; }\n};\n\n/**\n *  with methods that return default values\n */\nexport const DEFAULT_MANAGER = {\n  splits: () => { return []; },\n  split: () => { return null; },\n  names: () => { return []; }\n};\n","export function buildInstance(key: SplitIO.SplitKey): string {\n  // @ts-ignore\n  if (!key.bucketingKey) return key;\n  // @ts-ignore\n  return `${key.matchingKey ? key.matchingKey : key}-${key.bucketingKey ? key.bucketingKey : key}-`;\n}\n\nexport function parseTreatmentParams(param1: string | string[] | SplitIO.SplitKey, param2?: string | string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): any {\n  if (isString(param2) || Array.isArray(param2)) return { key: param1, splitNames: param2, attributes: param3};\n  return { key: undefined, splitNames: param1, attributes: param2 };\n}\n\nexport function parseTrackParams(param1: string | SplitIO.SplitKey, param2: string, param3: number | string | undefined, param4: number | SplitIO.Properties | undefined, param5: SplitIO.Properties | undefined) {\n  if (isString(param3)) return { key: param1, trafficType: param2, eventType: param3, value: param4, properties: param5};\n  return { key: undefined, trafficType: param1, eventType: param2, value: param3, properties: param4 };\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === 'string' || val instanceof String;\n}\n","import { Injectable } from '@angular/core';\nimport { SplitFactory } from '@splitsoftware/splitio-browserjs';\nimport * as SplitIO from '@splitsoftware/splitio-browserjs/types/splitio';\nimport { from, Observable } from 'rxjs';\nimport { INIT_CLIENT_EXISTS, INIT_CLIENT_FIRST, CONTROL_CLIENT, DEFAULT_MANAGER, VERSION } from './utils/constants';\nimport { buildInstance, parseTrackParams, parseTreatmentParams } from './utils/utils';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SplitService {\n\n  /**\n   * The local reference to the Split SDK.\n   */\n  private splitio: SplitIO.ISDK | undefined;\n  /**\n   * The local reference to the Split SDK's Client.\n   */\n  private splitClient: SplitIO.IClient;\n  /**\n   * The local reference to the Split SDK's Manager.\n   */\n  private splitManager: SplitIO.IManager;\n  /**\n   * Map of intialized clients\n   */\n  private clientsMap: Map<string, SplitIO.IClient> = new Map<string, SplitIO.IClient>();\n  /**\n   * Map of events status of intialized clients\n   */\n  private emittedEvents: Map<string, boolean> = new Map<string, boolean>();\n  /**\n   * Flag to determine if SDK is ready or not.\n   */\n  isSDKReady = false;\n  /**\n   * Factory config\n   */\n  private config: SplitIO.IBrowserSettings;\n  /**\n   * SDK events observables\n   */\n  sdkReady$: Observable<string>;\n  sdkReadyTimedOut$: Observable<string>;\n  sdkReadyFromCache$: Observable<string>;\n  sdkUpdate$: Observable<string>;\n\n  /**\n   * This method initializes the SDK with the required Browser APIKEY\n   * and the 'key' according to the Traffic type set (ex.: an user id).\n   * @function init\n   * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  init(config: SplitIO.IBrowserSettings): Observable<string> {\n    if (this.splitio) {\n      console.log('[ERROR] There is another instance of the SDK.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    this.config = config;\n    // @ts-ignore. 2nd param is not part of type definitions. Used to overwrite the version of the SDK for correct tracking.\n    this.splitio = SplitFactory(config, (modules) => {\n      modules.settings.version = VERSION;\n    });\n    this.splitClient = this.splitio.client();\n    this.splitManager = this.splitio.manager();\n    this.sdkInitEventObservable();\n    const instanceKey = buildInstance(this.config.core.key);\n    const sdkReady = this.splitClient.Event.SDK_READY;\n    this.splitClient.on(sdkReady, () => {\n      this.emittedEvents.set(instanceKey + sdkReady, true);\n      this.isSDKReady = true;\n    });\n    this.clientsMap.set(instanceKey, this.splitClient);\n    return this.sdkReady$;\n  }\n\n  /**\n   * Returns a shared client of the SDK, associated with the given key\n   * @function initClient\n   * @param {SplitKey} key The key for the new client instance.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  initClient(key: SplitIO.SplitKey): Observable<string> {\n    let client = this.getSDKClient(key);\n    if (client) {\n      console.log('[WARN] client for key ' + buildInstance(key) + ' is already initialized.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    if (!this.splitio) return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    client = this.splitio.client(key);\n    this.clientsMap.set(buildInstance(key), client);\n    return this.toObservable(key, client, client.Event.SDK_READY);\n  }\n\n  private getClientObservable(key: SplitIO.SplitKey, event: string, isOneTimeEvent = true): Observable<string> {\n    const client = this.getClient(key);\n    if (client === CONTROL_CLIENT) {\n      return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    }\n    return this.toObservable(key, client, client.Event[event], isOneTimeEvent);\n  }\n\n  /**\n   * Returns an observable that calls back when the client is ready\n   * @function getClientSDKReady\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReady(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY');\n  }\n\n  /**\n   * Returns an observable that calls back when the client ready event is timed out\n   * @function getClientSDKReadyTimedOut\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyTimedOut(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY_TIMED_OUT');\n  }\n\n  /**\n   * Returns an observable that calls back when the client is ready from cache\n   * @function getClientSDKReadyFromCache\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyFromCache(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY_FROM_CACHE');\n  }\n\n  /**\n   * Returns an observable that calls back when the client is updated\n   * @function getClientSDKUpdate\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKUpdate(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_UPDATE', false);\n  }\n\n  /**\n   * initialize sdk Events into observables\n   */\n  private sdkInitEventObservable(): void {\n    const client = this.splitClient;\n    const mainKey = this.config.core.key;\n    this.sdkReady$ = this.toObservable(mainKey, client, client.Event.SDK_READY);\n    this.sdkReadyTimedOut$ = this.toObservable(mainKey, client, client.Event.SDK_READY_TIMED_OUT);\n    this.sdkReadyFromCache$ = this.toObservable(mainKey, client, client.Event.SDK_READY_FROM_CACHE);\n    this.sdkUpdate$ = this.toObservable(mainKey, client, client.Event.SDK_UPDATE, false);\n  }\n\n  /**\n   * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).\n   * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,\n   * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.\n   * @returns Promise<void>\n   */\n  ready(): Promise<void> {\n    return this.getClient().ready();\n  }\n\n  private isInitialized(): boolean {\n    if (!this.splitio) {\n      console.log('[ERROR] plugin should be initialized');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the SDK client\n   * @param {SplitKey=} key The key for the client instance.\n   * @returns {IClient} split client.\n   */\n  getSDKClient(key?: SplitIO.SplitKey): SplitIO.IClient | undefined {\n    if (!this.isInitialized()) return undefined;\n    key = key ? key : this.config.core.key;\n    return this.clientsMap.get(buildInstance(key));\n  }\n\n  /**\n   * Returns the SDK factory\n   * @returns {ISDK} split factory\n   */\n  getSDKFactory(): SplitIO.ISDK | undefined {\n    if (!this.isInitialized()) return undefined;\n    return this.splitio;\n  }\n\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  private getClient(key?: SplitIO.SplitKey | undefined): any {\n    const client = this.getSDKClient(key);\n    if (!client) {\n      console.log('[ERROR] client' + ( key ? ' for key ' + buildInstance(key) : '') + ' should be initialized first.');\n      return CONTROL_CLIENT;\n    }\n    return client;\n  }\n\n  /**\n   * Returns a Treatment value, which is the treatment string for the given feature.\n   * @function getTreatment\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatment} - The treatment string.\n   */\n  getTreatment(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;\n  /**\n   * Returns a Treatment value, which is the treatment string for the given feature.\n   * @function getTreatment\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatment} - The treatment string.\n   */\n  getTreatment(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;\n  getTreatment(param1: string | SplitIO.SplitKey, param2?: string | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.Treatment {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatment(splitNames, attributes);\n  }\n\n  /**\n   * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.\n   * @function getTreatmentWithConfig\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).\n   */\n  getTreatmentWithConfig(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;\n  /**\n   * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.\n   * @function getTreatmentWithConfig\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).\n   */\n  getTreatmentWithConfig(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;\n  getTreatmentWithConfig(param1: string | SplitIO.SplitKey, param2?: string | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentWithConfig(splitNames, attributes);\n  }\n\n  /**\n   * Returns a Treatments value, which is an object map with the treatments for the given features.\n   * @function getTreatments\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatments} - The treatments object map.\n   */\n  getTreatments(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;\n  /**\n   * Returns a Treatments value, which is an object map with the treatments for the given features.\n   * @function getTreatments\\\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatments} - The treatments object map.\n   */\n  getTreatments(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;\n  getTreatments(param1: string[] | SplitIO.SplitKey, param2?: string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.Treatments {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatments(splitNames, attributes);\n  }\n\n  /**\n   * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.\n   * @function getTreatmentsWithConfig\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects\n   */\n  getTreatmentsWithConfig(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;\n  /**\n   * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.\n   * @function getTreatmentsWithConfig\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects\n   */\n  getTreatmentsWithConfig(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;\n  getTreatmentsWithConfig(param1: string[] | SplitIO.SplitKey, param2?: string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentsWithConfig(splitNames, attributes);\n  }\n\n  /**\n   * Tracks an event for a shared client to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).\n   * @function track\n   * @param {SplitKey} key - The key that identifies the entity related to this event.\n   * @param {string} trafficType - The traffic type of the entity related to this event.\n   * @param {string} eventType - The event type corresponding to this event.\n   * @param {number=} value - The value of this event.\n   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.\n   */\n  track(key: SplitIO.SplitKey, trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;\n  /**\n   * Tracks an event to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).\n   * @function track\n   * @param {string} trafficType - The traffic type of the entity related to this event.\n   * @param {string} eventType - The event type corresponding to this event.\n   * @param {number=} value - The value of this event.\n   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.\n   */\n  track(trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;\n  track(param1: string | SplitIO.SplitKey, param2: string, param3?: string | number | undefined, param4?: number | SplitIO.Properties | undefined, param5?: SplitIO.Properties | undefined): boolean {\n    const {key, trafficType, eventType, value, properties} = parseTrackParams(param1, param2, param3, param4, param5);\n    return this.getClient(key).track(trafficType, eventType, value, properties);\n  }\n\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  private getManager() {\n    const client = this.getSDKClient();\n    if (!client) {\n      console.log('[ERROR] The SDK has not being initialized. Returning default response for method call.');\n      return DEFAULT_MANAGER;\n    }\n    return this.splitManager;\n  }\n\n  /**\n   * Get the array of splits data in SplitView format.\n   * @function getSplits\n   * @returns {SplitViews} The list of SplitIO.SplitView.\n   */\n  getSplits(): SplitIO.SplitViews {\n    return this.getManager().splits();\n  }\n\n  /**\n   * Get the data of a split in SplitView format.\n   * @function getSplit\n   * @param {string} splitName The name of the split we wan't to get info of.\n   * @returns {SplitView} The SplitIO.SplitView of the given split.\n   */\n  getSplit(splitName: string): SplitIO.SplitView | null {\n    return this.getManager().split(splitName);\n  }\n\n  /**\n   * Get the array of Split names.\n   * @function getSplitNames\n   * @returns {SplitNames} The lists of Split names.\n   */\n  getSplitNames(): SplitIO.SplitNames {\n    return this.getManager().names();\n  }\n\n  /**\n   * Destroy all clients instances.\n   * @function destroy\n   * @returns {Observable<unknown>}\n   */\n  destroy(): Observable<void> {\n    const mainInstanceKey = buildInstance(this.config.core.key);\n    this.clientsMap.forEach((client, key) => {\n      if (buildInstance(key) !== mainInstanceKey){\n        client.destroy();\n        this.clientsMap.delete(buildInstance(key));\n      }\n    });\n    this.clientsMap.delete(mainInstanceKey);\n    this.splitio = undefined;\n    return from(this.splitClient.destroy());\n  }\n\n  /**\n   * Private function to return as observable the event on parameter\n   * @param {string} event\n   * @param response\n   * @returns Observable<any>\n   */\n  private toObservable(key: SplitIO.SplitKey, client: SplitIO.IClient, event: string, isOneTimeEvent = true): Observable<string> {\n    const eventKey = buildInstance(key) + event;\n    if (isOneTimeEvent) {\n      return new Observable(subscriber => {\n        const wasEventEmitted = this.emittedEvents.get(eventKey);\n        if (wasEventEmitted) {\n          Promise.resolve().then(() => subscriber.next(event));\n        } else {\n          client.once(event, () => {\n            this.emittedEvents.set(eventKey, true);\n            subscriber.next(event);\n          });\n        }\n      });\n    } else {\n      return new Observable(subscriber => {\n        client.on(event, () => {\n          subscriber.next(event);\n        });\n      });\n    }\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { CanActivate, CanActivateChild, CanLoad } from '@angular/router';\nimport { SplitService } from './splitio.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SplitioGuard implements CanActivate, CanLoad, CanActivateChild {\n\n  constructor(private splitService: SplitService) {}\n\n  canActivate(): boolean {\n    return this.splitService.isSDKReady;\n  }\n\n  canLoad(): boolean {\n    return this.splitService.isSDKReady;\n  }\n\n  canActivateChild(): boolean {\n    return this.splitService.isSDKReady;\n  }\n}\n"]}