(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@splitsoftware/splitio-browserjs'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('@splitsoftware/splitio-angular', ['exports', '@angular/core', '@splitsoftware/splitio-browserjs', 'rxjs'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.splitsoftware = global.splitsoftware || {}, global.splitsoftware['splitio-angular'] = {}), global.ng.core, global.splitioBrowserjs, global.rxjs));
}(this, (function (exports, i0, splitioBrowserjs, rxjs) { 'use strict';

    /**
     * SDK constant for control treatment
     */
    var CONTROL = 'control';
    /**
     * string constant for observable to return when client exists for a key
     */
    var INIT_CLIENT_EXISTS = 'init::clientExists';
    /**
     * string constant for observable to return when client is not initialized
     */
    var INIT_CLIENT_FIRST = 'init::clientFirst';
    var VERSION = 'angular-' + 'ANGULAR_SDK_VERSION_NUMBER';
    var ɵ0 = function () { return CONTROL; }, ɵ1 = function () { return { treatment: CONTROL, config: null }; }, ɵ2 = function (splitNames) {
        var result = {};
        splitNames.forEach(function (splitName) {
            var _a;
            result = Object.assign(Object.assign({}, result), (_a = {}, _a[splitName] = CONTROL, _a));
        });
        return result;
    }, ɵ3 = function (splitNames) {
        var result = {};
        splitNames.forEach(function (splitName) {
            var _a;
            result = Object.assign(Object.assign({}, result), (_a = {}, _a[splitName] = { treatment: CONTROL, config: null }, _a));
        });
        return result;
    }, ɵ4 = function () { return false; };
    /**
     * client with methods that return default values
     */
    var CONTROL_CLIENT = {
        getTreatment: ɵ0,
        getTreatmentWithConfig: ɵ1,
        getTreatments: ɵ2,
        getTreatmentsWithConfig: ɵ3,
        track: ɵ4
    };
    var ɵ5 = function () { return []; }, ɵ6 = function () { return null; }, ɵ7 = function () { return []; };
    /**
     *  with methods that return default values
     */
    var DEFAULT_MANAGER = {
        splits: ɵ5,
        split: ɵ6,
        names: ɵ7
    };

    function buildInstance(key) {
        // @ts-ignore
        if (!key.bucketingKey)
            return key;
        // @ts-ignore
        return (key.matchingKey ? key.matchingKey : key) + "-" + (key.bucketingKey ? key.bucketingKey : key) + "-";
    }
    function parseTreatmentParams(param1, param2, param3) {
        if (isString(param2) || Array.isArray(param2))
            return { key: param1, splitNames: param2, attributes: param3 };
        return { key: undefined, splitNames: param1, attributes: param2 };
    }
    function parseTrackParams(param1, param2, param3, param4, param5) {
        if (isString(param3))
            return { key: param1, trafficType: param2, eventType: param3, value: param4, properties: param5 };
        return { key: undefined, trafficType: param1, eventType: param2, value: param3, properties: param4 };
    }
    function isString(val) {
        return typeof val === 'string' || val instanceof String;
    }

    var SplitService = /** @class */ (function () {
        function SplitService() {
            /**
             * Map of intialized clients
             */
            this.clientsMap = new Map();
            /**
             * Map of events status of intialized clients
             */
            this.emittedEvents = new Map();
            /**
             * Flag to determine if SDK is ready or not.
             */
            this.isSDKReady = false;
        }
        /**
         * This method initializes the SDK with the required Browser APIKEY
         * and the 'key' according to the Traffic type set (ex.: an user id).
         * @function init
         * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.
         * @returns {Observable<string>} Returns when sdk is ready
         */
        SplitService.prototype.init = function (config) {
            var _this = this;
            if (this.splitio) {
                console.log('[ERROR] There is another instance of the SDK.');
                return new rxjs.Observable(function (observer) { return observer.error(INIT_CLIENT_EXISTS); });
            }
            this.config = config;
            // @ts-ignore. 2nd param is not part of type definitions. Used to overwrite the version of the SDK for correct tracking.
            this.splitio = splitioBrowserjs.SplitFactory(config, function (modules) {
                modules.settings.version = VERSION;
            });
            this.splitClient = this.splitio.client();
            this.splitManager = this.splitio.manager();
            this.sdkInitEventObservable();
            var instanceKey = buildInstance(this.config.core.key);
            var sdkReady = this.splitClient.Event.SDK_READY;
            this.splitClient.on(sdkReady, function () {
                _this.emittedEvents.set(instanceKey + sdkReady, true);
                _this.isSDKReady = true;
            });
            this.clientsMap.set(instanceKey, this.splitClient);
            return this.sdkReady$;
        };
        /**
         * Returns a shared client of the SDK, associated with the given key
         * @function initClient
         * @param {SplitKey} key The key for the new client instance.
         * @returns {Observable<string>} Returns when sdk is ready
         */
        SplitService.prototype.initClient = function (key) {
            var client = this.getSDKClient(key);
            if (client) {
                console.log('[WARN] client for key ' + buildInstance(key) + ' is already initialized.');
                return new rxjs.Observable(function (observer) { return observer.error(INIT_CLIENT_EXISTS); });
            }
            if (!this.splitio)
                return new rxjs.Observable(function (observer) { return observer.error(INIT_CLIENT_FIRST); });
            client = this.splitio.client(key);
            this.clientsMap.set(buildInstance(key), client);
            return this.toObservable(key, client, client.Event.SDK_READY);
        };
        SplitService.prototype.getClientObservable = function (key, event, isOneTimeEvent) {
            if (isOneTimeEvent === void 0) { isOneTimeEvent = true; }
            var client = this.getClient(key);
            if (client === CONTROL_CLIENT) {
                return new rxjs.Observable(function (observer) { return observer.error(INIT_CLIENT_FIRST); });
            }
            return this.toObservable(key, client, client.Event[event], isOneTimeEvent);
        };
        /**
         * Returns an observable that calls back when the client is ready
         * @function getClientSDKReady
         * @param {SplitKey} key The key for the client instance.
         * @returns {Observable<string>}
         */
        SplitService.prototype.getClientSDKReady = function (key) {
            return this.getClientObservable(key, 'SDK_READY');
        };
        /**
         * Returns an observable that calls back when the client ready event is timed out
         * @function getClientSDKReadyTimedOut
         * @param {SplitKey} key The key for the client instance.
         * @returns {Observable<string>}
         */
        SplitService.prototype.getClientSDKReadyTimedOut = function (key) {
            return this.getClientObservable(key, 'SDK_READY_TIMED_OUT');
        };
        /**
         * Returns an observable that calls back when the client is ready from cache
         * @function getClientSDKReadyFromCache
         * @param {SplitKey} key The key for the client instance.
         * @returns {Observable<string>}
         */
        SplitService.prototype.getClientSDKReadyFromCache = function (key) {
            return this.getClientObservable(key, 'SDK_READY_FROM_CACHE');
        };
        /**
         * Returns an observable that calls back when the client is updated
         * @function getClientSDKUpdate
         * @param {SplitKey} key The key for the client instance.
         * @returns {Observable<string>}
         */
        SplitService.prototype.getClientSDKUpdate = function (key) {
            return this.getClientObservable(key, 'SDK_UPDATE', false);
        };
        /**
         * initialize sdk Events into observables
         */
        SplitService.prototype.sdkInitEventObservable = function () {
            var client = this.splitClient;
            var mainKey = this.config.core.key;
            this.sdkReady$ = this.toObservable(mainKey, client, client.Event.SDK_READY);
            this.sdkReadyTimedOut$ = this.toObservable(mainKey, client, client.Event.SDK_READY_TIMED_OUT);
            this.sdkReadyFromCache$ = this.toObservable(mainKey, client, client.Event.SDK_READY_FROM_CACHE);
            this.sdkUpdate$ = this.toObservable(mainKey, client, client.Event.SDK_UPDATE, false);
        };
        /**
         * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).
         * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,
         * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.
         * @returns Promise<void>
         */
        SplitService.prototype.ready = function () {
            return this.getClient().ready();
        };
        SplitService.prototype.isInitialized = function () {
            if (!this.splitio) {
                console.log('[ERROR] plugin should be initialized');
                return false;
            }
            return true;
        };
        /**
         * Returns the SDK client
         * @param {SplitKey=} key The key for the client instance.
         * @returns {IClient} split client.
         */
        SplitService.prototype.getSDKClient = function (key) {
            if (!this.isInitialized())
                return undefined;
            key = key ? key : this.config.core.key;
            return this.clientsMap.get(buildInstance(key));
        };
        /**
         * Returns the SDK factory
         * @returns {ISDK} split factory
         */
        SplitService.prototype.getSDKFactory = function () {
            if (!this.isInitialized())
                return undefined;
            return this.splitio;
        };
        /**
         * Validates key and returns client if it is initialized for key or controlClient if it isn't
         */
        SplitService.prototype.getClient = function (key) {
            var client = this.getSDKClient(key);
            if (!client) {
                console.log('[ERROR] client' + (key ? ' for key ' + buildInstance(key) : '') + ' should be initialized first.');
                return CONTROL_CLIENT;
            }
            return client;
        };
        SplitService.prototype.getTreatment = function (param1, param2, param3) {
            var _a = parseTreatmentParams(param1, param2, param3), key = _a.key, splitNames = _a.splitNames, attributes = _a.attributes;
            return this.getClient(key).getTreatment(splitNames, attributes);
        };
        SplitService.prototype.getTreatmentWithConfig = function (param1, param2, param3) {
            var _a = parseTreatmentParams(param1, param2, param3), key = _a.key, splitNames = _a.splitNames, attributes = _a.attributes;
            return this.getClient(key).getTreatmentWithConfig(splitNames, attributes);
        };
        SplitService.prototype.getTreatments = function (param1, param2, param3) {
            var _a = parseTreatmentParams(param1, param2, param3), key = _a.key, splitNames = _a.splitNames, attributes = _a.attributes;
            return this.getClient(key).getTreatments(splitNames, attributes);
        };
        SplitService.prototype.getTreatmentsWithConfig = function (param1, param2, param3) {
            var _a = parseTreatmentParams(param1, param2, param3), key = _a.key, splitNames = _a.splitNames, attributes = _a.attributes;
            return this.getClient(key).getTreatmentsWithConfig(splitNames, attributes);
        };
        SplitService.prototype.track = function (param1, param2, param3, param4, param5) {
            var _a = parseTrackParams(param1, param2, param3, param4, param5), key = _a.key, trafficType = _a.trafficType, eventType = _a.eventType, value = _a.value, properties = _a.properties;
            return this.getClient(key).track(trafficType, eventType, value, properties);
        };
        /**
         * Validates key and returns client if it is initialized for key or controlClient if it isn't
         */
        SplitService.prototype.getManager = function () {
            var client = this.getSDKClient();
            if (!client) {
                console.log('[ERROR] The SDK has not being initialized. Returning default response for method call.');
                return DEFAULT_MANAGER;
            }
            return this.splitManager;
        };
        /**
         * Get the array of splits data in SplitView format.
         * @function getSplits
         * @returns {SplitViews} The list of SplitIO.SplitView.
         */
        SplitService.prototype.getSplits = function () {
            return this.getManager().splits();
        };
        /**
         * Get the data of a split in SplitView format.
         * @function getSplit
         * @param {string} splitName The name of the split we wan't to get info of.
         * @returns {SplitView} The SplitIO.SplitView of the given split.
         */
        SplitService.prototype.getSplit = function (splitName) {
            return this.getManager().split(splitName);
        };
        /**
         * Get the array of Split names.
         * @function getSplitNames
         * @returns {SplitNames} The lists of Split names.
         */
        SplitService.prototype.getSplitNames = function () {
            return this.getManager().names();
        };
        /**
         * Destroy all clients instances.
         * @function destroy
         * @returns {Observable<unknown>}
         */
        SplitService.prototype.destroy = function () {
            var _this = this;
            var mainInstanceKey = buildInstance(this.config.core.key);
            this.clientsMap.forEach(function (client, key) {
                if (buildInstance(key) !== mainInstanceKey) {
                    client.destroy();
                    _this.clientsMap.delete(buildInstance(key));
                }
            });
            this.clientsMap.delete(mainInstanceKey);
            this.splitio = undefined;
            return rxjs.from(this.splitClient.destroy());
        };
        /**
         * Private function to return as observable the event on parameter
         * @param {string} event
         * @param response
         * @returns Observable<any>
         */
        SplitService.prototype.toObservable = function (key, client, event, isOneTimeEvent) {
            var _this = this;
            if (isOneTimeEvent === void 0) { isOneTimeEvent = true; }
            var eventKey = buildInstance(key) + event;
            if (isOneTimeEvent) {
                return new rxjs.Observable(function (subscriber) {
                    var wasEventEmitted = _this.emittedEvents.get(eventKey);
                    if (wasEventEmitted) {
                        Promise.resolve().then(function () { return subscriber.next(event); });
                    }
                    else {
                        client.once(event, function () {
                            _this.emittedEvents.set(eventKey, true);
                            subscriber.next(event);
                        });
                    }
                });
            }
            else {
                return new rxjs.Observable(function (subscriber) {
                    client.on(event, function () {
                        subscriber.next(event);
                    });
                });
            }
        };
        return SplitService;
    }());
    SplitService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SplitService_Factory() { return new SplitService(); }, token: SplitService, providedIn: "root" });
    SplitService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];

    var SplitioGuard = /** @class */ (function () {
        function SplitioGuard(splitService) {
            this.splitService = splitService;
        }
        SplitioGuard.prototype.canActivate = function () {
            return this.splitService.isSDKReady;
        };
        SplitioGuard.prototype.canLoad = function () {
            return this.splitService.isSDKReady;
        };
        SplitioGuard.prototype.canActivateChild = function () {
            return this.splitService.isSDKReady;
        };
        return SplitioGuard;
    }());
    SplitioGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function SplitioGuard_Factory() { return new SplitioGuard(i0.ɵɵinject(SplitService)); }, token: SplitioGuard, providedIn: "root" });
    SplitioGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    SplitioGuard.ctorParameters = function () { return [
        { type: SplitService }
    ]; };

    /*
     * Public API Surface of splitio
     */

    /**
     * Generated bundle index. Do not edit.
     */

    Object.defineProperty(exports, 'DebugLogger', {
        enumerable: true,
        get: function () {
            return splitioBrowserjs.DebugLogger;
        }
    });
    Object.defineProperty(exports, 'ErrorLogger', {
        enumerable: true,
        get: function () {
            return splitioBrowserjs.ErrorLogger;
        }
    });
    Object.defineProperty(exports, 'InLocalStorage', {
        enumerable: true,
        get: function () {
            return splitioBrowserjs.InLocalStorage;
        }
    });
    Object.defineProperty(exports, 'InfoLogger', {
        enumerable: true,
        get: function () {
            return splitioBrowserjs.InfoLogger;
        }
    });
    Object.defineProperty(exports, 'LocalhostFromObject', {
        enumerable: true,
        get: function () {
            return splitioBrowserjs.LocalhostFromObject;
        }
    });
    Object.defineProperty(exports, 'WarnLogger', {
        enumerable: true,
        get: function () {
            return splitioBrowserjs.WarnLogger;
        }
    });
    exports.SplitService = SplitService;
    exports.SplitioGuard = SplitioGuard;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=splitsoftware-splitio-angular.umd.js.map
