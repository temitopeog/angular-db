{"version":3,"file":"splitsoftware-splitio-angular.umd.js","sources":["../../projects/splitio/src/lib/utils/constants.ts","../../projects/splitio/src/lib/utils/utils.ts","../../projects/splitio/src/lib/splitio.service.ts","../../projects/splitio/src/lib/splitio.guard.ts","../../projects/splitio/src/public-api.ts","../../projects/splitio/src/splitsoftware-splitio-angular.ts"],"sourcesContent":["/**\n * SDK constant for control treatment\n */\nexport const CONTROL = 'control';\n/**\n * string constant for observable to return when client exists for a key\n */\nexport const INIT_CLIENT_EXISTS = 'init::clientExists';\n/**\n * string constant for observable to return when client is not initialized\n */\nexport const INIT_CLIENT_FIRST = 'init::clientFirst';\n\nexport const VERSION = 'angular-' + 'ANGULAR_SDK_VERSION_NUMBER';\n\n/**\n * client with methods that return default values\n */\nexport const CONTROL_CLIENT = {\n  getTreatment: () => { return CONTROL; },\n  getTreatmentWithConfig: () => { return { treatment: CONTROL, config: null }; },\n  getTreatments: (splitNames: string[]) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n      result = { ...result, [splitName]: CONTROL };\n    });\n    return result;\n  },\n  getTreatmentsWithConfig: (splitNames: string[]) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n      result = { ...result, [splitName]: { treatment: CONTROL, config: null } };\n    });\n    return result;\n  },\n  track: () => { return false; }\n};\n\n/**\n *  with methods that return default values\n */\nexport const DEFAULT_MANAGER = {\n  splits: () => { return []; },\n  split: () => { return null; },\n  names: () => { return []; }\n};\n","export function buildInstance(key: SplitIO.SplitKey): string {\n  // @ts-ignore\n  if (!key.bucketingKey) return key;\n  // @ts-ignore\n  return `${key.matchingKey ? key.matchingKey : key}-${key.bucketingKey ? key.bucketingKey : key}-`;\n}\n\nexport function parseTreatmentParams(param1: string | string[] | SplitIO.SplitKey, param2?: string | string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): any {\n  if (isString(param2) || Array.isArray(param2)) return { key: param1, splitNames: param2, attributes: param3};\n  return { key: undefined, splitNames: param1, attributes: param2 };\n}\n\nexport function parseTrackParams(param1: string | SplitIO.SplitKey, param2: string, param3: number | string | undefined, param4: number | SplitIO.Properties | undefined, param5: SplitIO.Properties | undefined) {\n  if (isString(param3)) return { key: param1, trafficType: param2, eventType: param3, value: param4, properties: param5};\n  return { key: undefined, trafficType: param1, eventType: param2, value: param3, properties: param4 };\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === 'string' || val instanceof String;\n}\n","import { Injectable } from '@angular/core';\nimport { SplitFactory } from '@splitsoftware/splitio-browserjs';\nimport * as SplitIO from '@splitsoftware/splitio-browserjs/types/splitio';\nimport { from, Observable } from 'rxjs';\nimport { INIT_CLIENT_EXISTS, INIT_CLIENT_FIRST, CONTROL_CLIENT, DEFAULT_MANAGER, VERSION } from './utils/constants';\nimport { buildInstance, parseTrackParams, parseTreatmentParams } from './utils/utils';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SplitService {\n\n  /**\n   * The local reference to the Split SDK.\n   */\n  private splitio: SplitIO.ISDK | undefined;\n  /**\n   * The local reference to the Split SDK's Client.\n   */\n  private splitClient: SplitIO.IClient;\n  /**\n   * The local reference to the Split SDK's Manager.\n   */\n  private splitManager: SplitIO.IManager;\n  /**\n   * Map of intialized clients\n   */\n  private clientsMap: Map<string, SplitIO.IClient> = new Map<string, SplitIO.IClient>();\n  /**\n   * Map of events status of intialized clients\n   */\n  private emittedEvents: Map<string, boolean> = new Map<string, boolean>();\n  /**\n   * Flag to determine if SDK is ready or not.\n   */\n  isSDKReady = false;\n  /**\n   * Factory config\n   */\n  private config: SplitIO.IBrowserSettings;\n  /**\n   * SDK events observables\n   */\n  sdkReady$: Observable<string>;\n  sdkReadyTimedOut$: Observable<string>;\n  sdkReadyFromCache$: Observable<string>;\n  sdkUpdate$: Observable<string>;\n\n  /**\n   * This method initializes the SDK with the required Browser APIKEY\n   * and the 'key' according to the Traffic type set (ex.: an user id).\n   * @function init\n   * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  init(config: SplitIO.IBrowserSettings): Observable<string> {\n    if (this.splitio) {\n      console.log('[ERROR] There is another instance of the SDK.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    this.config = config;\n    // @ts-ignore. 2nd param is not part of type definitions. Used to overwrite the version of the SDK for correct tracking.\n    this.splitio = SplitFactory(config, (modules) => {\n      modules.settings.version = VERSION;\n    });\n    this.splitClient = this.splitio.client();\n    this.splitManager = this.splitio.manager();\n    this.sdkInitEventObservable();\n    const instanceKey = buildInstance(this.config.core.key);\n    const sdkReady = this.splitClient.Event.SDK_READY;\n    this.splitClient.on(sdkReady, () => {\n      this.emittedEvents.set(instanceKey + sdkReady, true);\n      this.isSDKReady = true;\n    });\n    this.clientsMap.set(instanceKey, this.splitClient);\n    return this.sdkReady$;\n  }\n\n  /**\n   * Returns a shared client of the SDK, associated with the given key\n   * @function initClient\n   * @param {SplitKey} key The key for the new client instance.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  initClient(key: SplitIO.SplitKey): Observable<string> {\n    let client = this.getSDKClient(key);\n    if (client) {\n      console.log('[WARN] client for key ' + buildInstance(key) + ' is already initialized.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    if (!this.splitio) return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    client = this.splitio.client(key);\n    this.clientsMap.set(buildInstance(key), client);\n    return this.toObservable(key, client, client.Event.SDK_READY);\n  }\n\n  private getClientObservable(key: SplitIO.SplitKey, event: string, isOneTimeEvent = true): Observable<string> {\n    const client = this.getClient(key);\n    if (client === CONTROL_CLIENT) {\n      return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    }\n    return this.toObservable(key, client, client.Event[event], isOneTimeEvent);\n  }\n\n  /**\n   * Returns an observable that calls back when the client is ready\n   * @function getClientSDKReady\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReady(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY');\n  }\n\n  /**\n   * Returns an observable that calls back when the client ready event is timed out\n   * @function getClientSDKReadyTimedOut\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyTimedOut(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY_TIMED_OUT');\n  }\n\n  /**\n   * Returns an observable that calls back when the client is ready from cache\n   * @function getClientSDKReadyFromCache\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyFromCache(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY_FROM_CACHE');\n  }\n\n  /**\n   * Returns an observable that calls back when the client is updated\n   * @function getClientSDKUpdate\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKUpdate(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_UPDATE', false);\n  }\n\n  /**\n   * initialize sdk Events into observables\n   */\n  private sdkInitEventObservable(): void {\n    const client = this.splitClient;\n    const mainKey = this.config.core.key;\n    this.sdkReady$ = this.toObservable(mainKey, client, client.Event.SDK_READY);\n    this.sdkReadyTimedOut$ = this.toObservable(mainKey, client, client.Event.SDK_READY_TIMED_OUT);\n    this.sdkReadyFromCache$ = this.toObservable(mainKey, client, client.Event.SDK_READY_FROM_CACHE);\n    this.sdkUpdate$ = this.toObservable(mainKey, client, client.Event.SDK_UPDATE, false);\n  }\n\n  /**\n   * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).\n   * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,\n   * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.\n   * @returns Promise<void>\n   */\n  ready(): Promise<void> {\n    return this.getClient().ready();\n  }\n\n  private isInitialized(): boolean {\n    if (!this.splitio) {\n      console.log('[ERROR] plugin should be initialized');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the SDK client\n   * @param {SplitKey=} key The key for the client instance.\n   * @returns {IClient} split client.\n   */\n  getSDKClient(key?: SplitIO.SplitKey): SplitIO.IClient | undefined {\n    if (!this.isInitialized()) return undefined;\n    key = key ? key : this.config.core.key;\n    return this.clientsMap.get(buildInstance(key));\n  }\n\n  /**\n   * Returns the SDK factory\n   * @returns {ISDK} split factory\n   */\n  getSDKFactory(): SplitIO.ISDK | undefined {\n    if (!this.isInitialized()) return undefined;\n    return this.splitio;\n  }\n\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  private getClient(key?: SplitIO.SplitKey | undefined): any {\n    const client = this.getSDKClient(key);\n    if (!client) {\n      console.log('[ERROR] client' + ( key ? ' for key ' + buildInstance(key) : '') + ' should be initialized first.');\n      return CONTROL_CLIENT;\n    }\n    return client;\n  }\n\n  /**\n   * Returns a Treatment value, which is the treatment string for the given feature.\n   * @function getTreatment\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatment} - The treatment string.\n   */\n  getTreatment(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;\n  /**\n   * Returns a Treatment value, which is the treatment string for the given feature.\n   * @function getTreatment\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatment} - The treatment string.\n   */\n  getTreatment(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;\n  getTreatment(param1: string | SplitIO.SplitKey, param2?: string | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.Treatment {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatment(splitNames, attributes);\n  }\n\n  /**\n   * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.\n   * @function getTreatmentWithConfig\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).\n   */\n  getTreatmentWithConfig(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;\n  /**\n   * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.\n   * @function getTreatmentWithConfig\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).\n   */\n  getTreatmentWithConfig(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;\n  getTreatmentWithConfig(param1: string | SplitIO.SplitKey, param2?: string | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentWithConfig(splitNames, attributes);\n  }\n\n  /**\n   * Returns a Treatments value, which is an object map with the treatments for the given features.\n   * @function getTreatments\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatments} - The treatments object map.\n   */\n  getTreatments(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;\n  /**\n   * Returns a Treatments value, which is an object map with the treatments for the given features.\n   * @function getTreatments\\\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatments} - The treatments object map.\n   */\n  getTreatments(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;\n  getTreatments(param1: string[] | SplitIO.SplitKey, param2?: string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.Treatments {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatments(splitNames, attributes);\n  }\n\n  /**\n   * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.\n   * @function getTreatmentsWithConfig\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects\n   */\n  getTreatmentsWithConfig(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;\n  /**\n   * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.\n   * @function getTreatmentsWithConfig\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects\n   */\n  getTreatmentsWithConfig(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;\n  getTreatmentsWithConfig(param1: string[] | SplitIO.SplitKey, param2?: string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentsWithConfig(splitNames, attributes);\n  }\n\n  /**\n   * Tracks an event for a shared client to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).\n   * @function track\n   * @param {SplitKey} key - The key that identifies the entity related to this event.\n   * @param {string} trafficType - The traffic type of the entity related to this event.\n   * @param {string} eventType - The event type corresponding to this event.\n   * @param {number=} value - The value of this event.\n   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.\n   */\n  track(key: SplitIO.SplitKey, trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;\n  /**\n   * Tracks an event to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).\n   * @function track\n   * @param {string} trafficType - The traffic type of the entity related to this event.\n   * @param {string} eventType - The event type corresponding to this event.\n   * @param {number=} value - The value of this event.\n   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.\n   */\n  track(trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;\n  track(param1: string | SplitIO.SplitKey, param2: string, param3?: string | number | undefined, param4?: number | SplitIO.Properties | undefined, param5?: SplitIO.Properties | undefined): boolean {\n    const {key, trafficType, eventType, value, properties} = parseTrackParams(param1, param2, param3, param4, param5);\n    return this.getClient(key).track(trafficType, eventType, value, properties);\n  }\n\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  private getManager() {\n    const client = this.getSDKClient();\n    if (!client) {\n      console.log('[ERROR] The SDK has not being initialized. Returning default response for method call.');\n      return DEFAULT_MANAGER;\n    }\n    return this.splitManager;\n  }\n\n  /**\n   * Get the array of splits data in SplitView format.\n   * @function getSplits\n   * @returns {SplitViews} The list of SplitIO.SplitView.\n   */\n  getSplits(): SplitIO.SplitViews {\n    return this.getManager().splits();\n  }\n\n  /**\n   * Get the data of a split in SplitView format.\n   * @function getSplit\n   * @param {string} splitName The name of the split we wan't to get info of.\n   * @returns {SplitView} The SplitIO.SplitView of the given split.\n   */\n  getSplit(splitName: string): SplitIO.SplitView | null {\n    return this.getManager().split(splitName);\n  }\n\n  /**\n   * Get the array of Split names.\n   * @function getSplitNames\n   * @returns {SplitNames} The lists of Split names.\n   */\n  getSplitNames(): SplitIO.SplitNames {\n    return this.getManager().names();\n  }\n\n  /**\n   * Destroy all clients instances.\n   * @function destroy\n   * @returns {Observable<unknown>}\n   */\n  destroy(): Observable<void> {\n    const mainInstanceKey = buildInstance(this.config.core.key);\n    this.clientsMap.forEach((client, key) => {\n      if (buildInstance(key) !== mainInstanceKey){\n        client.destroy();\n        this.clientsMap.delete(buildInstance(key));\n      }\n    });\n    this.clientsMap.delete(mainInstanceKey);\n    this.splitio = undefined;\n    return from(this.splitClient.destroy());\n  }\n\n  /**\n   * Private function to return as observable the event on parameter\n   * @param {string} event\n   * @param response\n   * @returns Observable<any>\n   */\n  private toObservable(key: SplitIO.SplitKey, client: SplitIO.IClient, event: string, isOneTimeEvent = true): Observable<string> {\n    const eventKey = buildInstance(key) + event;\n    if (isOneTimeEvent) {\n      return new Observable(subscriber => {\n        const wasEventEmitted = this.emittedEvents.get(eventKey);\n        if (wasEventEmitted) {\n          Promise.resolve().then(() => subscriber.next(event));\n        } else {\n          client.once(event, () => {\n            this.emittedEvents.set(eventKey, true);\n            subscriber.next(event);\n          });\n        }\n      });\n    } else {\n      return new Observable(subscriber => {\n        client.on(event, () => {\n          subscriber.next(event);\n        });\n      });\n    }\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { CanActivate, CanActivateChild, CanLoad } from '@angular/router';\nimport { SplitService } from './splitio.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SplitioGuard implements CanActivate, CanLoad, CanActivateChild {\n\n  constructor(private splitService: SplitService) {}\n\n  canActivate(): boolean {\n    return this.splitService.isSDKReady;\n  }\n\n  canLoad(): boolean {\n    return this.splitService.isSDKReady;\n  }\n\n  canActivateChild(): boolean {\n    return this.splitService.isSDKReady;\n  }\n}\n","/*\n * Public API Surface of splitio\n */\n\nexport * from './lib/splitio.service';\nexport * from './lib/splitio.guard';\n\nexport { InLocalStorage, LocalhostFromObject, DebugLogger, InfoLogger, WarnLogger, ErrorLogger } from '@splitsoftware/splitio-browserjs';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["Observable","SplitFactory","from","Injectable"],"mappings":";;;;;;IAAA;;;IAGO,IAAM,OAAO,GAAG,SAAS,CAAC;IACjC;;;IAGO,IAAM,kBAAkB,GAAG,oBAAoB,CAAC;IACvD;;;IAGO,IAAM,iBAAiB,GAAG,mBAAmB,CAAC;IAE9C,IAAM,OAAO,GAAG,UAAU,GAAG,4BAA4B,CAAC;aAMjD,cAAQ,OAAO,OAAO,CAAC,EAAE,OACf,cAAQ,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,EAAE,OAC/D,UAAC,UAAoB;QAClC,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,UAAU,CAAC,OAAO,CAAC,UAAC,SAAS;;YAC3B,MAAM,mCAAQ,MAAM,aAAE,GAAC,SAAS,IAAG,OAAO,MAAE,CAAC;SAC9C,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC,OACwB,UAAC,UAAoB;QAC5C,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,UAAU,CAAC,OAAO,CAAC,UAAC,SAAS;;YAC3B,MAAM,mCAAQ,MAAM,aAAE,GAAC,SAAS,IAAG,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAE,CAAC;SAC3E,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC,OACM,cAAQ,OAAO,KAAK,CAAC,EAAE;IApBhC;;;IAGO,IAAM,cAAc,GAAG;QAC5B,YAAY,IAA2B;QACvC,sBAAsB,IAAwD;QAC9E,aAAa,IAMZ;QACD,uBAAuB,IAMtB;QACD,KAAK,IAAyB;KAC/B,CAAC;aAMQ,cAAQ,OAAO,EAAE,CAAC,EAAE,OACrB,cAAQ,OAAO,IAAI,CAAC,EAAE,OACtB,cAAQ,OAAO,EAAE,CAAC,EAAE;IAN7B;;;IAGO,IAAM,eAAe,GAAG;QAC7B,MAAM,IAAsB;QAC5B,KAAK,IAAwB;QAC7B,KAAK,IAAsB;KAC5B;;aC7Ce,aAAa,CAAC,GAAqB;;QAEjD,IAAI,CAAC,GAAG,CAAC,YAAY;YAAE,OAAO,GAAG,CAAC;;QAElC,OAAO,CAAG,GAAG,CAAC,WAAW,GAAG,GAAG,CAAC,WAAW,GAAG,GAAG,WAAI,GAAG,CAAC,YAAY,GAAG,GAAG,CAAC,YAAY,GAAG,GAAG,OAAG,CAAC;IACpG,CAAC;aAEe,oBAAoB,CAAC,MAA4C,EAAE,MAA2D,EAAE,MAAuC;QACrL,IAAI,QAAQ,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC;YAAE,OAAO,EAAE,GAAG,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAC,CAAC;QAC7G,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,CAAC;IACpE,CAAC;aAEe,gBAAgB,CAAC,MAAiC,EAAE,MAAc,EAAE,MAAmC,EAAE,MAA+C,EAAE,MAAsC;QAC9M,IAAI,QAAQ,CAAC,MAAM,CAAC;YAAE,OAAO,EAAE,GAAG,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAC,CAAC;QACvH,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,CAAC;IACvG,CAAC;aAEe,QAAQ,CAAC,GAAQ;QAC/B,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,YAAY,MAAM,CAAC;IAC1D;;;QCZA;;;;YAoBU,eAAU,GAAiC,IAAI,GAAG,EAA2B,CAAC;;;;YAI9E,kBAAa,GAAyB,IAAI,GAAG,EAAmB,CAAC;;;;YAIzE,eAAU,GAAG,KAAK,CAAC;SAoXpB;;;;;;;;QAhWC,2BAAI,GAAJ,UAAK,MAAgC;YAArC,iBAqBC;YApBC,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,OAAO,CAAC,GAAG,CAAC,+CAA+C,CAAC,CAAC;gBAC7D,OAAO,IAAIA,eAAU,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,KAAK,CAAC,kBAAkB,CAAC,GAAA,CAAC,CAAC;aACvE;YACD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;;YAErB,IAAI,CAAC,OAAO,GAAGC,6BAAY,CAAC,MAAM,EAAE,UAAC,OAAO;gBAC1C,OAAO,CAAC,QAAQ,CAAC,OAAO,GAAG,OAAO,CAAC;aACpC,CAAC,CAAC;YACH,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;YACzC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YAC3C,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC9B,IAAM,WAAW,GAAG,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACxD,IAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC;YAClD,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,QAAQ,EAAE;gBAC5B,KAAI,CAAC,aAAa,CAAC,GAAG,CAAC,WAAW,GAAG,QAAQ,EAAE,IAAI,CAAC,CAAC;gBACrD,KAAI,CAAC,UAAU,GAAG,IAAI,CAAC;aACxB,CAAC,CAAC;YACH,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;YACnD,OAAO,IAAI,CAAC,SAAS,CAAC;SACvB;;;;;;;QAQD,iCAAU,GAAV,UAAW,GAAqB;YAC9B,IAAI,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;YACpC,IAAI,MAAM,EAAE;gBACV,OAAO,CAAC,GAAG,CAAC,wBAAwB,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,0BAA0B,CAAC,CAAC;gBACxF,OAAO,IAAID,eAAU,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,KAAK,CAAC,kBAAkB,CAAC,GAAA,CAAC,CAAC;aACvE;YACD,IAAI,CAAC,IAAI,CAAC,OAAO;gBAAE,OAAO,IAAIA,eAAU,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAC,GAAA,CAAC,CAAC;YACxF,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAClC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC;YAChD,OAAO,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;SAC/D;QAEO,0CAAmB,GAAnB,UAAoB,GAAqB,EAAE,KAAa,EAAE,cAAqB;YAArB,+BAAA,EAAA,qBAAqB;YACrF,IAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;YACnC,IAAI,MAAM,KAAK,cAAc,EAAE;gBAC7B,OAAO,IAAIA,eAAU,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAC,GAAA,CAAC,CAAC;aACtE;YACD,OAAO,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,cAAc,CAAC,CAAC;SAC5E;;;;;;;QAQD,wCAAiB,GAAjB,UAAkB,GAAqB;YACrC,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;SACnD;;;;;;;QAQD,gDAAyB,GAAzB,UAA0B,GAAqB;YAC7C,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,qBAAqB,CAAC,CAAC;SAC7D;;;;;;;QAQD,iDAA0B,GAA1B,UAA2B,GAAqB;YAC9C,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,sBAAsB,CAAC,CAAC;SAC9D;;;;;;;QAQD,yCAAkB,GAAlB,UAAmB,GAAqB;YACtC,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;SAC3D;;;;QAKO,6CAAsB,GAAtB;YACN,IAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC;YAChC,IAAM,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC;YACrC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAC5E,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;YAC9F,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC;YAChG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;SACtF;;;;;;;QAQD,4BAAK,GAAL;YACE,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,CAAC;SACjC;QAEO,oCAAa,GAAb;YACN,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBACjB,OAAO,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC;gBACpD,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;SACb;;;;;;QAOD,mCAAY,GAAZ,UAAa,GAAsB;YACjC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;gBAAE,OAAO,SAAS,CAAC;YAC5C,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC;YACvC,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;SAChD;;;;;QAMD,oCAAa,GAAb;YACE,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;gBAAE,OAAO,SAAS,CAAC;YAC5C,OAAO,IAAI,CAAC,OAAO,CAAC;SACrB;;;;QAKO,gCAAS,GAAT,UAAU,GAAkC;YAClD,IAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;YACtC,IAAI,CAAC,MAAM,EAAE;gBACX,OAAO,CAAC,GAAG,CAAC,gBAAgB,IAAK,GAAG,GAAG,WAAW,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,+BAA+B,CAAC,CAAC;gBACjH,OAAO,cAAc,CAAC;aACvB;YACD,OAAO,MAAM,CAAC;SACf;QAmBD,mCAAY,GAAZ,UAAa,MAAiC,EAAE,MAAgD,EAAE,MAAuC;YACjI,IAAA,KAAgC,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,EAA3E,GAAG,SAAA,EAAE,UAAU,gBAAA,EAAE,UAAU,gBAAgD,CAAC;YACnF,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;SACjE;QAmBD,6CAAsB,GAAtB,UAAuB,MAAiC,EAAE,MAAgD,EAAE,MAAuC;YAC3I,IAAA,KAAgC,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,EAA3E,GAAG,SAAA,EAAE,UAAU,gBAAA,EAAE,UAAU,gBAAgD,CAAC;YACnF,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,sBAAsB,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;SAC3E;QAmBD,oCAAa,GAAb,UAAc,MAAmC,EAAE,MAAkD,EAAE,MAAuC;YACtI,IAAA,KAAgC,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,EAA3E,GAAG,SAAA,EAAE,UAAU,gBAAA,EAAE,UAAU,gBAAgD,CAAC;YACnF,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,aAAa,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;SAClE;QAmBD,8CAAuB,GAAvB,UAAwB,MAAmC,EAAE,MAAkD,EAAE,MAAuC;YAChJ,IAAA,KAAgC,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,EAA3E,GAAG,SAAA,EAAE,UAAU,gBAAA,EAAE,UAAU,gBAAgD,CAAC;YACnF,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,uBAAuB,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;SAC5E;QAuBD,4BAAK,GAAL,UAAM,MAAiC,EAAE,MAAc,EAAE,MAAoC,EAAE,MAAgD,EAAE,MAAuC;YAChL,IAAA,KAAmD,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,EAA1G,GAAG,SAAA,EAAE,WAAW,iBAAA,EAAE,SAAS,eAAA,EAAE,KAAK,WAAA,EAAE,UAAU,gBAA4D,CAAC;YAClH,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;SAC7E;;;;QAKO,iCAAU,GAAV;YACN,IAAM,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YACnC,IAAI,CAAC,MAAM,EAAE;gBACX,OAAO,CAAC,GAAG,CAAC,wFAAwF,CAAC,CAAC;gBACtG,OAAO,eAAe,CAAC;aACxB;YACD,OAAO,IAAI,CAAC,YAAY,CAAC;SAC1B;;;;;;QAOD,gCAAS,GAAT;YACE,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC,MAAM,EAAE,CAAC;SACnC;;;;;;;QAQD,+BAAQ,GAAR,UAAS,SAAiB;YACxB,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;SAC3C;;;;;;QAOD,oCAAa,GAAb;YACE,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,CAAC;SAClC;;;;;;QAOD,8BAAO,GAAP;YAAA,iBAWC;YAVC,IAAM,eAAe,GAAG,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC5D,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,GAAG;gBAClC,IAAI,aAAa,CAAC,GAAG,CAAC,KAAK,eAAe,EAAC;oBACzC,MAAM,CAAC,OAAO,EAAE,CAAC;oBACjB,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;iBAC5C;aACF,CAAC,CAAC;YACH,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;YACxC,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;YACzB,OAAOE,SAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC;SACzC;;;;;;;QAQO,mCAAY,GAAZ,UAAa,GAAqB,EAAE,MAAuB,EAAE,KAAa,EAAE,cAAqB;YAAjG,iBAqBP;YArBmF,+BAAA,EAAA,qBAAqB;YACvG,IAAM,QAAQ,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YAC5C,IAAI,cAAc,EAAE;gBAClB,OAAO,IAAIF,eAAU,CAAC,UAAA,UAAU;oBAC9B,IAAM,eAAe,GAAG,KAAI,CAAC,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;oBACzD,IAAI,eAAe,EAAE;wBACnB,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,cAAM,OAAA,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAA,CAAC,CAAC;qBACtD;yBAAM;wBACL,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE;4BACjB,KAAI,CAAC,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;4BACvC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;yBACxB,CAAC,CAAC;qBACJ;iBACF,CAAC,CAAC;aACJ;iBAAM;gBACL,OAAO,IAAIA,eAAU,CAAC,UAAA,UAAU;oBAC9B,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE;wBACf,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBACxB,CAAC,CAAC;iBACJ,CAAC,CAAC;aACJ;SACF;;;;;gBA9YFG,aAAU,SAAC;oBACV,UAAU,EAAE,MAAM;iBACnB;;;;QCAC,sBAAoB,YAA0B;YAA1B,iBAAY,GAAZ,YAAY,CAAc;SAAI;QAElD,kCAAW,GAAX;YACE,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;SACrC;QAED,8BAAO,GAAP;YACE,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;SACrC;QAED,uCAAgB,GAAhB;YACE,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;SACrC;;;;;gBAjBFA,aAAU,SAAC;oBACV,UAAU,EAAE,MAAM;iBACnB;;;gBAJQ,YAAY;;;ICFrB;;;;ICAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}