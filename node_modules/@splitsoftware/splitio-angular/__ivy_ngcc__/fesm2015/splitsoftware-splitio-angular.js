import { ɵɵdefineInjectable, Injectable, ɵɵinject } from '@angular/core';
import { SplitFactory } from '@splitsoftware/splitio-browserjs';
import * as ɵngcc0 from '@angular/core';
export { DebugLogger, ErrorLogger, InLocalStorage, InfoLogger, LocalhostFromObject, WarnLogger } from '@splitsoftware/splitio-browserjs';
import { Observable, from } from 'rxjs';

/**
 * SDK constant for control treatment
 */
const CONTROL = 'control';
/**
 * string constant for observable to return when client exists for a key
 */
const INIT_CLIENT_EXISTS = 'init::clientExists';
/**
 * string constant for observable to return when client is not initialized
 */
const INIT_CLIENT_FIRST = 'init::clientFirst';
const VERSION = 'angular-' + '0.3.0';
const ɵ0 = () => { return CONTROL; }, ɵ1 = () => { return { treatment: CONTROL, config: null }; }, ɵ2 = (splitNames) => {
    let result = {};
    splitNames.forEach((splitName) => {
        result = Object.assign(Object.assign({}, result), { [splitName]: CONTROL });
    });
    return result;
}, ɵ3 = (splitNames) => {
    let result = {};
    splitNames.forEach((splitName) => {
        result = Object.assign(Object.assign({}, result), { [splitName]: { treatment: CONTROL, config: null } });
    });
    return result;
}, ɵ4 = () => { return false; };
/**
 * client with methods that return default values
 */
const CONTROL_CLIENT = {
    getTreatment: ɵ0,
    getTreatmentWithConfig: ɵ1,
    getTreatments: ɵ2,
    getTreatmentsWithConfig: ɵ3,
    track: ɵ4
};
const ɵ5 = () => { return []; }, ɵ6 = () => { return null; }, ɵ7 = () => { return []; };
/**
 *  with methods that return default values
 */
const DEFAULT_MANAGER = {
    splits: ɵ5,
    split: ɵ6,
    names: ɵ7
};

function buildInstance(key) {
    // @ts-ignore
    if (!key.bucketingKey)
        return key;
    // @ts-ignore
    return `${key.matchingKey ? key.matchingKey : key}-${key.bucketingKey ? key.bucketingKey : key}-`;
}
function parseTreatmentParams(param1, param2, param3) {
    if (isString(param2) || Array.isArray(param2))
        return { key: param1, splitNames: param2, attributes: param3 };
    return { key: undefined, splitNames: param1, attributes: param2 };
}
function parseTrackParams(param1, param2, param3, param4, param5) {
    if (isString(param3))
        return { key: param1, trafficType: param2, eventType: param3, value: param4, properties: param5 };
    return { key: undefined, trafficType: param1, eventType: param2, value: param3, properties: param4 };
}
function isString(val) {
    return typeof val === 'string' || val instanceof String;
}

class SplitService {
    constructor() {
        /**
         * Map of intialized clients
         */
        this.clientsMap = new Map();
        /**
         * Map of events status of intialized clients
         */
        this.emittedEvents = new Map();
        /**
         * Flag to determine if SDK is ready or not.
         */
        this.isSDKReady = false;
    }
    /**
     * This method initializes the SDK with the required Browser APIKEY
     * and the 'key' according to the Traffic type set (ex.: an user id).
     * @function init
     * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.
     * @returns {Observable<string>} Returns when sdk is ready
     */
    init(config) {
        if (this.splitio) {
            console.log('[ERROR] There is another instance of the SDK.');
            return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));
        }
        this.config = config;
        // @ts-ignore. 2nd param is not part of type definitions. Used to overwrite the version of the SDK for correct tracking.
        this.splitio = SplitFactory(config, (modules) => {
            modules.settings.version = VERSION;
        });
        this.splitClient = this.splitio.client();
        this.splitManager = this.splitio.manager();
        this.sdkInitEventObservable();
        const instanceKey = buildInstance(this.config.core.key);
        const sdkReady = this.splitClient.Event.SDK_READY;
        this.splitClient.on(sdkReady, () => {
            this.emittedEvents.set(instanceKey + sdkReady, true);
            this.isSDKReady = true;
        });
        this.clientsMap.set(instanceKey, this.splitClient);
        return this.sdkReady$;
    }
    /**
     * Returns a shared client of the SDK, associated with the given key
     * @function initClient
     * @param {SplitKey} key The key for the new client instance.
     * @returns {Observable<string>} Returns when sdk is ready
     */
    initClient(key) {
        let client = this.getSDKClient(key);
        if (client) {
            console.log('[WARN] client for key ' + buildInstance(key) + ' is already initialized.');
            return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));
        }
        if (!this.splitio)
            return new Observable(observer => observer.error(INIT_CLIENT_FIRST));
        client = this.splitio.client(key);
        this.clientsMap.set(buildInstance(key), client);
        return this.toObservable(key, client, client.Event.SDK_READY);
    }
    getClientObservable(key, event, isOneTimeEvent = true) {
        const client = this.getClient(key);
        if (client === CONTROL_CLIENT) {
            return new Observable(observer => observer.error(INIT_CLIENT_FIRST));
        }
        return this.toObservable(key, client, client.Event[event], isOneTimeEvent);
    }
    /**
     * Returns an observable that calls back when the client is ready
     * @function getClientSDKReady
     * @param {SplitKey} key The key for the client instance.
     * @returns {Observable<string>}
     */
    getClientSDKReady(key) {
        return this.getClientObservable(key, 'SDK_READY');
    }
    /**
     * Returns an observable that calls back when the client ready event is timed out
     * @function getClientSDKReadyTimedOut
     * @param {SplitKey} key The key for the client instance.
     * @returns {Observable<string>}
     */
    getClientSDKReadyTimedOut(key) {
        return this.getClientObservable(key, 'SDK_READY_TIMED_OUT');
    }
    /**
     * Returns an observable that calls back when the client is ready from cache
     * @function getClientSDKReadyFromCache
     * @param {SplitKey} key The key for the client instance.
     * @returns {Observable<string>}
     */
    getClientSDKReadyFromCache(key) {
        return this.getClientObservable(key, 'SDK_READY_FROM_CACHE');
    }
    /**
     * Returns an observable that calls back when the client is updated
     * @function getClientSDKUpdate
     * @param {SplitKey} key The key for the client instance.
     * @returns {Observable<string>}
     */
    getClientSDKUpdate(key) {
        return this.getClientObservable(key, 'SDK_UPDATE', false);
    }
    /**
     * initialize sdk Events into observables
     */
    sdkInitEventObservable() {
        const client = this.splitClient;
        const mainKey = this.config.core.key;
        this.sdkReady$ = this.toObservable(mainKey, client, client.Event.SDK_READY);
        this.sdkReadyTimedOut$ = this.toObservable(mainKey, client, client.Event.SDK_READY_TIMED_OUT);
        this.sdkReadyFromCache$ = this.toObservable(mainKey, client, client.Event.SDK_READY_FROM_CACHE);
        this.sdkUpdate$ = this.toObservable(mainKey, client, client.Event.SDK_UPDATE, false);
    }
    /**
     * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).
     * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,
     * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.
     * @returns Promise<void>
     */
    ready() {
        return this.getClient().ready();
    }
    isInitialized() {
        if (!this.splitio) {
            console.log('[ERROR] plugin should be initialized');
            return false;
        }
        return true;
    }
    /**
     * Returns the SDK client
     * @param {SplitKey=} key The key for the client instance.
     * @returns {IClient} split client.
     */
    getSDKClient(key) {
        if (!this.isInitialized())
            return undefined;
        key = key ? key : this.config.core.key;
        return this.clientsMap.get(buildInstance(key));
    }
    /**
     * Returns the SDK factory
     * @returns {ISDK} split factory
     */
    getSDKFactory() {
        if (!this.isInitialized())
            return undefined;
        return this.splitio;
    }
    /**
     * Validates key and returns client if it is initialized for key or controlClient if it isn't
     */
    getClient(key) {
        const client = this.getSDKClient(key);
        if (!client) {
            console.log('[ERROR] client' + (key ? ' for key ' + buildInstance(key) : '') + ' should be initialized first.');
            return CONTROL_CLIENT;
        }
        return client;
    }
    getTreatment(param1, param2, param3) {
        const { key, splitNames, attributes } = parseTreatmentParams(param1, param2, param3);
        return this.getClient(key).getTreatment(splitNames, attributes);
    }
    getTreatmentWithConfig(param1, param2, param3) {
        const { key, splitNames, attributes } = parseTreatmentParams(param1, param2, param3);
        return this.getClient(key).getTreatmentWithConfig(splitNames, attributes);
    }
    getTreatments(param1, param2, param3) {
        const { key, splitNames, attributes } = parseTreatmentParams(param1, param2, param3);
        return this.getClient(key).getTreatments(splitNames, attributes);
    }
    getTreatmentsWithConfig(param1, param2, param3) {
        const { key, splitNames, attributes } = parseTreatmentParams(param1, param2, param3);
        return this.getClient(key).getTreatmentsWithConfig(splitNames, attributes);
    }
    track(param1, param2, param3, param4, param5) {
        const { key, trafficType, eventType, value, properties } = parseTrackParams(param1, param2, param3, param4, param5);
        return this.getClient(key).track(trafficType, eventType, value, properties);
    }
    /**
     * Validates key and returns client if it is initialized for key or controlClient if it isn't
     */
    getManager() {
        const client = this.getSDKClient();
        if (!client) {
            console.log('[ERROR] The SDK has not being initialized. Returning default response for method call.');
            return DEFAULT_MANAGER;
        }
        return this.splitManager;
    }
    /**
     * Get the array of splits data in SplitView format.
     * @function getSplits
     * @returns {SplitViews} The list of SplitIO.SplitView.
     */
    getSplits() {
        return this.getManager().splits();
    }
    /**
     * Get the data of a split in SplitView format.
     * @function getSplit
     * @param {string} splitName The name of the split we wan't to get info of.
     * @returns {SplitView} The SplitIO.SplitView of the given split.
     */
    getSplit(splitName) {
        return this.getManager().split(splitName);
    }
    /**
     * Get the array of Split names.
     * @function getSplitNames
     * @returns {SplitNames} The lists of Split names.
     */
    getSplitNames() {
        return this.getManager().names();
    }
    /**
     * Destroy all clients instances.
     * @function destroy
     * @returns {Observable<unknown>}
     */
    destroy() {
        const mainInstanceKey = buildInstance(this.config.core.key);
        this.clientsMap.forEach((client, key) => {
            if (buildInstance(key) !== mainInstanceKey) {
                client.destroy();
                this.clientsMap.delete(buildInstance(key));
            }
        });
        this.clientsMap.delete(mainInstanceKey);
        this.splitio = undefined;
        return from(this.splitClient.destroy());
    }
    /**
     * Private function to return as observable the event on parameter
     * @param {string} event
     * @param response
     * @returns Observable<any>
     */
    toObservable(key, client, event, isOneTimeEvent = true) {
        const eventKey = buildInstance(key) + event;
        if (isOneTimeEvent) {
            return new Observable(subscriber => {
                const wasEventEmitted = this.emittedEvents.get(eventKey);
                if (wasEventEmitted) {
                    Promise.resolve().then(() => subscriber.next(event));
                }
                else {
                    client.once(event, () => {
                        this.emittedEvents.set(eventKey, true);
                        subscriber.next(event);
                    });
                }
            });
        }
        else {
            return new Observable(subscriber => {
                client.on(event, () => {
                    subscriber.next(event);
                });
            });
        }
    }
}
SplitService.ɵfac = function SplitService_Factory(t) { return new (t || SplitService)(); };
SplitService.ɵprov = ɵɵdefineInjectable({ factory: function SplitService_Factory() { return new SplitService(); }, token: SplitService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

class SplitioGuard {
    constructor(splitService) {
        this.splitService = splitService;
    }
    canActivate() {
        return this.splitService.isSDKReady;
    }
    canLoad() {
        return this.splitService.isSDKReady;
    }
    canActivateChild() {
        return this.splitService.isSDKReady;
    }
}
SplitioGuard.ɵfac = function SplitioGuard_Factory(t) { return new (t || SplitioGuard)(ɵngcc0.ɵɵinject(SplitService)); };
SplitioGuard.ɵprov = ɵɵdefineInjectable({ factory: function SplitioGuard_Factory() { return new SplitioGuard(ɵɵinject(SplitService)); }, token: SplitioGuard, providedIn: "root" });
SplitioGuard.ctorParameters = () => [
    { type: SplitService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitioGuard, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: SplitService }]; }, null); })();

/*
 * Public API Surface of splitio
 */

/**
 * Generated bundle index. Do not edit.
 */

export { SplitService, SplitioGuard };

//# sourceMappingURL=splitsoftware-splitio-angular.js.map