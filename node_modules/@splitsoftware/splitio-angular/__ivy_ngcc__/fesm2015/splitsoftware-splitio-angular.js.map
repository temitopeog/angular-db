{"version":3,"file":"splitsoftware-splitio-angular.js","sources":["../../projects/splitio/src/lib/utils/constants.ts","../../projects/splitio/src/lib/utils/utils.ts","../../projects/splitio/src/lib/splitio.service.ts","../../projects/splitio/src/lib/splitio.guard.ts","../../projects/splitio/src/public-api.ts","../../projects/splitio/src/splitsoftware-splitio-angular.ts"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACO,MAAM,OAAO,GAAG,SAAS,CAAC;AACjC;AACA;AACA;AACO,MAAM,kBAAkB,GAAG,oBAAoB,CAAC;AACvD;AACA;AACA;AACO,MAAM,iBAAiB,GAAG,mBAAmB,CAAC;AAE9C,MAAM,OAAO,GAAG,UAAU,GAAG;AAAS,mBAAmB,CAAC,TAMjD,QAAQ,OAAO,OAAO,CAAC,EAAE,OACf,QAAQ,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,EAAE,OAC/D,CAAC,UAAoB;AACtC,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS;AACjC,QAAM,MAAM,mCAAQ,MAAM,KAAE,CAAC,SAAS,GAAG,OAAO,GAAE,CAAC;AACnD,KAAK,CAAC,CAAC;AACP,IAAI,OAAO,MAAM,CAAC;AAChB,CAAC,OACwB,CAAC,UAAoB;AAChD,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS;AACjC,QAAM,MAAM,mCAAQ,MAAM,KAAE,CAAC,SAAS,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,GAAE,CAAC;AAChF,KAAK,CAAC,CAAC;AACP,IAAI,OAAO,MAAM,CAAC;AAChB,CAAC,OACM,QAAQ,OAAO,KAAK,CAAC,EAAE;AApBhC;AACA;AACA;AACO,MAAM,cAAc,GAAG;AAC9B,IAAE,YAAY,IAA2B;AACzC,IAAE,sBAAsB,IAAwD;AAChF,IAAE,aAAa,IAMZ;AACH,IAAE,uBAAuB,IAMtB;AACH,IAAE,KAAK,IAAyB;AAChC,CAAC,CAAC;AACF,WAKU,QAAQ,OAAO,EAAE,CAAC,EAAE,OACrB,QAAQ,OAAO,IAAI,CAAC,EAAE,OACtB,QAAQ,OAAO,EAAE,CAAC,EAAE;AAN7B;AACA;AACA;AACO,MAAM,eAAe,GAAG;AAC/B,IAAE,MAAM,IAAsB;AAC9B,IAAE,KAAK,IAAwB;AAC/B,IAAE,KAAK,IAAsB;AAC7B,CAAC;AACD;AAAC,SC9Ce,aAAa,CAAC,GAAqB;AAAI;AAC7C,IACR,IAAI,CAAC,GAAG,CAAC,YAAY;AAAE,QAAA,OAAO,GAAG,CAAC;AACpC;AACE,IAAA,OAAO,GAAG,GAAG,CAAC,WAAW,GAAG,GAAG,CAAC,WAAW,GAAG,GAAG,IAAI,GAAG,CAAC,YAAY,GAAG,GAAG,CAAC,YAAY,GAAG,GAAG,GAAG,CAAC;AACpG,CAAC;AACD,SACgB,oBAAoB,CAAC,MAA4C,EAAE,MAA2D,EAAE,MAAuC;AAAI,IACzL,IAAI,QAAQ,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC;AAAE,QAAA,OAAO,EAAE,GAAG,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAC,CAAC;AAC/G,IAAE,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,CAAC;AACpE,CAAC;AACD,SACgB,gBAAgB,CAAC,MAAiC,EAAE,MAAc,EAAE,MAAmC,EAAE,MAA+C,EAAE,MAAsC;AAChN,IAAE,IAAI,QAAQ,CAAC,MAAM,CAAC;AAAE,QAAA,OAAO,EAAE,GAAG,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAC,CAAC;AACzH,IAAE,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,CAAC;AACvG,CAAC;AACD,SACgB,QAAQ,CAAC,GAAQ;AAAI,IACnC,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,YAAY,MAAM,CAAC;AAC1D;AACA;AAAC,MCVY,YAAY;AACzB,IAJA;AACE;AAAY;AAEa;AAGvB,QAcM,eAAU,GAAiC,IAAI,GAAG,EAA2B,CAAC;AACxF;AACM;AAEA;AAAY,QAAR,kBAAa,GAAyB,IAAI,GAAG,EAAmB,CAAC;AAC3E;AACM;AAEA;AAAY,QAAhB,eAAU,GAAG,KAAK,CAAC;AACrB,KAmXC;AACD;AAAQ;AAAwE;AAA0E;AAAsB;AAA6G;AAA+D;AAAQ,IAjWlW,IAAI,CAAC,MAAgC;AAAI,QACvC,IAAI,IAAI,CAAC,OAAO,EAAE;AACtB,YAAM,OAAO,CAAC,GAAG,CAAC,+CAA+C,CAAC,CAAC;AACnE,YAAM,OAAO,IAAI,UAAU,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC,CAAC;AAC5E,SAAK;AACL,QAAI,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACzB;AACI,QAAA,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,OAAO;AAChD,YAAM,OAAO,CAAC,QAAQ,CAAC,OAAO,GAAG,OAAO,CAAC;AACzC,SAAK,CAAC,CAAC;AACP,QAAI,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;AAC7C,QAAI,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;AAC/C,QAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;AAClC,QAAI,MAAM,WAAW,GAAG,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5D,QAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC;AACtD,QAAI,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,QAAQ,EAAE;AAClC,YAAM,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,WAAW,GAAG,QAAQ,EAAE,IAAI,CAAC,CAAC;AAC3D,YAAM,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;AAC7B,SAAK,CAAC,CAAC;AACP,QAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;AACvD,QAAI,OAAO,IAAI,CAAC,SAAS,CAAC;AAC1B,KAAG;AACH;AAEC;AACE;AACE;AACE;AAEJ;AAAQ,IAAT,UAAU,CAAC,GAAqB;AAAI,QAClC,IAAI,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;AACxC,QAAI,IAAI,MAAM,EAAE;AAChB,YAAM,OAAO,CAAC,GAAG,CAAC,wBAAwB,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,0BAA0B,CAAC,CAAC;AAC9F,YAAM,OAAO,IAAI,UAAU,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC,CAAC;AAC5E,SAAK;AACL,QAAI,IAAI,CAAC,IAAI,CAAC,OAAO;AAAE,YAAA,OAAO,IAAI,UAAU,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;AAC5F,QAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACtC,QAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC;AACpD,QAAI,OAAO,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AAClE,KAAG;AACH,IACU,mBAAmB,CAAC,GAAqB,EAAE,KAAa,EAAE,cAAc,GAAG,IAAI;AAAI,QACzF,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;AACvC,QAAI,IAAI,MAAM,KAAK,cAAc,EAAE;AACnC,YAAM,OAAO,IAAI,UAAU,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;AAC3E,SAAK;AACL,QAAI,OAAO,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,cAAc,CAAC,CAAC;AAC/E,KAAG;AACH;AAEC;AACE;AACE;AACE;AAEJ;AAAQ,IAAT,iBAAiB,CAAC,GAAqB;AAAI,QACzC,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;AACtD,KAAG;AACH;AAEC;AACE;AACE;AACE;AAEJ;AAAQ,IAAT,yBAAyB,CAAC,GAAqB;AAAI,QACjD,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,qBAAqB,CAAC,CAAC;AAChE,KAAG;AACH;AAEC;AACE;AACE;AACE;AAEJ;AAAQ,IAAT,0BAA0B,CAAC,GAAqB;AAAI,QAClD,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,sBAAsB,CAAC,CAAC;AACjE,KAAG;AACH;AAEC;AACE;AACE;AACE;AAEJ;AAAQ,IAAT,kBAAkB,CAAC,GAAqB;AAAI,QAC1C,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;AAC9D,KAAG;AACH;AAEC;AACE;AACE,IAAK,sBAAsB;AAAK,QACjC,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC;AACpC,QAAI,MAAM,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC;AACzC,QAAI,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AAChF,QAAI,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;AAClG,QAAI,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC;AACpG,QAAI,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;AACzF,KAAG;AACH;AAEC;AACE;AACE;AACE;AAEJ;AAAQ,IAAT,KAAK;AAAK,QACR,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,CAAC;AACpC,KAAG;AACH,IACU,aAAa;AAAK,QACxB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;AACvB,YAAM,OAAO,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC;AAC1D,YAAM,OAAO,KAAK,CAAC;AACnB,SAAK;AACL,QAAI,OAAO,IAAI,CAAC;AAChB,KAAG;AACH;AAEC;AACE;AACE;AAEJ;AAAQ,IAAP,YAAY,CAAC,GAAsB;AAAI,QACrC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;AAAE,YAAA,OAAO,SAAS,CAAC;AAChD,QAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC;AAC3C,QAAI,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;AACnD,KAAG;AACH;AAEC;AACE;AACE;AACE,IAAL,aAAa;AAAK,QAChB,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;AAAE,YAAA,OAAO,SAAS,CAAC;AAChD,QAAI,OAAO,IAAI,CAAC,OAAO,CAAC;AACxB,KAAG;AACH;AAEC;AACE;AACE,IAAK,SAAS,CAAC,GAAkC;AAAI,QACtD,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;AAC1C,QAAI,IAAI,CAAC,MAAM,EAAE;AACjB,YAAM,OAAO,CAAC,GAAG,CAAC,gBAAgB,IAAK,GAAG,GAAG,WAAW,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,+BAA+B,CAAC,CAAC;AACvH,YAAM,OAAO,cAAc,CAAC;AAC5B,SAAK;AACL,QAAI,OAAO,MAAM,CAAC;AAClB,KAAG;AACH,IAkBE,YAAY,CAAC,MAAiC,EAAE,MAAgD,EAAE,MAAuC;AAAI,QAC3I,MAAM,EAAC,GAAG,EAAE,UAAU,EAAE,UAAU,EAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AACvF,QAAI,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AACpE,KAAG;AACH,IAkBE,sBAAsB,CAAC,MAAiC,EAAE,MAAgD,EAAE,MAAuC;AAAI,QACrJ,MAAM,EAAC,GAAG,EAAE,UAAU,EAAE,UAAU,EAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AACvF,QAAI,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,sBAAsB,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AAC9E,KAAG;AACH,IAkBE,aAAa,CAAC,MAAmC,EAAE,MAAkD,EAAE,MAAuC;AAAI,QAChJ,MAAM,EAAC,GAAG,EAAE,UAAU,EAAE,UAAU,EAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AACvF,QAAI,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,aAAa,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AACrE,KAAG;AACH,IAkBE,uBAAuB,CAAC,MAAmC,EAAE,MAAkD,EAAE,MAAuC;AAAI,QAC1J,MAAM,EAAC,GAAG,EAAE,UAAU,EAAE,UAAU,EAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AACvF,QAAI,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,uBAAuB,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AAC/E,KAAG;AACH,IAsBE,KAAK,CAAC,MAAiC,EAAE,MAAc,EAAE,MAAoC,EAAE,MAAgD,EAAE,MAAuC;AAAI,QAC1L,MAAM,EAAC,GAAG,EAAE,WAAW,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AACtH,QAAI,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;AAChF,KAAG;AACH;AAEC;AACE;AACE,IAAK,UAAU;AACpB,QAAI,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;AACvC,QAAI,IAAI,CAAC,MAAM,EAAE;AACjB,YAAM,OAAO,CAAC,GAAG,CAAC,wFAAwF,CAAC,CAAC;AAC5G,YAAM,OAAO,eAAe,CAAC;AAC7B,SAAK;AACL,QAAI,OAAO,IAAI,CAAC,YAAY,CAAC;AAC7B,KAAG;AACH;AAEC;AACE;AACE;AAEJ;AAAQ,IAAP,SAAS;AAAK,QACZ,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC,MAAM,EAAE,CAAC;AACtC,KAAG;AACH;AAEC;AACE;AACE;AACE;AAEJ;AAAQ,IAAT,QAAQ,CAAC,SAAiB;AAAI,QAC5B,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AAC9C,KAAG;AACH;AAEC;AACE;AACE;AAEJ;AAAQ,IAAP,aAAa;AAAK,QAChB,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,CAAC;AACrC,KAAG;AACH;AAEC;AACE;AACE;AAEJ;AAAQ,IAAP,OAAO;AAAK,QACV,MAAM,eAAe,GAAG,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChE,QAAI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,GAAG;AACxC,YAAM,IAAI,aAAa,CAAC,GAAG,CAAC,KAAK,eAAe,EAAC;AACjD,gBAAQ,MAAM,CAAC,OAAO,EAAE,CAAC;AACzB,gBAAQ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;AACnD,aAAO;AACP,SAAK,CAAC,CAAC;AACP,QAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;AAC5C,QAAI,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;AAC7B,QAAI,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,CAAC;AAC5C,KAAG;AACH;AAEC;AACE;AACE;AACE;AAEJ;AAAQ,IAAD,YAAY,CAAC,GAAqB,EAAE,MAAuB,EAAE,KAAa,EAAE,cAAc,GAAG,IAAI;AAAI,QAC3G,MAAM,QAAQ,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;AAChD,QAAI,IAAI,cAAc,EAAE;AACxB,YAAM,OAAO,IAAI,UAAU,CAAC,UAAU;AACtC,gBAAQ,MAAM,eAAe,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AACjE,gBAAQ,IAAI,eAAe,EAAE;AAC7B,oBAAU,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,MAAM,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;AAC/D,iBAAS;AAAC,qBAAK;AACf,oBAAU,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE;AAC7B,wBAAY,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AACnD,wBAAY,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACnC,qBAAW,CAAC,CAAC;AACb,iBAAS;AACT,aAAO,CAAC,CAAC;AACT,SAAK;AAAC,aAAK;AACX,YAAM,OAAO,IAAI,UAAU,CAAC,UAAU;AACtC,gBAAQ,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE;AACzB,oBAAU,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACjC,iBAAS,CAAC,CAAC;AACX,aAAO,CAAC,CAAC;AACT,SAAK;AACL,KAAG;AACH;2FACA;AAAC;wCAhZA,UAAU,SAAC,kBACV,UAAU,EAAE,MAAM;CACnB;;;;gDACI;AAAC;AAAC,MCHM,YAAY;AAAG,IAE1B,YAAoB,YAA0B;AAAI,QAA9B,iBAAY,GAAZ,YAAY,CAAc;AAAC,KAAG;AACpD,IACE,WAAW;AAAK,QACd,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;AACxC,KAAG;AACH,IACE,OAAO;AAAK,QACV,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;AACxC,KAAG;AACH,IACE,gBAAgB;AAAK,QACnB,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;AACxC,KAAG;AACH;wHAAC;AACD,oLAhBK;AAAC;EAHL,UAAU,SAAC,rBAGgC,YALnC,YAAY;AAAG;SAGtB,UAAU,EAAE,MAAM,cACnB;;;;;sEAJyB;AAAC;ACF3B;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;AACA;AACS","sourcesContent":["/**\n * SDK constant for control treatment\n */\nexport const CONTROL = 'control';\n/**\n * string constant for observable to return when client exists for a key\n */\nexport const INIT_CLIENT_EXISTS = 'init::clientExists';\n/**\n * string constant for observable to return when client is not initialized\n */\nexport const INIT_CLIENT_FIRST = 'init::clientFirst';\n\nexport const VERSION = 'angular-' + 'ANGULAR_SDK_VERSION_NUMBER';\n\n/**\n * client with methods that return default values\n */\nexport const CONTROL_CLIENT = {\n  getTreatment: () => { return CONTROL; },\n  getTreatmentWithConfig: () => { return { treatment: CONTROL, config: null }; },\n  getTreatments: (splitNames: string[]) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n      result = { ...result, [splitName]: CONTROL };\n    });\n    return result;\n  },\n  getTreatmentsWithConfig: (splitNames: string[]) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n      result = { ...result, [splitName]: { treatment: CONTROL, config: null } };\n    });\n    return result;\n  },\n  track: () => { return false; }\n};\n\n/**\n *  with methods that return default values\n */\nexport const DEFAULT_MANAGER = {\n  splits: () => { return []; },\n  split: () => { return null; },\n  names: () => { return []; }\n};\n","export function buildInstance(key: SplitIO.SplitKey): string {\n  // @ts-ignore\n  if (!key.bucketingKey) return key;\n  // @ts-ignore\n  return `${key.matchingKey ? key.matchingKey : key}-${key.bucketingKey ? key.bucketingKey : key}-`;\n}\n\nexport function parseTreatmentParams(param1: string | string[] | SplitIO.SplitKey, param2?: string | string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): any {\n  if (isString(param2) || Array.isArray(param2)) return { key: param1, splitNames: param2, attributes: param3};\n  return { key: undefined, splitNames: param1, attributes: param2 };\n}\n\nexport function parseTrackParams(param1: string | SplitIO.SplitKey, param2: string, param3: number | string | undefined, param4: number | SplitIO.Properties | undefined, param5: SplitIO.Properties | undefined) {\n  if (isString(param3)) return { key: param1, trafficType: param2, eventType: param3, value: param4, properties: param5};\n  return { key: undefined, trafficType: param1, eventType: param2, value: param3, properties: param4 };\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === 'string' || val instanceof String;\n}\n","import { Injectable } from '@angular/core';\nimport { SplitFactory } from '@splitsoftware/splitio-browserjs';\nimport * as SplitIO from '@splitsoftware/splitio-browserjs/types/splitio';\nimport { from, Observable } from 'rxjs';\nimport { INIT_CLIENT_EXISTS, INIT_CLIENT_FIRST, CONTROL_CLIENT, DEFAULT_MANAGER, VERSION } from './utils/constants';\nimport { buildInstance, parseTrackParams, parseTreatmentParams } from './utils/utils';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SplitService {\n\n  /**\n   * The local reference to the Split SDK.\n   */\n  private splitio: SplitIO.ISDK | undefined;\n  /**\n   * The local reference to the Split SDK's Client.\n   */\n  private splitClient: SplitIO.IClient;\n  /**\n   * The local reference to the Split SDK's Manager.\n   */\n  private splitManager: SplitIO.IManager;\n  /**\n   * Map of intialized clients\n   */\n  private clientsMap: Map<string, SplitIO.IClient> = new Map<string, SplitIO.IClient>();\n  /**\n   * Map of events status of intialized clients\n   */\n  private emittedEvents: Map<string, boolean> = new Map<string, boolean>();\n  /**\n   * Flag to determine if SDK is ready or not.\n   */\n  isSDKReady = false;\n  /**\n   * Factory config\n   */\n  private config: SplitIO.IBrowserSettings;\n  /**\n   * SDK events observables\n   */\n  sdkReady$: Observable<string>;\n  sdkReadyTimedOut$: Observable<string>;\n  sdkReadyFromCache$: Observable<string>;\n  sdkUpdate$: Observable<string>;\n\n  /**\n   * This method initializes the SDK with the required Browser APIKEY\n   * and the 'key' according to the Traffic type set (ex.: an user id).\n   * @function init\n   * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  init(config: SplitIO.IBrowserSettings): Observable<string> {\n    if (this.splitio) {\n      console.log('[ERROR] There is another instance of the SDK.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    this.config = config;\n    // @ts-ignore. 2nd param is not part of type definitions. Used to overwrite the version of the SDK for correct tracking.\n    this.splitio = SplitFactory(config, (modules) => {\n      modules.settings.version = VERSION;\n    });\n    this.splitClient = this.splitio.client();\n    this.splitManager = this.splitio.manager();\n    this.sdkInitEventObservable();\n    const instanceKey = buildInstance(this.config.core.key);\n    const sdkReady = this.splitClient.Event.SDK_READY;\n    this.splitClient.on(sdkReady, () => {\n      this.emittedEvents.set(instanceKey + sdkReady, true);\n      this.isSDKReady = true;\n    });\n    this.clientsMap.set(instanceKey, this.splitClient);\n    return this.sdkReady$;\n  }\n\n  /**\n   * Returns a shared client of the SDK, associated with the given key\n   * @function initClient\n   * @param {SplitKey} key The key for the new client instance.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  initClient(key: SplitIO.SplitKey): Observable<string> {\n    let client = this.getSDKClient(key);\n    if (client) {\n      console.log('[WARN] client for key ' + buildInstance(key) + ' is already initialized.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    if (!this.splitio) return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    client = this.splitio.client(key);\n    this.clientsMap.set(buildInstance(key), client);\n    return this.toObservable(key, client, client.Event.SDK_READY);\n  }\n\n  private getClientObservable(key: SplitIO.SplitKey, event: string, isOneTimeEvent = true): Observable<string> {\n    const client = this.getClient(key);\n    if (client === CONTROL_CLIENT) {\n      return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    }\n    return this.toObservable(key, client, client.Event[event], isOneTimeEvent);\n  }\n\n  /**\n   * Returns an observable that calls back when the client is ready\n   * @function getClientSDKReady\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReady(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY');\n  }\n\n  /**\n   * Returns an observable that calls back when the client ready event is timed out\n   * @function getClientSDKReadyTimedOut\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyTimedOut(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY_TIMED_OUT');\n  }\n\n  /**\n   * Returns an observable that calls back when the client is ready from cache\n   * @function getClientSDKReadyFromCache\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyFromCache(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY_FROM_CACHE');\n  }\n\n  /**\n   * Returns an observable that calls back when the client is updated\n   * @function getClientSDKUpdate\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKUpdate(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_UPDATE', false);\n  }\n\n  /**\n   * initialize sdk Events into observables\n   */\n  private sdkInitEventObservable(): void {\n    const client = this.splitClient;\n    const mainKey = this.config.core.key;\n    this.sdkReady$ = this.toObservable(mainKey, client, client.Event.SDK_READY);\n    this.sdkReadyTimedOut$ = this.toObservable(mainKey, client, client.Event.SDK_READY_TIMED_OUT);\n    this.sdkReadyFromCache$ = this.toObservable(mainKey, client, client.Event.SDK_READY_FROM_CACHE);\n    this.sdkUpdate$ = this.toObservable(mainKey, client, client.Event.SDK_UPDATE, false);\n  }\n\n  /**\n   * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).\n   * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,\n   * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.\n   * @returns Promise<void>\n   */\n  ready(): Promise<void> {\n    return this.getClient().ready();\n  }\n\n  private isInitialized(): boolean {\n    if (!this.splitio) {\n      console.log('[ERROR] plugin should be initialized');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the SDK client\n   * @param {SplitKey=} key The key for the client instance.\n   * @returns {IClient} split client.\n   */\n  getSDKClient(key?: SplitIO.SplitKey): SplitIO.IClient | undefined {\n    if (!this.isInitialized()) return undefined;\n    key = key ? key : this.config.core.key;\n    return this.clientsMap.get(buildInstance(key));\n  }\n\n  /**\n   * Returns the SDK factory\n   * @returns {ISDK} split factory\n   */\n  getSDKFactory(): SplitIO.ISDK | undefined {\n    if (!this.isInitialized()) return undefined;\n    return this.splitio;\n  }\n\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  private getClient(key?: SplitIO.SplitKey | undefined): any {\n    const client = this.getSDKClient(key);\n    if (!client) {\n      console.log('[ERROR] client' + ( key ? ' for key ' + buildInstance(key) : '') + ' should be initialized first.');\n      return CONTROL_CLIENT;\n    }\n    return client;\n  }\n\n  /**\n   * Returns a Treatment value, which is the treatment string for the given feature.\n   * @function getTreatment\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatment} - The treatment string.\n   */\n  getTreatment(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;\n  /**\n   * Returns a Treatment value, which is the treatment string for the given feature.\n   * @function getTreatment\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatment} - The treatment string.\n   */\n  getTreatment(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;\n  getTreatment(param1: string | SplitIO.SplitKey, param2?: string | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.Treatment {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatment(splitNames, attributes);\n  }\n\n  /**\n   * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.\n   * @function getTreatmentWithConfig\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).\n   */\n  getTreatmentWithConfig(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;\n  /**\n   * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.\n   * @function getTreatmentWithConfig\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).\n   */\n  getTreatmentWithConfig(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;\n  getTreatmentWithConfig(param1: string | SplitIO.SplitKey, param2?: string | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentWithConfig(splitNames, attributes);\n  }\n\n  /**\n   * Returns a Treatments value, which is an object map with the treatments for the given features.\n   * @function getTreatments\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatments} - The treatments object map.\n   */\n  getTreatments(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;\n  /**\n   * Returns a Treatments value, which is an object map with the treatments for the given features.\n   * @function getTreatments\\\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatments} - The treatments object map.\n   */\n  getTreatments(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;\n  getTreatments(param1: string[] | SplitIO.SplitKey, param2?: string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.Treatments {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatments(splitNames, attributes);\n  }\n\n  /**\n   * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.\n   * @function getTreatmentsWithConfig\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects\n   */\n  getTreatmentsWithConfig(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;\n  /**\n   * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.\n   * @function getTreatmentsWithConfig\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects\n   */\n  getTreatmentsWithConfig(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;\n  getTreatmentsWithConfig(param1: string[] | SplitIO.SplitKey, param2?: string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentsWithConfig(splitNames, attributes);\n  }\n\n  /**\n   * Tracks an event for a shared client to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).\n   * @function track\n   * @param {SplitKey} key - The key that identifies the entity related to this event.\n   * @param {string} trafficType - The traffic type of the entity related to this event.\n   * @param {string} eventType - The event type corresponding to this event.\n   * @param {number=} value - The value of this event.\n   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.\n   */\n  track(key: SplitIO.SplitKey, trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;\n  /**\n   * Tracks an event to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).\n   * @function track\n   * @param {string} trafficType - The traffic type of the entity related to this event.\n   * @param {string} eventType - The event type corresponding to this event.\n   * @param {number=} value - The value of this event.\n   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.\n   */\n  track(trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;\n  track(param1: string | SplitIO.SplitKey, param2: string, param3?: string | number | undefined, param4?: number | SplitIO.Properties | undefined, param5?: SplitIO.Properties | undefined): boolean {\n    const {key, trafficType, eventType, value, properties} = parseTrackParams(param1, param2, param3, param4, param5);\n    return this.getClient(key).track(trafficType, eventType, value, properties);\n  }\n\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  private getManager() {\n    const client = this.getSDKClient();\n    if (!client) {\n      console.log('[ERROR] The SDK has not being initialized. Returning default response for method call.');\n      return DEFAULT_MANAGER;\n    }\n    return this.splitManager;\n  }\n\n  /**\n   * Get the array of splits data in SplitView format.\n   * @function getSplits\n   * @returns {SplitViews} The list of SplitIO.SplitView.\n   */\n  getSplits(): SplitIO.SplitViews {\n    return this.getManager().splits();\n  }\n\n  /**\n   * Get the data of a split in SplitView format.\n   * @function getSplit\n   * @param {string} splitName The name of the split we wan't to get info of.\n   * @returns {SplitView} The SplitIO.SplitView of the given split.\n   */\n  getSplit(splitName: string): SplitIO.SplitView | null {\n    return this.getManager().split(splitName);\n  }\n\n  /**\n   * Get the array of Split names.\n   * @function getSplitNames\n   * @returns {SplitNames} The lists of Split names.\n   */\n  getSplitNames(): SplitIO.SplitNames {\n    return this.getManager().names();\n  }\n\n  /**\n   * Destroy all clients instances.\n   * @function destroy\n   * @returns {Observable<unknown>}\n   */\n  destroy(): Observable<void> {\n    const mainInstanceKey = buildInstance(this.config.core.key);\n    this.clientsMap.forEach((client, key) => {\n      if (buildInstance(key) !== mainInstanceKey){\n        client.destroy();\n        this.clientsMap.delete(buildInstance(key));\n      }\n    });\n    this.clientsMap.delete(mainInstanceKey);\n    this.splitio = undefined;\n    return from(this.splitClient.destroy());\n  }\n\n  /**\n   * Private function to return as observable the event on parameter\n   * @param {string} event\n   * @param response\n   * @returns Observable<any>\n   */\n  private toObservable(key: SplitIO.SplitKey, client: SplitIO.IClient, event: string, isOneTimeEvent = true): Observable<string> {\n    const eventKey = buildInstance(key) + event;\n    if (isOneTimeEvent) {\n      return new Observable(subscriber => {\n        const wasEventEmitted = this.emittedEvents.get(eventKey);\n        if (wasEventEmitted) {\n          Promise.resolve().then(() => subscriber.next(event));\n        } else {\n          client.once(event, () => {\n            this.emittedEvents.set(eventKey, true);\n            subscriber.next(event);\n          });\n        }\n      });\n    } else {\n      return new Observable(subscriber => {\n        client.on(event, () => {\n          subscriber.next(event);\n        });\n      });\n    }\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { CanActivate, CanActivateChild, CanLoad } from '@angular/router';\nimport { SplitService } from './splitio.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SplitioGuard implements CanActivate, CanLoad, CanActivateChild {\n\n  constructor(private splitService: SplitService) {}\n\n  canActivate(): boolean {\n    return this.splitService.isSDKReady;\n  }\n\n  canLoad(): boolean {\n    return this.splitService.isSDKReady;\n  }\n\n  canActivateChild(): boolean {\n    return this.splitService.isSDKReady;\n  }\n}\n","/*\n * Public API Surface of splitio\n */\n\nexport * from './lib/splitio.service';\nexport * from './lib/splitio.guard';\n\nexport { InLocalStorage, LocalhostFromObject, DebugLogger, InfoLogger, WarnLogger, ErrorLogger } from '@splitsoftware/splitio-browserjs';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]}