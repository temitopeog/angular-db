{"version":3,"file":"splitsoftware-splitio-angular.js","sources":["../../projects/splitio/src/lib/utils/constants.ts","../../projects/splitio/src/lib/utils/utils.ts","../../projects/splitio/src/lib/splitio.service.ts","../../projects/splitio/src/lib/splitio.guard.ts","../../projects/splitio/src/public-api.ts","../../projects/splitio/src/splitsoftware-splitio-angular.ts"],"sourcesContent":["/**\n * SDK constant for control treatment\n */\nexport const CONTROL = 'control';\n/**\n * string constant for observable to return when client exists for a key\n */\nexport const INIT_CLIENT_EXISTS = 'init::clientExists';\n/**\n * string constant for observable to return when client is not initialized\n */\nexport const INIT_CLIENT_FIRST = 'init::clientFirst';\n\nexport const VERSION = 'angular-' + 'ANGULAR_SDK_VERSION_NUMBER';\n\n/**\n * client with methods that return default values\n */\nexport const CONTROL_CLIENT = {\n  getTreatment: () => { return CONTROL; },\n  getTreatmentWithConfig: () => { return { treatment: CONTROL, config: null }; },\n  getTreatments: (splitNames: string[]) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n      result = { ...result, [splitName]: CONTROL };\n    });\n    return result;\n  },\n  getTreatmentsWithConfig: (splitNames: string[]) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n      result = { ...result, [splitName]: { treatment: CONTROL, config: null } };\n    });\n    return result;\n  },\n  track: () => { return false; }\n};\n\n/**\n *  with methods that return default values\n */\nexport const DEFAULT_MANAGER = {\n  splits: () => { return []; },\n  split: () => { return null; },\n  names: () => { return []; }\n};\n","export function buildInstance(key: SplitIO.SplitKey): string {\n  // @ts-ignore\n  if (!key.bucketingKey) return key;\n  // @ts-ignore\n  return `${key.matchingKey ? key.matchingKey : key}-${key.bucketingKey ? key.bucketingKey : key}-`;\n}\n\nexport function parseTreatmentParams(param1: string | string[] | SplitIO.SplitKey, param2?: string | string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): any {\n  if (isString(param2) || Array.isArray(param2)) return { key: param1, splitNames: param2, attributes: param3};\n  return { key: undefined, splitNames: param1, attributes: param2 };\n}\n\nexport function parseTrackParams(param1: string | SplitIO.SplitKey, param2: string, param3: number | string | undefined, param4: number | SplitIO.Properties | undefined, param5: SplitIO.Properties | undefined) {\n  if (isString(param3)) return { key: param1, trafficType: param2, eventType: param3, value: param4, properties: param5};\n  return { key: undefined, trafficType: param1, eventType: param2, value: param3, properties: param4 };\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === 'string' || val instanceof String;\n}\n","import { Injectable } from '@angular/core';\nimport { SplitFactory } from '@splitsoftware/splitio-browserjs';\nimport * as SplitIO from '@splitsoftware/splitio-browserjs/types/splitio';\nimport { from, Observable } from 'rxjs';\nimport { INIT_CLIENT_EXISTS, INIT_CLIENT_FIRST, CONTROL_CLIENT, DEFAULT_MANAGER, VERSION } from './utils/constants';\nimport { buildInstance, parseTrackParams, parseTreatmentParams } from './utils/utils';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SplitService {\n\n  /**\n   * The local reference to the Split SDK.\n   */\n  private splitio: SplitIO.ISDK | undefined;\n  /**\n   * The local reference to the Split SDK's Client.\n   */\n  private splitClient: SplitIO.IClient;\n  /**\n   * The local reference to the Split SDK's Manager.\n   */\n  private splitManager: SplitIO.IManager;\n  /**\n   * Map of intialized clients\n   */\n  private clientsMap: Map<string, SplitIO.IClient> = new Map<string, SplitIO.IClient>();\n  /**\n   * Map of events status of intialized clients\n   */\n  private emittedEvents: Map<string, boolean> = new Map<string, boolean>();\n  /**\n   * Flag to determine if SDK is ready or not.\n   */\n  isSDKReady = false;\n  /**\n   * Factory config\n   */\n  private config: SplitIO.IBrowserSettings;\n  /**\n   * SDK events observables\n   */\n  sdkReady$: Observable<string>;\n  sdkReadyTimedOut$: Observable<string>;\n  sdkReadyFromCache$: Observable<string>;\n  sdkUpdate$: Observable<string>;\n\n  /**\n   * This method initializes the SDK with the required Browser APIKEY\n   * and the 'key' according to the Traffic type set (ex.: an user id).\n   * @function init\n   * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  init(config: SplitIO.IBrowserSettings): Observable<string> {\n    if (this.splitio) {\n      console.log('[ERROR] There is another instance of the SDK.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    this.config = config;\n    // @ts-ignore. 2nd param is not part of type definitions. Used to overwrite the version of the SDK for correct tracking.\n    this.splitio = SplitFactory(config, (modules) => {\n      modules.settings.version = VERSION;\n    });\n    this.splitClient = this.splitio.client();\n    this.splitManager = this.splitio.manager();\n    this.sdkInitEventObservable();\n    const instanceKey = buildInstance(this.config.core.key);\n    const sdkReady = this.splitClient.Event.SDK_READY;\n    this.splitClient.on(sdkReady, () => {\n      this.emittedEvents.set(instanceKey + sdkReady, true);\n      this.isSDKReady = true;\n    });\n    this.clientsMap.set(instanceKey, this.splitClient);\n    return this.sdkReady$;\n  }\n\n  /**\n   * Returns a shared client of the SDK, associated with the given key\n   * @function initClient\n   * @param {SplitKey} key The key for the new client instance.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  initClient(key: SplitIO.SplitKey): Observable<string> {\n    let client = this.getSDKClient(key);\n    if (client) {\n      console.log('[WARN] client for key ' + buildInstance(key) + ' is already initialized.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    if (!this.splitio) return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    client = this.splitio.client(key);\n    this.clientsMap.set(buildInstance(key), client);\n    return this.toObservable(key, client, client.Event.SDK_READY);\n  }\n\n  private getClientObservable(key: SplitIO.SplitKey, event: string, isOneTimeEvent = true): Observable<string> {\n    const client = this.getClient(key);\n    if (client === CONTROL_CLIENT) {\n      return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    }\n    return this.toObservable(key, client, client.Event[event], isOneTimeEvent);\n  }\n\n  /**\n   * Returns an observable that calls back when the client is ready\n   * @function getClientSDKReady\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReady(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY');\n  }\n\n  /**\n   * Returns an observable that calls back when the client ready event is timed out\n   * @function getClientSDKReadyTimedOut\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyTimedOut(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY_TIMED_OUT');\n  }\n\n  /**\n   * Returns an observable that calls back when the client is ready from cache\n   * @function getClientSDKReadyFromCache\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyFromCache(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_READY_FROM_CACHE');\n  }\n\n  /**\n   * Returns an observable that calls back when the client is updated\n   * @function getClientSDKUpdate\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKUpdate(key: SplitIO.SplitKey): Observable<string> {\n    return this.getClientObservable(key, 'SDK_UPDATE', false);\n  }\n\n  /**\n   * initialize sdk Events into observables\n   */\n  private sdkInitEventObservable(): void {\n    const client = this.splitClient;\n    const mainKey = this.config.core.key;\n    this.sdkReady$ = this.toObservable(mainKey, client, client.Event.SDK_READY);\n    this.sdkReadyTimedOut$ = this.toObservable(mainKey, client, client.Event.SDK_READY_TIMED_OUT);\n    this.sdkReadyFromCache$ = this.toObservable(mainKey, client, client.Event.SDK_READY_FROM_CACHE);\n    this.sdkUpdate$ = this.toObservable(mainKey, client, client.Event.SDK_UPDATE, false);\n  }\n\n  /**\n   * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).\n   * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,\n   * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.\n   * @returns Promise<void>\n   */\n  ready(): Promise<void> {\n    return this.getClient().ready();\n  }\n\n  private isInitialized(): boolean {\n    if (!this.splitio) {\n      console.log('[ERROR] plugin should be initialized');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the SDK client\n   * @param {SplitKey=} key The key for the client instance.\n   * @returns {IClient} split client.\n   */\n  getSDKClient(key?: SplitIO.SplitKey): SplitIO.IClient | undefined {\n    if (!this.isInitialized()) return undefined;\n    key = key ? key : this.config.core.key;\n    return this.clientsMap.get(buildInstance(key));\n  }\n\n  /**\n   * Returns the SDK factory\n   * @returns {ISDK} split factory\n   */\n  getSDKFactory(): SplitIO.ISDK | undefined {\n    if (!this.isInitialized()) return undefined;\n    return this.splitio;\n  }\n\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  private getClient(key?: SplitIO.SplitKey | undefined): any {\n    const client = this.getSDKClient(key);\n    if (!client) {\n      console.log('[ERROR] client' + ( key ? ' for key ' + buildInstance(key) : '') + ' should be initialized first.');\n      return CONTROL_CLIENT;\n    }\n    return client;\n  }\n\n  /**\n   * Returns a Treatment value, which is the treatment string for the given feature.\n   * @function getTreatment\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatment} - The treatment string.\n   */\n  getTreatment(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;\n  /**\n   * Returns a Treatment value, which is the treatment string for the given feature.\n   * @function getTreatment\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatment} - The treatment string.\n   */\n  getTreatment(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;\n  getTreatment(param1: string | SplitIO.SplitKey, param2?: string | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.Treatment {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatment(splitNames, attributes);\n  }\n\n  /**\n   * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.\n   * @function getTreatmentWithConfig\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).\n   */\n  getTreatmentWithConfig(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;\n  /**\n   * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.\n   * @function getTreatmentWithConfig\n   * @param {string} splitName - The string that represents the split we want to get the treatment.\n   * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).\n   */\n  getTreatmentWithConfig(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;\n  getTreatmentWithConfig(param1: string | SplitIO.SplitKey, param2?: string | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentWithConfig(splitNames, attributes);\n  }\n\n  /**\n   * Returns a Treatments value, which is an object map with the treatments for the given features.\n   * @function getTreatments\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatments} - The treatments object map.\n   */\n  getTreatments(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;\n  /**\n   * Returns a Treatments value, which is an object map with the treatments for the given features.\n   * @function getTreatments\\\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {Treatments} - The treatments object map.\n   */\n  getTreatments(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;\n  getTreatments(param1: string[] | SplitIO.SplitKey, param2?: string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.Treatments {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatments(splitNames, attributes);\n  }\n\n  /**\n   * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.\n   * @function getTreatmentsWithConfig\n   * @param {SplitKey} key - The key for the client instance.\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects\n   */\n  getTreatmentsWithConfig(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;\n  /**\n   * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.\n   * @function getTreatmentsWithConfig\n   * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.\n   * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.\n   * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects\n   */\n  getTreatmentsWithConfig(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;\n  getTreatmentsWithConfig(param1: string[] | SplitIO.SplitKey, param2?: string[] | SplitIO.Attributes | undefined, param3?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig {\n    const {key, splitNames, attributes} = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentsWithConfig(splitNames, attributes);\n  }\n\n  /**\n   * Tracks an event for a shared client to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).\n   * @function track\n   * @param {SplitKey} key - The key that identifies the entity related to this event.\n   * @param {string} trafficType - The traffic type of the entity related to this event.\n   * @param {string} eventType - The event type corresponding to this event.\n   * @param {number=} value - The value of this event.\n   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.\n   */\n  track(key: SplitIO.SplitKey, trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;\n  /**\n   * Tracks an event to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).\n   * @function track\n   * @param {string} trafficType - The traffic type of the entity related to this event.\n   * @param {string} eventType - The event type corresponding to this event.\n   * @param {number=} value - The value of this event.\n   * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.\n   */\n  track(trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;\n  track(param1: string | SplitIO.SplitKey, param2: string, param3?: string | number | undefined, param4?: number | SplitIO.Properties | undefined, param5?: SplitIO.Properties | undefined): boolean {\n    const {key, trafficType, eventType, value, properties} = parseTrackParams(param1, param2, param3, param4, param5);\n    return this.getClient(key).track(trafficType, eventType, value, properties);\n  }\n\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  private getManager() {\n    const client = this.getSDKClient();\n    if (!client) {\n      console.log('[ERROR] The SDK has not being initialized. Returning default response for method call.');\n      return DEFAULT_MANAGER;\n    }\n    return this.splitManager;\n  }\n\n  /**\n   * Get the array of splits data in SplitView format.\n   * @function getSplits\n   * @returns {SplitViews} The list of SplitIO.SplitView.\n   */\n  getSplits(): SplitIO.SplitViews {\n    return this.getManager().splits();\n  }\n\n  /**\n   * Get the data of a split in SplitView format.\n   * @function getSplit\n   * @param {string} splitName The name of the split we wan't to get info of.\n   * @returns {SplitView} The SplitIO.SplitView of the given split.\n   */\n  getSplit(splitName: string): SplitIO.SplitView | null {\n    return this.getManager().split(splitName);\n  }\n\n  /**\n   * Get the array of Split names.\n   * @function getSplitNames\n   * @returns {SplitNames} The lists of Split names.\n   */\n  getSplitNames(): SplitIO.SplitNames {\n    return this.getManager().names();\n  }\n\n  /**\n   * Destroy all clients instances.\n   * @function destroy\n   * @returns {Observable<unknown>}\n   */\n  destroy(): Observable<void> {\n    const mainInstanceKey = buildInstance(this.config.core.key);\n    this.clientsMap.forEach((client, key) => {\n      if (buildInstance(key) !== mainInstanceKey){\n        client.destroy();\n        this.clientsMap.delete(buildInstance(key));\n      }\n    });\n    this.clientsMap.delete(mainInstanceKey);\n    this.splitio = undefined;\n    return from(this.splitClient.destroy());\n  }\n\n  /**\n   * Private function to return as observable the event on parameter\n   * @param {string} event\n   * @param response\n   * @returns Observable<any>\n   */\n  private toObservable(key: SplitIO.SplitKey, client: SplitIO.IClient, event: string, isOneTimeEvent = true): Observable<string> {\n    const eventKey = buildInstance(key) + event;\n    if (isOneTimeEvent) {\n      return new Observable(subscriber => {\n        const wasEventEmitted = this.emittedEvents.get(eventKey);\n        if (wasEventEmitted) {\n          Promise.resolve().then(() => subscriber.next(event));\n        } else {\n          client.once(event, () => {\n            this.emittedEvents.set(eventKey, true);\n            subscriber.next(event);\n          });\n        }\n      });\n    } else {\n      return new Observable(subscriber => {\n        client.on(event, () => {\n          subscriber.next(event);\n        });\n      });\n    }\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { CanActivate, CanActivateChild, CanLoad } from '@angular/router';\nimport { SplitService } from './splitio.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SplitioGuard implements CanActivate, CanLoad, CanActivateChild {\n\n  constructor(private splitService: SplitService) {}\n\n  canActivate(): boolean {\n    return this.splitService.isSDKReady;\n  }\n\n  canLoad(): boolean {\n    return this.splitService.isSDKReady;\n  }\n\n  canActivateChild(): boolean {\n    return this.splitService.isSDKReady;\n  }\n}\n","/*\n * Public API Surface of splitio\n */\n\nexport * from './lib/splitio.service';\nexport * from './lib/splitio.guard';\n\nexport { InLocalStorage, LocalhostFromObject, DebugLogger, InfoLogger, WarnLogger, ErrorLogger } from '@splitsoftware/splitio-browserjs';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}