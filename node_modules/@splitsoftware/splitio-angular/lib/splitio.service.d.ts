import * as SplitIO from '@splitsoftware/splitio-browserjs/types/splitio';
import { Observable } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export declare class SplitService {
    /**
     * The local reference to the Split SDK.
     */
    private splitio;
    /**
     * The local reference to the Split SDK's Client.
     */
    private splitClient;
    /**
     * The local reference to the Split SDK's Manager.
     */
    private splitManager;
    /**
     * Map of intialized clients
     */
    private clientsMap;
    /**
     * Map of events status of intialized clients
     */
    private emittedEvents;
    /**
     * Flag to determine if SDK is ready or not.
     */
    isSDKReady: boolean;
    /**
     * Factory config
     */
    private config;
    /**
     * SDK events observables
     */
    sdkReady$: Observable<string>;
    sdkReadyTimedOut$: Observable<string>;
    sdkReadyFromCache$: Observable<string>;
    sdkUpdate$: Observable<string>;
    /**
     * This method initializes the SDK with the required Browser APIKEY
     * and the 'key' according to the Traffic type set (ex.: an user id).
     * @function init
     * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.
     * @returns {Observable<string>} Returns when sdk is ready
     */
    init(config: SplitIO.IBrowserSettings): Observable<string>;
    /**
     * Returns a shared client of the SDK, associated with the given key
     * @function initClient
     * @param {SplitKey} key The key for the new client instance.
     * @returns {Observable<string>} Returns when sdk is ready
     */
    initClient(key: SplitIO.SplitKey): Observable<string>;
    private getClientObservable;
    /**
     * Returns an observable that calls back when the client is ready
     * @function getClientSDKReady
     * @param {SplitKey} key The key for the client instance.
     * @returns {Observable<string>}
     */
    getClientSDKReady(key: SplitIO.SplitKey): Observable<string>;
    /**
     * Returns an observable that calls back when the client ready event is timed out
     * @function getClientSDKReadyTimedOut
     * @param {SplitKey} key The key for the client instance.
     * @returns {Observable<string>}
     */
    getClientSDKReadyTimedOut(key: SplitIO.SplitKey): Observable<string>;
    /**
     * Returns an observable that calls back when the client is ready from cache
     * @function getClientSDKReadyFromCache
     * @param {SplitKey} key The key for the client instance.
     * @returns {Observable<string>}
     */
    getClientSDKReadyFromCache(key: SplitIO.SplitKey): Observable<string>;
    /**
     * Returns an observable that calls back when the client is updated
     * @function getClientSDKUpdate
     * @param {SplitKey} key The key for the client instance.
     * @returns {Observable<string>}
     */
    getClientSDKUpdate(key: SplitIO.SplitKey): Observable<string>;
    /**
     * initialize sdk Events into observables
     */
    private sdkInitEventObservable;
    /**
     * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).
     * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,
     * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.
     * @returns Promise<void>
     */
    ready(): Promise<void>;
    private isInitialized;
    /**
     * Returns the SDK client
     * @param {SplitKey=} key The key for the client instance.
     * @returns {IClient} split client.
     */
    getSDKClient(key?: SplitIO.SplitKey): SplitIO.IClient | undefined;
    /**
     * Returns the SDK factory
     * @returns {ISDK} split factory
     */
    getSDKFactory(): SplitIO.ISDK | undefined;
    /**
     * Validates key and returns client if it is initialized for key or controlClient if it isn't
     */
    private getClient;
    /**
     * Returns a Treatment value, which is the treatment string for the given feature.
     * @function getTreatment
     * @param {SplitKey} key - The key for the client instance.
     * @param {string} splitName - The string that represents the split we want to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {Treatment} - The treatment string.
     */
    getTreatment(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;
    /**
     * Returns a Treatment value, which is the treatment string for the given feature.
     * @function getTreatment
     * @param {string} splitName - The string that represents the split we want to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {Treatment} - The treatment string.
     */
    getTreatment(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.Treatment;
    /**
     * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.
     * @function getTreatmentWithConfig
     * @param {SplitKey} key - The key for the client instance.
     * @param {string} splitName - The string that represents the split we want to get the treatment.
     * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).
     */
    getTreatmentWithConfig(key: SplitIO.SplitKey, splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;
    /**
     * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.
     * @function getTreatmentWithConfig
     * @param {string} splitName - The string that represents the split we want to get the treatment.
     * @param {Attributes} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentWithConfig} - The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).
     */
    getTreatmentWithConfig(splitName: string, attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentWithConfig;
    /**
     * Returns a Treatments value, which is an object map with the treatments for the given features.
     * @function getTreatments
     * @param {SplitKey} key - The key for the client instance.
     * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {Treatments} - The treatments object map.
     */
    getTreatments(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;
    /**
     * Returns a Treatments value, which is an object map with the treatments for the given features.
     * @function getTreatments\
     * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {Treatments} - The treatments object map.
     */
    getTreatments(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.Treatments;
    /**
     * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.
     * @function getTreatmentsWithConfig
     * @param {SplitKey} key - The key for the client instance.
     * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects
     */
    getTreatmentsWithConfig(key: SplitIO.SplitKey, splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;
    /**
     * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.
     * @function getTreatmentsWithConfig
     * @param {Array<string>} splitNames - An array of the split names we want to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects
     */
    getTreatmentsWithConfig(splitNames: string[], attributes?: SplitIO.Attributes | undefined): SplitIO.TreatmentsWithConfig;
    /**
     * Tracks an event for a shared client to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).
     * @function track
     * @param {SplitKey} key - The key that identifies the entity related to this event.
     * @param {string} trafficType - The traffic type of the entity related to this event.
     * @param {string} eventType - The event type corresponding to this event.
     * @param {number=} value - The value of this event.
     * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
     * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.
     */
    track(key: SplitIO.SplitKey, trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;
    /**
     * Tracks an event to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).
     * @function track
     * @param {string} trafficType - The traffic type of the entity related to this event.
     * @param {string} eventType - The event type corresponding to this event.
     * @param {number=} value - The value of this event.
     * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
     * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.
     */
    track(trafficType: string, eventType: string, value?: number | undefined, properties?: SplitIO.Properties | undefined): boolean;
    /**
     * Validates key and returns client if it is initialized for key or controlClient if it isn't
     */
    private getManager;
    /**
     * Get the array of splits data in SplitView format.
     * @function getSplits
     * @returns {SplitViews} The list of SplitIO.SplitView.
     */
    getSplits(): SplitIO.SplitViews;
    /**
     * Get the data of a split in SplitView format.
     * @function getSplit
     * @param {string} splitName The name of the split we wan't to get info of.
     * @returns {SplitView} The SplitIO.SplitView of the given split.
     */
    getSplit(splitName: string): SplitIO.SplitView | null;
    /**
     * Get the array of Split names.
     * @function getSplitNames
     * @returns {SplitNames} The lists of Split names.
     */
    getSplitNames(): SplitIO.SplitNames;
    /**
     * Destroy all clients instances.
     * @function destroy
     * @returns {Observable<unknown>}
     */
    destroy(): Observable<void>;
    /**
     * Private function to return as observable the event on parameter
     * @param {string} event
     * @param response
     * @returns Observable<any>
     */
    private toObservable;
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<SplitService, never>;
}

//# sourceMappingURL=splitio.service.d.ts.map