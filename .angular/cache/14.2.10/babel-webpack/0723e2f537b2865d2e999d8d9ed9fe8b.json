{"ast":null,"code":"import { fromImpressionsCollector } from '../sync/submitters/impressionsSubmitter';\nimport { fromImpressionCountsCollector } from '../sync/submitters/impressionCountsSubmitter';\nimport { OPTIMIZED, DEBUG } from '../utils/constants';\nimport { objectAssign } from '../utils/lang/objectAssign';\nimport { CLEANUP_REGISTERING, CLEANUP_DEREGISTERING } from '../logger/constants';\nimport { isConsentGranted } from '../consent';\nimport { telemetryCacheStatsAdapter } from '../sync/submitters/telemetrySubmitter';\n// 'unload' event is used instead of 'beforeunload', since 'unload' is not a cancelable event, so no other listeners can stop the event from occurring.\nvar UNLOAD_DOM_EVENT = 'unload';\nvar EVENT_NAME = 'for unload page event.';\n/**\n * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.\n */\nvar BrowserSignalListener = /** @class */function () {\n  function BrowserSignalListener(syncManager, settings, storage, serviceApi) {\n    this.syncManager = syncManager;\n    this.settings = settings;\n    this.storage = storage;\n    this.serviceApi = serviceApi;\n    this.flushData = this.flushData.bind(this);\n    this.fromImpressionsCollector = fromImpressionsCollector.bind(undefined, settings.core.labelsEnabled);\n  }\n  /**\n   * start method.\n   * Called when SplitFactory is initialized.\n   * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.\n   */\n  BrowserSignalListener.prototype.start = function () {\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      this.settings.log.debug(CLEANUP_REGISTERING, [EVENT_NAME]);\n      window.addEventListener(UNLOAD_DOM_EVENT, this.flushData);\n    }\n  };\n  /**\n   * stop method.\n   * Called when client is destroyed.\n   * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.\n   */\n  BrowserSignalListener.prototype.stop = function () {\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      this.settings.log.debug(CLEANUP_DEREGISTERING, [EVENT_NAME]);\n      window.removeEventListener(UNLOAD_DOM_EVENT, this.flushData);\n    }\n  };\n  /**\n   * flushData method.\n   * Called when unload event is triggered. It flushed remaining impressions and events to the backend,\n   * using beacon API if possible, or falling back to regular post transport.\n   */\n  BrowserSignalListener.prototype.flushData = function () {\n    if (!this.syncManager) return; // In consumer mode there is not sync manager and data to flush\n    // Flush impressions & events data if there is user consent\n    if (isConsentGranted(this.settings)) {\n      var eventsUrl = this.settings.urls.events;\n      var extraMetadata = {\n        // sim stands for Sync/Split Impressions Mode\n        sim: this.settings.sync.impressionsMode === OPTIMIZED ? OPTIMIZED : DEBUG\n      };\n      this._flushData(eventsUrl + '/testImpressions/beacon', this.storage.impressions, this.serviceApi.postTestImpressionsBulk, this.fromImpressionsCollector, extraMetadata);\n      this._flushData(eventsUrl + '/events/beacon', this.storage.events, this.serviceApi.postEventsBulk);\n      if (this.storage.impressionCounts) this._flushData(eventsUrl + '/testImpressions/count/beacon', this.storage.impressionCounts, this.serviceApi.postTestImpressionsCount, fromImpressionCountsCollector);\n    }\n    // Flush telemetry data\n    if (this.storage.telemetry) {\n      var telemetryUrl = this.settings.urls.telemetry;\n      var telemetryCacheAdapter = telemetryCacheStatsAdapter(this.storage.telemetry, this.storage.splits, this.storage.segments);\n      this._flushData(telemetryUrl + '/v1/metrics/usage/beacon', telemetryCacheAdapter, this.serviceApi.postMetricsUsage);\n    }\n    // Close streaming connection\n    if (this.syncManager.pushManager) this.syncManager.pushManager.stop();\n  };\n  BrowserSignalListener.prototype._flushData = function (url, cache, postService, fromCacheToPayload, extraMetadata) {\n    // if there is data in cache, send it to backend\n    if (!cache.isEmpty()) {\n      var dataPayload = fromCacheToPayload ? fromCacheToPayload(cache.pop()) : cache.pop();\n      if (!this._sendBeacon(url, dataPayload, extraMetadata)) {\n        postService(JSON.stringify(dataPayload)).catch(function () {}); // no-op just to catch a possible exception\n      }\n\n      cache.clear();\n    }\n  };\n  /**\n   * _sendBeacon method.\n   * Util method that check if beacon API is available, build the payload and send it.\n   */\n  BrowserSignalListener.prototype._sendBeacon = function (url, data, extraMetadata) {\n    // eslint-disable-next-line compat/compat\n    if (typeof navigator !== 'undefined' && navigator.sendBeacon) {\n      var json = {\n        entries: data,\n        token: this.settings.core.authorizationKey,\n        sdk: this.settings.version\n      };\n      // Extend with endpoint specific metadata where needed\n      if (extraMetadata) objectAssign(json, extraMetadata);\n      // Stringify the payload\n      var payload = JSON.stringify(json);\n      // eslint-disable-next-line compat/compat\n      return navigator.sendBeacon(url, payload);\n    }\n    return false;\n  };\n  return BrowserSignalListener;\n}();\nexport { BrowserSignalListener };","map":{"version":3,"names":["fromImpressionsCollector","fromImpressionCountsCollector","OPTIMIZED","DEBUG","objectAssign","CLEANUP_REGISTERING","CLEANUP_DEREGISTERING","isConsentGranted","telemetryCacheStatsAdapter","UNLOAD_DOM_EVENT","EVENT_NAME","BrowserSignalListener","syncManager","settings","storage","serviceApi","flushData","bind","undefined","core","labelsEnabled","prototype","start","window","addEventListener","log","debug","stop","removeEventListener","eventsUrl","urls","events","extraMetadata","sim","sync","impressionsMode","_flushData","impressions","postTestImpressionsBulk","postEventsBulk","impressionCounts","postTestImpressionsCount","telemetry","telemetryUrl","telemetryCacheAdapter","splits","segments","postMetricsUsage","pushManager","url","cache","postService","fromCacheToPayload","isEmpty","dataPayload","pop","_sendBeacon","JSON","stringify","catch","clear","data","navigator","sendBeacon","json","entries","token","authorizationKey","sdk","version","payload"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/listeners/browser.js"],"sourcesContent":["import { fromImpressionsCollector } from '../sync/submitters/impressionsSubmitter';\nimport { fromImpressionCountsCollector } from '../sync/submitters/impressionCountsSubmitter';\nimport { OPTIMIZED, DEBUG } from '../utils/constants';\nimport { objectAssign } from '../utils/lang/objectAssign';\nimport { CLEANUP_REGISTERING, CLEANUP_DEREGISTERING } from '../logger/constants';\nimport { isConsentGranted } from '../consent';\nimport { telemetryCacheStatsAdapter } from '../sync/submitters/telemetrySubmitter';\n// 'unload' event is used instead of 'beforeunload', since 'unload' is not a cancelable event, so no other listeners can stop the event from occurring.\nvar UNLOAD_DOM_EVENT = 'unload';\nvar EVENT_NAME = 'for unload page event.';\n/**\n * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.\n */\nvar BrowserSignalListener = /** @class */ (function () {\n    function BrowserSignalListener(syncManager, settings, storage, serviceApi) {\n        this.syncManager = syncManager;\n        this.settings = settings;\n        this.storage = storage;\n        this.serviceApi = serviceApi;\n        this.flushData = this.flushData.bind(this);\n        this.fromImpressionsCollector = fromImpressionsCollector.bind(undefined, settings.core.labelsEnabled);\n    }\n    /**\n     * start method.\n     * Called when SplitFactory is initialized.\n     * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.\n     */\n    BrowserSignalListener.prototype.start = function () {\n        if (typeof window !== 'undefined' && window.addEventListener) {\n            this.settings.log.debug(CLEANUP_REGISTERING, [EVENT_NAME]);\n            window.addEventListener(UNLOAD_DOM_EVENT, this.flushData);\n        }\n    };\n    /**\n     * stop method.\n     * Called when client is destroyed.\n     * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.\n     */\n    BrowserSignalListener.prototype.stop = function () {\n        if (typeof window !== 'undefined' && window.removeEventListener) {\n            this.settings.log.debug(CLEANUP_DEREGISTERING, [EVENT_NAME]);\n            window.removeEventListener(UNLOAD_DOM_EVENT, this.flushData);\n        }\n    };\n    /**\n     * flushData method.\n     * Called when unload event is triggered. It flushed remaining impressions and events to the backend,\n     * using beacon API if possible, or falling back to regular post transport.\n     */\n    BrowserSignalListener.prototype.flushData = function () {\n        if (!this.syncManager)\n            return; // In consumer mode there is not sync manager and data to flush\n        // Flush impressions & events data if there is user consent\n        if (isConsentGranted(this.settings)) {\n            var eventsUrl = this.settings.urls.events;\n            var extraMetadata = {\n                // sim stands for Sync/Split Impressions Mode\n                sim: this.settings.sync.impressionsMode === OPTIMIZED ? OPTIMIZED : DEBUG\n            };\n            this._flushData(eventsUrl + '/testImpressions/beacon', this.storage.impressions, this.serviceApi.postTestImpressionsBulk, this.fromImpressionsCollector, extraMetadata);\n            this._flushData(eventsUrl + '/events/beacon', this.storage.events, this.serviceApi.postEventsBulk);\n            if (this.storage.impressionCounts)\n                this._flushData(eventsUrl + '/testImpressions/count/beacon', this.storage.impressionCounts, this.serviceApi.postTestImpressionsCount, fromImpressionCountsCollector);\n        }\n        // Flush telemetry data\n        if (this.storage.telemetry) {\n            var telemetryUrl = this.settings.urls.telemetry;\n            var telemetryCacheAdapter = telemetryCacheStatsAdapter(this.storage.telemetry, this.storage.splits, this.storage.segments);\n            this._flushData(telemetryUrl + '/v1/metrics/usage/beacon', telemetryCacheAdapter, this.serviceApi.postMetricsUsage);\n        }\n        // Close streaming connection\n        if (this.syncManager.pushManager)\n            this.syncManager.pushManager.stop();\n    };\n    BrowserSignalListener.prototype._flushData = function (url, cache, postService, fromCacheToPayload, extraMetadata) {\n        // if there is data in cache, send it to backend\n        if (!cache.isEmpty()) {\n            var dataPayload = fromCacheToPayload ? fromCacheToPayload(cache.pop()) : cache.pop();\n            if (!this._sendBeacon(url, dataPayload, extraMetadata)) {\n                postService(JSON.stringify(dataPayload)).catch(function () { }); // no-op just to catch a possible exception\n            }\n            cache.clear();\n        }\n    };\n    /**\n     * _sendBeacon method.\n     * Util method that check if beacon API is available, build the payload and send it.\n     */\n    BrowserSignalListener.prototype._sendBeacon = function (url, data, extraMetadata) {\n        // eslint-disable-next-line compat/compat\n        if (typeof navigator !== 'undefined' && navigator.sendBeacon) {\n            var json = {\n                entries: data,\n                token: this.settings.core.authorizationKey,\n                sdk: this.settings.version\n            };\n            // Extend with endpoint specific metadata where needed\n            if (extraMetadata)\n                objectAssign(json, extraMetadata);\n            // Stringify the payload\n            var payload = JSON.stringify(json);\n            // eslint-disable-next-line compat/compat\n            return navigator.sendBeacon(url, payload);\n        }\n        return false;\n    };\n    return BrowserSignalListener;\n}());\nexport { BrowserSignalListener };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}