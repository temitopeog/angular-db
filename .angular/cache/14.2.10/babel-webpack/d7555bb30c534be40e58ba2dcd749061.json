{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { KeyBuilderSS } from '../KeyBuilderSS';\nimport { SplitsCachePluggable } from './SplitsCachePluggable';\nimport { SegmentsCachePluggable } from './SegmentsCachePluggable';\nimport { ImpressionsCachePluggable } from './ImpressionsCachePluggable';\nimport { EventsCachePluggable } from './EventsCachePluggable';\nimport { wrapperAdapter, METHODS_TO_PROMISE_WRAP } from './wrapperAdapter';\nimport { isObject } from '../../utils/lang';\nimport { validatePrefix } from '../KeyBuilder';\nimport { CONSUMER_PARTIAL_MODE, STORAGE_PLUGGABLE } from '../../utils/constants';\nimport { ImpressionsCacheInMemory } from '../inMemory/ImpressionsCacheInMemory';\nimport { EventsCacheInMemory } from '../inMemory/EventsCacheInMemory';\nimport { ImpressionCountsCacheInMemory } from '../inMemory/ImpressionCountsCacheInMemory';\nvar NO_VALID_WRAPPER = 'Expecting pluggable storage `wrapper` in options, but no valid wrapper instance was provided.';\nvar NO_VALID_WRAPPER_INTERFACE = 'The provided wrapper instance doesn’t follow the expected interface. Check our docs.';\n/**\n * Validate pluggable storage factory options.\n *\n * @param options user options\n * @throws Will throw an error if the options are invalid. Example: wrapper is not provided or doesn't have some methods.\n */\nfunction validatePluggableStorageOptions(options) {\n  if (!isObject(options) || !isObject(options.wrapper)) throw new Error(NO_VALID_WRAPPER);\n  var wrapper = options.wrapper;\n  var missingMethods = METHODS_TO_PROMISE_WRAP.filter(function (method) {\n    return typeof wrapper[method] !== 'function';\n  });\n  if (missingMethods.length) throw new Error(NO_VALID_WRAPPER_INTERFACE + \" The following methods are missing or invalid: \" + missingMethods);\n}\n// subscription to wrapper connect event in order to emit SDK_READY event\nfunction wrapperConnect(wrapper, onReadyCb) {\n  wrapper.connect().then(function () {\n    onReadyCb();\n    // At the moment, we don't synchronize config with pluggable storage\n  }).catch(function (e) {\n    onReadyCb(e || new Error('Error connecting wrapper'));\n  });\n}\n// Async return type in `client.track` method on consumer partial mode\n// No need to promisify impressions cache\nfunction promisifyEventsTrack(events) {\n  var origTrack = events.track;\n  events.track = function () {\n    return Promise.resolve(origTrack.apply(this, arguments));\n  };\n  return events;\n}\n/**\n * Pluggable storage factory for consumer server-side & client-side SplitFactory.\n */\nexport function PluggableStorage(options) {\n  validatePluggableStorageOptions(options);\n  var prefix = validatePrefix(options.prefix);\n  function PluggableStorageFactory(_a) {\n    var log = _a.log,\n      metadata = _a.metadata,\n      onReadyCb = _a.onReadyCb,\n      mode = _a.mode,\n      eventsQueueSize = _a.eventsQueueSize,\n      impressionsQueueSize = _a.impressionsQueueSize,\n      optimize = _a.optimize;\n    var keys = new KeyBuilderSS(prefix, metadata);\n    var wrapper = wrapperAdapter(log, options.wrapper);\n    var isPartialConsumer = mode === CONSUMER_PARTIAL_MODE;\n    // Connects to wrapper and emits SDK_READY event on main client\n    wrapperConnect(wrapper, onReadyCb);\n    return {\n      splits: new SplitsCachePluggable(log, keys, wrapper),\n      segments: new SegmentsCachePluggable(log, keys, wrapper),\n      impressions: isPartialConsumer ? new ImpressionsCacheInMemory(impressionsQueueSize) : new ImpressionsCachePluggable(log, keys.buildImpressionsKey(), wrapper, metadata),\n      impressionCounts: optimize ? new ImpressionCountsCacheInMemory() : undefined,\n      events: isPartialConsumer ? promisifyEventsTrack(new EventsCacheInMemory(eventsQueueSize)) : new EventsCachePluggable(log, keys.buildEventsKey(), wrapper, metadata),\n      // @TODO Not using TelemetryCachePluggable yet because it's not supported by the Split Synchronizer, and needs to drop or queue operations while the wrapper is not ready\n      // telemetry: isPartialConsumer ? new TelemetryCacheInMemory() : new TelemetryCachePluggable(log, keys, wrapper),\n      // Disconnect the underlying storage\n      destroy: function () {\n        return wrapper.disconnect();\n      },\n      // emits SDK_READY event on shared clients and returns a reference to the storage\n      shared: function (_, onReadyCb) {\n        wrapperConnect(wrapper, onReadyCb);\n        return __assign(__assign({}, this), {\n          // no-op destroy, to disconnect the wrapper only when the main client is destroyed\n          destroy: function () {}\n        });\n      }\n    };\n  }\n  PluggableStorageFactory.type = STORAGE_PLUGGABLE;\n  return PluggableStorageFactory;\n}","map":{"version":3,"names":["__assign","KeyBuilderSS","SplitsCachePluggable","SegmentsCachePluggable","ImpressionsCachePluggable","EventsCachePluggable","wrapperAdapter","METHODS_TO_PROMISE_WRAP","isObject","validatePrefix","CONSUMER_PARTIAL_MODE","STORAGE_PLUGGABLE","ImpressionsCacheInMemory","EventsCacheInMemory","ImpressionCountsCacheInMemory","NO_VALID_WRAPPER","NO_VALID_WRAPPER_INTERFACE","validatePluggableStorageOptions","options","wrapper","Error","missingMethods","filter","method","length","wrapperConnect","onReadyCb","connect","then","catch","e","promisifyEventsTrack","events","origTrack","track","Promise","resolve","apply","arguments","PluggableStorage","prefix","PluggableStorageFactory","_a","log","metadata","mode","eventsQueueSize","impressionsQueueSize","optimize","keys","isPartialConsumer","splits","segments","impressions","buildImpressionsKey","impressionCounts","undefined","buildEventsKey","destroy","disconnect","shared","_","type"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/pluggable/index.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { KeyBuilderSS } from '../KeyBuilderSS';\nimport { SplitsCachePluggable } from './SplitsCachePluggable';\nimport { SegmentsCachePluggable } from './SegmentsCachePluggable';\nimport { ImpressionsCachePluggable } from './ImpressionsCachePluggable';\nimport { EventsCachePluggable } from './EventsCachePluggable';\nimport { wrapperAdapter, METHODS_TO_PROMISE_WRAP } from './wrapperAdapter';\nimport { isObject } from '../../utils/lang';\nimport { validatePrefix } from '../KeyBuilder';\nimport { CONSUMER_PARTIAL_MODE, STORAGE_PLUGGABLE } from '../../utils/constants';\nimport { ImpressionsCacheInMemory } from '../inMemory/ImpressionsCacheInMemory';\nimport { EventsCacheInMemory } from '../inMemory/EventsCacheInMemory';\nimport { ImpressionCountsCacheInMemory } from '../inMemory/ImpressionCountsCacheInMemory';\nvar NO_VALID_WRAPPER = 'Expecting pluggable storage `wrapper` in options, but no valid wrapper instance was provided.';\nvar NO_VALID_WRAPPER_INTERFACE = 'The provided wrapper instance doesn’t follow the expected interface. Check our docs.';\n/**\n * Validate pluggable storage factory options.\n *\n * @param options user options\n * @throws Will throw an error if the options are invalid. Example: wrapper is not provided or doesn't have some methods.\n */\nfunction validatePluggableStorageOptions(options) {\n    if (!isObject(options) || !isObject(options.wrapper))\n        throw new Error(NO_VALID_WRAPPER);\n    var wrapper = options.wrapper;\n    var missingMethods = METHODS_TO_PROMISE_WRAP.filter(function (method) { return typeof wrapper[method] !== 'function'; });\n    if (missingMethods.length)\n        throw new Error(NO_VALID_WRAPPER_INTERFACE + \" The following methods are missing or invalid: \" + missingMethods);\n}\n// subscription to wrapper connect event in order to emit SDK_READY event\nfunction wrapperConnect(wrapper, onReadyCb) {\n    wrapper.connect().then(function () {\n        onReadyCb();\n        // At the moment, we don't synchronize config with pluggable storage\n    }).catch(function (e) {\n        onReadyCb(e || new Error('Error connecting wrapper'));\n    });\n}\n// Async return type in `client.track` method on consumer partial mode\n// No need to promisify impressions cache\nfunction promisifyEventsTrack(events) {\n    var origTrack = events.track;\n    events.track = function () {\n        return Promise.resolve(origTrack.apply(this, arguments));\n    };\n    return events;\n}\n/**\n * Pluggable storage factory for consumer server-side & client-side SplitFactory.\n */\nexport function PluggableStorage(options) {\n    validatePluggableStorageOptions(options);\n    var prefix = validatePrefix(options.prefix);\n    function PluggableStorageFactory(_a) {\n        var log = _a.log, metadata = _a.metadata, onReadyCb = _a.onReadyCb, mode = _a.mode, eventsQueueSize = _a.eventsQueueSize, impressionsQueueSize = _a.impressionsQueueSize, optimize = _a.optimize;\n        var keys = new KeyBuilderSS(prefix, metadata);\n        var wrapper = wrapperAdapter(log, options.wrapper);\n        var isPartialConsumer = mode === CONSUMER_PARTIAL_MODE;\n        // Connects to wrapper and emits SDK_READY event on main client\n        wrapperConnect(wrapper, onReadyCb);\n        return {\n            splits: new SplitsCachePluggable(log, keys, wrapper),\n            segments: new SegmentsCachePluggable(log, keys, wrapper),\n            impressions: isPartialConsumer ? new ImpressionsCacheInMemory(impressionsQueueSize) : new ImpressionsCachePluggable(log, keys.buildImpressionsKey(), wrapper, metadata),\n            impressionCounts: optimize ? new ImpressionCountsCacheInMemory() : undefined,\n            events: isPartialConsumer ? promisifyEventsTrack(new EventsCacheInMemory(eventsQueueSize)) : new EventsCachePluggable(log, keys.buildEventsKey(), wrapper, metadata),\n            // @TODO Not using TelemetryCachePluggable yet because it's not supported by the Split Synchronizer, and needs to drop or queue operations while the wrapper is not ready\n            // telemetry: isPartialConsumer ? new TelemetryCacheInMemory() : new TelemetryCachePluggable(log, keys, wrapper),\n            // Disconnect the underlying storage\n            destroy: function () {\n                return wrapper.disconnect();\n            },\n            // emits SDK_READY event on shared clients and returns a reference to the storage\n            shared: function (_, onReadyCb) {\n                wrapperConnect(wrapper, onReadyCb);\n                return __assign(__assign({}, this), { \n                    // no-op destroy, to disconnect the wrapper only when the main client is destroyed\n                    destroy: function () { } });\n            }\n        };\n    }\n    PluggableStorageFactory.type = STORAGE_PLUGGABLE;\n    return PluggableStorageFactory;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}