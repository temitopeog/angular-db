{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { AbstractSplitsCacheSync, usesSegments } from '../AbstractSplitsCacheSync';\nimport { isFiniteNumber, toNumber, isNaNNumber } from '../../utils/lang';\nimport { LOG_PREFIX } from './constants';\n/**\n * ISplitsCacheSync implementation that stores split definitions in browser LocalStorage.\n */\nvar SplitsCacheInLocal = /** @class */function (_super) {\n  __extends(SplitsCacheInLocal, _super);\n  /**\n   * @param {KeyBuilderCS} keys\n   * @param {number | undefined} expirationTimestamp\n   * @param {ISplitFiltersValidation} splitFiltersValidation\n   */\n  function SplitsCacheInLocal(log, keys, expirationTimestamp, splitFiltersValidation) {\n    if (splitFiltersValidation === void 0) {\n      splitFiltersValidation = {\n        queryString: null,\n        groupedFilters: {\n          byName: [],\n          byPrefix: []\n        },\n        validFilters: []\n      };\n    }\n    var _this = _super.call(this) || this;\n    _this.log = log;\n    _this.cacheReadyButNeedsToFlush = false;\n    _this.keys = keys;\n    _this.splitFiltersValidation = splitFiltersValidation;\n    _this._checkExpiration(expirationTimestamp);\n    _this._checkFilterQuery();\n    return _this;\n  }\n  SplitsCacheInLocal.prototype._decrementCount = function (key) {\n    var count = toNumber(localStorage.getItem(key)) - 1;\n    // @ts-expect-error\n    if (count > 0) localStorage.setItem(key, count);else localStorage.removeItem(key);\n  };\n  SplitsCacheInLocal.prototype._decrementCounts = function (split) {\n    try {\n      if (split) {\n        if (split.trafficTypeName) {\n          var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n          this._decrementCount(ttKey);\n        }\n        if (usesSegments(split)) {\n          var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();\n          this._decrementCount(segmentsCountKey);\n        }\n      }\n    } catch (e) {\n      this.log.error(LOG_PREFIX + e);\n    }\n  };\n  SplitsCacheInLocal.prototype._incrementCounts = function (split) {\n    try {\n      if (split) {\n        if (split.trafficTypeName) {\n          var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n          // @ts-expect-error\n          localStorage.setItem(ttKey, toNumber(localStorage.getItem(ttKey)) + 1);\n        }\n        if (usesSegments(split)) {\n          var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();\n          // @ts-expect-error\n          localStorage.setItem(segmentsCountKey, toNumber(localStorage.getItem(segmentsCountKey)) + 1);\n        }\n      }\n    } catch (e) {\n      this.log.error(LOG_PREFIX + e);\n    }\n  };\n  /**\n   * Removes all splits cache related data from localStorage (splits, counters, changeNumber and lastUpdated).\n   * We cannot simply call `localStorage.clear()` since that implies removing user items from the storage.\n   */\n  SplitsCacheInLocal.prototype.clear = function () {\n    this.log.info(LOG_PREFIX + 'Flushing Splits data from localStorage');\n    // collect item keys\n    var len = localStorage.length;\n    var accum = [];\n    for (var cur = 0; cur < len; cur++) {\n      var key = localStorage.key(cur);\n      if (key != null && this.keys.isSplitsCacheKey(key)) accum.push(key);\n    }\n    // remove items\n    accum.forEach(function (key) {\n      localStorage.removeItem(key);\n    });\n    this.hasSync = false;\n  };\n  SplitsCacheInLocal.prototype.addSplit = function (name, split) {\n    try {\n      var splitKey = this.keys.buildSplitKey(name);\n      var splitFromLocalStorage = localStorage.getItem(splitKey);\n      var previousSplit = splitFromLocalStorage ? JSON.parse(splitFromLocalStorage) : null;\n      this._decrementCounts(previousSplit);\n      localStorage.setItem(splitKey, split);\n      var parsedSplit = split ? JSON.parse(split) : null;\n      this._incrementCounts(parsedSplit);\n      return true;\n    } catch (e) {\n      this.log.error(LOG_PREFIX + e);\n      return false;\n    }\n  };\n  SplitsCacheInLocal.prototype.removeSplit = function (name) {\n    try {\n      var split = this.getSplit(name);\n      localStorage.removeItem(this.keys.buildSplitKey(name));\n      var parsedSplit = JSON.parse(split);\n      this._decrementCounts(parsedSplit);\n      return true;\n    } catch (e) {\n      this.log.error(LOG_PREFIX + e);\n      return false;\n    }\n  };\n  SplitsCacheInLocal.prototype.getSplit = function (name) {\n    return localStorage.getItem(this.keys.buildSplitKey(name));\n  };\n  SplitsCacheInLocal.prototype.setChangeNumber = function (changeNumber) {\n    // when cache is ready but using a new split query, we must clear all split data\n    if (this.cacheReadyButNeedsToFlush) {\n      this.clear();\n      this.cacheReadyButNeedsToFlush = false;\n    }\n    // when using a new split query, we must update it at the store\n    if (this.updateNewFilter) {\n      this.log.info(LOG_PREFIX + 'Split filter query was modified. Updating cache.');\n      var queryKey = this.keys.buildSplitsFilterQueryKey();\n      var queryString = this.splitFiltersValidation.queryString;\n      try {\n        if (queryString) localStorage.setItem(queryKey, queryString);else localStorage.removeItem(queryKey);\n      } catch (e) {\n        this.log.error(LOG_PREFIX + e);\n      }\n      this.updateNewFilter = false;\n    }\n    try {\n      localStorage.setItem(this.keys.buildSplitsTillKey(), changeNumber + '');\n      // update \"last updated\" timestamp with current time\n      localStorage.setItem(this.keys.buildLastUpdatedKey(), Date.now() + '');\n      this.hasSync = true;\n      return true;\n    } catch (e) {\n      this.log.error(LOG_PREFIX + e);\n      return false;\n    }\n  };\n  SplitsCacheInLocal.prototype.getChangeNumber = function () {\n    var n = -1;\n    var value = localStorage.getItem(this.keys.buildSplitsTillKey());\n    if (value !== null) {\n      value = parseInt(value, 10);\n      return isNaNNumber(value) ? n : value;\n    }\n    return n;\n  };\n  SplitsCacheInLocal.prototype.getSplitNames = function () {\n    var len = localStorage.length;\n    var accum = [];\n    var cur = 0;\n    while (cur < len) {\n      var key = localStorage.key(cur);\n      if (key != null && this.keys.isSplitKey(key)) accum.push(this.keys.extractKey(key));\n      cur++;\n    }\n    return accum;\n  };\n  SplitsCacheInLocal.prototype.trafficTypeExists = function (trafficType) {\n    var ttCount = toNumber(localStorage.getItem(this.keys.buildTrafficTypeKey(trafficType)));\n    return isFiniteNumber(ttCount) && ttCount > 0;\n  };\n  SplitsCacheInLocal.prototype.usesSegments = function () {\n    // If cache hasn't been synchronized with the cloud, assume we need them.\n    if (!this.hasSync) return true;\n    var storedCount = localStorage.getItem(this.keys.buildSplitsWithSegmentCountKey());\n    var splitsWithSegmentsCount = storedCount === null ? 0 : toNumber(storedCount);\n    if (isFiniteNumber(splitsWithSegmentsCount)) {\n      return splitsWithSegmentsCount > 0;\n    } else {\n      return true;\n    }\n  };\n  /**\n   * Check if the splits information is already stored in browser LocalStorage.\n   * In this function we could add more code to check if the data is valid.\n   * @override\n   */\n  SplitsCacheInLocal.prototype.checkCache = function () {\n    return this.getChangeNumber() > -1 || this.cacheReadyButNeedsToFlush;\n  };\n  /**\n   * Clean Splits cache if its `lastUpdated` timestamp is older than the given `expirationTimestamp`,\n   * Clean operation (clear) also updates `lastUpdated` timestamp with current time.\n   *\n   * @param {number | undefined} expirationTimestamp if the value is not a number, data will not be cleaned\n   */\n  SplitsCacheInLocal.prototype._checkExpiration = function (expirationTimestamp) {\n    var value = localStorage.getItem(this.keys.buildLastUpdatedKey());\n    if (value !== null) {\n      value = parseInt(value, 10);\n      if (!isNaNNumber(value) && expirationTimestamp && value < expirationTimestamp) this.clear();\n    }\n  };\n  SplitsCacheInLocal.prototype._checkFilterQuery = function () {\n    var _this = this;\n    var _a = this.splitFiltersValidation,\n      queryString = _a.queryString,\n      groupedFilters = _a.groupedFilters;\n    var queryKey = this.keys.buildSplitsFilterQueryKey();\n    var currentQueryString = localStorage.getItem(queryKey);\n    if (currentQueryString !== queryString) {\n      try {\n        // mark cache to update the new query filter on first successful splits fetch\n        this.updateNewFilter = true;\n        // if cache is ready:\n        if (this.checkCache()) {\n          // * set change number to -1, to fetch splits with -1 `since` value.\n          localStorage.setItem(this.keys.buildSplitsTillKey(), '-1');\n          // * remove from cache splits that doesn't match with the new filters\n          this.getSplitNames().forEach(function (splitName) {\n            if (queryString && (\n            // @TODO consider redefining `groupedFilters` to expose a method like `groupedFilters::filter(splitName): boolean`\n            groupedFilters.byName.indexOf(splitName) > -1 || groupedFilters.byPrefix.some(function (prefix) {\n              return splitName.startsWith(prefix + '__');\n            }))) {\n              // * set `cacheReadyButNeedsToFlush` so that `checkCache` returns true (the storage is ready to be used) and the data is cleared before updating on first successful splits fetch\n              _this.cacheReadyButNeedsToFlush = true;\n              return;\n            }\n            _this.removeSplit(splitName);\n          });\n        }\n      } catch (e) {\n        this.log.error(LOG_PREFIX + e);\n      }\n    }\n    // if the filter didn't change, nothing is done\n  };\n\n  return SplitsCacheInLocal;\n}(AbstractSplitsCacheSync);\nexport { SplitsCacheInLocal };","map":{"version":3,"names":["__extends","AbstractSplitsCacheSync","usesSegments","isFiniteNumber","toNumber","isNaNNumber","LOG_PREFIX","SplitsCacheInLocal","_super","log","keys","expirationTimestamp","splitFiltersValidation","queryString","groupedFilters","byName","byPrefix","validFilters","_this","call","cacheReadyButNeedsToFlush","_checkExpiration","_checkFilterQuery","prototype","_decrementCount","key","count","localStorage","getItem","setItem","removeItem","_decrementCounts","split","trafficTypeName","ttKey","buildTrafficTypeKey","segmentsCountKey","buildSplitsWithSegmentCountKey","e","error","_incrementCounts","clear","info","len","length","accum","cur","isSplitsCacheKey","push","forEach","hasSync","addSplit","name","splitKey","buildSplitKey","splitFromLocalStorage","previousSplit","JSON","parse","parsedSplit","removeSplit","getSplit","setChangeNumber","changeNumber","updateNewFilter","queryKey","buildSplitsFilterQueryKey","buildSplitsTillKey","buildLastUpdatedKey","Date","now","getChangeNumber","n","value","parseInt","getSplitNames","isSplitKey","extractKey","trafficTypeExists","trafficType","ttCount","storedCount","splitsWithSegmentsCount","checkCache","_a","currentQueryString","splitName","indexOf","some","prefix","startsWith"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/inLocalStorage/SplitsCacheInLocal.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { AbstractSplitsCacheSync, usesSegments } from '../AbstractSplitsCacheSync';\nimport { isFiniteNumber, toNumber, isNaNNumber } from '../../utils/lang';\nimport { LOG_PREFIX } from './constants';\n/**\n * ISplitsCacheSync implementation that stores split definitions in browser LocalStorage.\n */\nvar SplitsCacheInLocal = /** @class */ (function (_super) {\n    __extends(SplitsCacheInLocal, _super);\n    /**\n     * @param {KeyBuilderCS} keys\n     * @param {number | undefined} expirationTimestamp\n     * @param {ISplitFiltersValidation} splitFiltersValidation\n     */\n    function SplitsCacheInLocal(log, keys, expirationTimestamp, splitFiltersValidation) {\n        if (splitFiltersValidation === void 0) { splitFiltersValidation = { queryString: null, groupedFilters: { byName: [], byPrefix: [] }, validFilters: [] }; }\n        var _this = _super.call(this) || this;\n        _this.log = log;\n        _this.cacheReadyButNeedsToFlush = false;\n        _this.keys = keys;\n        _this.splitFiltersValidation = splitFiltersValidation;\n        _this._checkExpiration(expirationTimestamp);\n        _this._checkFilterQuery();\n        return _this;\n    }\n    SplitsCacheInLocal.prototype._decrementCount = function (key) {\n        var count = toNumber(localStorage.getItem(key)) - 1;\n        // @ts-expect-error\n        if (count > 0)\n            localStorage.setItem(key, count);\n        else\n            localStorage.removeItem(key);\n    };\n    SplitsCacheInLocal.prototype._decrementCounts = function (split) {\n        try {\n            if (split) {\n                if (split.trafficTypeName) {\n                    var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n                    this._decrementCount(ttKey);\n                }\n                if (usesSegments(split)) {\n                    var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();\n                    this._decrementCount(segmentsCountKey);\n                }\n            }\n        }\n        catch (e) {\n            this.log.error(LOG_PREFIX + e);\n        }\n    };\n    SplitsCacheInLocal.prototype._incrementCounts = function (split) {\n        try {\n            if (split) {\n                if (split.trafficTypeName) {\n                    var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n                    // @ts-expect-error\n                    localStorage.setItem(ttKey, toNumber(localStorage.getItem(ttKey)) + 1);\n                }\n                if (usesSegments(split)) {\n                    var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();\n                    // @ts-expect-error\n                    localStorage.setItem(segmentsCountKey, toNumber(localStorage.getItem(segmentsCountKey)) + 1);\n                }\n            }\n        }\n        catch (e) {\n            this.log.error(LOG_PREFIX + e);\n        }\n    };\n    /**\n     * Removes all splits cache related data from localStorage (splits, counters, changeNumber and lastUpdated).\n     * We cannot simply call `localStorage.clear()` since that implies removing user items from the storage.\n     */\n    SplitsCacheInLocal.prototype.clear = function () {\n        this.log.info(LOG_PREFIX + 'Flushing Splits data from localStorage');\n        // collect item keys\n        var len = localStorage.length;\n        var accum = [];\n        for (var cur = 0; cur < len; cur++) {\n            var key = localStorage.key(cur);\n            if (key != null && this.keys.isSplitsCacheKey(key))\n                accum.push(key);\n        }\n        // remove items\n        accum.forEach(function (key) {\n            localStorage.removeItem(key);\n        });\n        this.hasSync = false;\n    };\n    SplitsCacheInLocal.prototype.addSplit = function (name, split) {\n        try {\n            var splitKey = this.keys.buildSplitKey(name);\n            var splitFromLocalStorage = localStorage.getItem(splitKey);\n            var previousSplit = splitFromLocalStorage ? JSON.parse(splitFromLocalStorage) : null;\n            this._decrementCounts(previousSplit);\n            localStorage.setItem(splitKey, split);\n            var parsedSplit = split ? JSON.parse(split) : null;\n            this._incrementCounts(parsedSplit);\n            return true;\n        }\n        catch (e) {\n            this.log.error(LOG_PREFIX + e);\n            return false;\n        }\n    };\n    SplitsCacheInLocal.prototype.removeSplit = function (name) {\n        try {\n            var split = this.getSplit(name);\n            localStorage.removeItem(this.keys.buildSplitKey(name));\n            var parsedSplit = JSON.parse(split);\n            this._decrementCounts(parsedSplit);\n            return true;\n        }\n        catch (e) {\n            this.log.error(LOG_PREFIX + e);\n            return false;\n        }\n    };\n    SplitsCacheInLocal.prototype.getSplit = function (name) {\n        return localStorage.getItem(this.keys.buildSplitKey(name));\n    };\n    SplitsCacheInLocal.prototype.setChangeNumber = function (changeNumber) {\n        // when cache is ready but using a new split query, we must clear all split data\n        if (this.cacheReadyButNeedsToFlush) {\n            this.clear();\n            this.cacheReadyButNeedsToFlush = false;\n        }\n        // when using a new split query, we must update it at the store\n        if (this.updateNewFilter) {\n            this.log.info(LOG_PREFIX + 'Split filter query was modified. Updating cache.');\n            var queryKey = this.keys.buildSplitsFilterQueryKey();\n            var queryString = this.splitFiltersValidation.queryString;\n            try {\n                if (queryString)\n                    localStorage.setItem(queryKey, queryString);\n                else\n                    localStorage.removeItem(queryKey);\n            }\n            catch (e) {\n                this.log.error(LOG_PREFIX + e);\n            }\n            this.updateNewFilter = false;\n        }\n        try {\n            localStorage.setItem(this.keys.buildSplitsTillKey(), changeNumber + '');\n            // update \"last updated\" timestamp with current time\n            localStorage.setItem(this.keys.buildLastUpdatedKey(), Date.now() + '');\n            this.hasSync = true;\n            return true;\n        }\n        catch (e) {\n            this.log.error(LOG_PREFIX + e);\n            return false;\n        }\n    };\n    SplitsCacheInLocal.prototype.getChangeNumber = function () {\n        var n = -1;\n        var value = localStorage.getItem(this.keys.buildSplitsTillKey());\n        if (value !== null) {\n            value = parseInt(value, 10);\n            return isNaNNumber(value) ? n : value;\n        }\n        return n;\n    };\n    SplitsCacheInLocal.prototype.getSplitNames = function () {\n        var len = localStorage.length;\n        var accum = [];\n        var cur = 0;\n        while (cur < len) {\n            var key = localStorage.key(cur);\n            if (key != null && this.keys.isSplitKey(key))\n                accum.push(this.keys.extractKey(key));\n            cur++;\n        }\n        return accum;\n    };\n    SplitsCacheInLocal.prototype.trafficTypeExists = function (trafficType) {\n        var ttCount = toNumber(localStorage.getItem(this.keys.buildTrafficTypeKey(trafficType)));\n        return isFiniteNumber(ttCount) && ttCount > 0;\n    };\n    SplitsCacheInLocal.prototype.usesSegments = function () {\n        // If cache hasn't been synchronized with the cloud, assume we need them.\n        if (!this.hasSync)\n            return true;\n        var storedCount = localStorage.getItem(this.keys.buildSplitsWithSegmentCountKey());\n        var splitsWithSegmentsCount = storedCount === null ? 0 : toNumber(storedCount);\n        if (isFiniteNumber(splitsWithSegmentsCount)) {\n            return splitsWithSegmentsCount > 0;\n        }\n        else {\n            return true;\n        }\n    };\n    /**\n     * Check if the splits information is already stored in browser LocalStorage.\n     * In this function we could add more code to check if the data is valid.\n     * @override\n     */\n    SplitsCacheInLocal.prototype.checkCache = function () {\n        return this.getChangeNumber() > -1 || this.cacheReadyButNeedsToFlush;\n    };\n    /**\n     * Clean Splits cache if its `lastUpdated` timestamp is older than the given `expirationTimestamp`,\n     * Clean operation (clear) also updates `lastUpdated` timestamp with current time.\n     *\n     * @param {number | undefined} expirationTimestamp if the value is not a number, data will not be cleaned\n     */\n    SplitsCacheInLocal.prototype._checkExpiration = function (expirationTimestamp) {\n        var value = localStorage.getItem(this.keys.buildLastUpdatedKey());\n        if (value !== null) {\n            value = parseInt(value, 10);\n            if (!isNaNNumber(value) && expirationTimestamp && value < expirationTimestamp)\n                this.clear();\n        }\n    };\n    SplitsCacheInLocal.prototype._checkFilterQuery = function () {\n        var _this = this;\n        var _a = this.splitFiltersValidation, queryString = _a.queryString, groupedFilters = _a.groupedFilters;\n        var queryKey = this.keys.buildSplitsFilterQueryKey();\n        var currentQueryString = localStorage.getItem(queryKey);\n        if (currentQueryString !== queryString) {\n            try {\n                // mark cache to update the new query filter on first successful splits fetch\n                this.updateNewFilter = true;\n                // if cache is ready:\n                if (this.checkCache()) {\n                    // * set change number to -1, to fetch splits with -1 `since` value.\n                    localStorage.setItem(this.keys.buildSplitsTillKey(), '-1');\n                    // * remove from cache splits that doesn't match with the new filters\n                    this.getSplitNames().forEach(function (splitName) {\n                        if (queryString && (\n                        // @TODO consider redefining `groupedFilters` to expose a method like `groupedFilters::filter(splitName): boolean`\n                        groupedFilters.byName.indexOf(splitName) > -1 ||\n                            groupedFilters.byPrefix.some(function (prefix) { return splitName.startsWith(prefix + '__'); }))) {\n                            // * set `cacheReadyButNeedsToFlush` so that `checkCache` returns true (the storage is ready to be used) and the data is cleared before updating on first successful splits fetch\n                            _this.cacheReadyButNeedsToFlush = true;\n                            return;\n                        }\n                        _this.removeSplit(splitName);\n                    });\n                }\n            }\n            catch (e) {\n                this.log.error(LOG_PREFIX + e);\n            }\n        }\n        // if the filter didn't change, nothing is done\n    };\n    return SplitsCacheInLocal;\n}(AbstractSplitsCacheSync));\nexport { SplitsCacheInLocal };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}