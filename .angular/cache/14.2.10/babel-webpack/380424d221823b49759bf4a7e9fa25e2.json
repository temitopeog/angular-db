{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { isFiniteNumber, isNaNNumber } from '../../utils/lang';\nimport { LOG_PREFIX } from './constants';\nimport { AbstractSplitsCacheAsync } from '../AbstractSplitsCacheAsync';\n/**\n * ISplitsCacheAsync implementation for pluggable storages.\n */\nvar SplitsCachePluggable = /** @class */function (_super) {\n  __extends(SplitsCachePluggable, _super);\n  /**\n   * Create a SplitsCache that uses a storage wrapper.\n   * @param log  Logger instance.\n   * @param keys  Key builder.\n   * @param wrapper  Adapted wrapper storage.\n   */\n  function SplitsCachePluggable(log, keys, wrapper) {\n    var _this = _super.call(this) || this;\n    _this.log = log;\n    _this.keys = keys;\n    _this.wrapper = wrapper;\n    return _this;\n  }\n  SplitsCachePluggable.prototype._decrementCounts = function (split) {\n    var _this = this;\n    if (split.trafficTypeName) {\n      var ttKey_1 = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n      return this.wrapper.decr(ttKey_1).then(function (count) {\n        if (count === 0) return _this.wrapper.del(ttKey_1);\n      });\n    }\n  };\n  SplitsCachePluggable.prototype._incrementCounts = function (split) {\n    if (split.trafficTypeName) {\n      var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n      return this.wrapper.incr(ttKey);\n    }\n  };\n  /**\n   * Add a given split.\n   * The returned promise is resolved when the operation success\n   * or rejected if it fails (e.g., wrapper operation fails)\n   */\n  SplitsCachePluggable.prototype.addSplit = function (name, split) {\n    var _this = this;\n    var splitKey = this.keys.buildSplitKey(name);\n    return this.wrapper.get(splitKey).then(function (splitFromStorage) {\n      // handling parsing error\n      var parsedPreviousSplit, parsedSplit;\n      try {\n        parsedPreviousSplit = splitFromStorage ? JSON.parse(splitFromStorage) : undefined;\n        parsedSplit = JSON.parse(split);\n      } catch (e) {\n        throw new Error('Error parsing split definition: ' + e);\n      }\n      return Promise.all([_this.wrapper.set(splitKey, split), _this._incrementCounts(parsedSplit),\n      // If it's an update, we decrement the traffic type and segment count of the existing split,\n      parsedPreviousSplit && _this._decrementCounts(parsedPreviousSplit)]);\n    }).then(function () {\n      return true;\n    });\n  };\n  /**\n   * Add a list of splits.\n   * The returned promise is resolved when the operation success\n   * or rejected if it fails (e.g., wrapper operation fails)\n   */\n  SplitsCachePluggable.prototype.addSplits = function (entries) {\n    var _this = this;\n    return Promise.all(entries.map(function (keyValuePair) {\n      return _this.addSplit(keyValuePair[0], keyValuePair[1]);\n    }));\n  };\n  /**\n   * Remove a given split.\n   * The returned promise is resolved when the operation success, with a boolean indicating if the split existed or not.\n   * or rejected if it fails (e.g., wrapper operation fails).\n   */\n  SplitsCachePluggable.prototype.removeSplit = function (name) {\n    var _this = this;\n    return this.getSplit(name).then(function (split) {\n      if (split) {\n        var parsedSplit = JSON.parse(split);\n        _this._decrementCounts(parsedSplit);\n      }\n      return _this.wrapper.del(_this.keys.buildSplitKey(name));\n    });\n  };\n  /**\n   * Remove a list of splits.\n   * The returned promise is resolved when the operation success, with a boolean array indicating if the splits existed or not.\n   * or rejected if it fails (e.g., wrapper operation fails).\n   */\n  SplitsCachePluggable.prototype.removeSplits = function (names) {\n    var _this = this;\n    return Promise.all(names.map(function (name) {\n      return _this.removeSplit(name);\n    }));\n  };\n  /**\n   * Get split.\n   * The returned promise is resolved with the split definition or null if it's not defined,\n   * or rejected if wrapper operation fails.\n   */\n  SplitsCachePluggable.prototype.getSplit = function (name) {\n    return this.wrapper.get(this.keys.buildSplitKey(name));\n  };\n  /**\n   * Get list of splits.\n   * The returned promise is resolved with a map of split names to their split definition or null if it's not defined,\n   * or rejected if wrapper operation fails.\n   */\n  SplitsCachePluggable.prototype.getSplits = function (names) {\n    var _this = this;\n    var keys = names.map(function (name) {\n      return _this.keys.buildSplitKey(name);\n    });\n    return this.wrapper.getMany(keys).then(function (splitDefinitions) {\n      var splits = {};\n      names.forEach(function (name, idx) {\n        splits[name] = splitDefinitions[idx];\n      });\n      return Promise.resolve(splits);\n    });\n  };\n  /**\n   * Get list of all split definitions.\n   * The returned promise is resolved with the list of split definitions,\n   * or rejected if wrapper operation fails.\n   */\n  SplitsCachePluggable.prototype.getAll = function () {\n    var _this = this;\n    return this.wrapper.getKeysByPrefix(this.keys.buildSplitKeyPrefix()).then(function (listOfKeys) {\n      return Promise.all(listOfKeys.map(_this.wrapper.get));\n    });\n  };\n  /**\n   * Get list of split names.\n   * The returned promise is resolved with the list of split names,\n   * or rejected if wrapper operation fails.\n   */\n  SplitsCachePluggable.prototype.getSplitNames = function () {\n    var _this = this;\n    return this.wrapper.getKeysByPrefix(this.keys.buildSplitKeyPrefix()).then(function (listOfKeys) {\n      return listOfKeys.map(_this.keys.extractKey);\n    });\n  };\n  /**\n   * Check traffic type existence.\n   * The returned promise is resolved with a boolean indicating whether the TT exist or not.\n   * In case of wrapper operation failures, the promise resolves with a true value, assuming that the TT might exist.\n   * It will never be rejected.\n   */\n  SplitsCachePluggable.prototype.trafficTypeExists = function (trafficType) {\n    var _this = this;\n    // If there is a number there should be > 0, otherwise the TT is considered as not existent.\n    return this.wrapper.get(this.keys.buildTrafficTypeKey(trafficType)).then(function (ttCount) {\n      if (ttCount === null) return false; // if entry doesn't exist, means that TT doesn't exist\n      ttCount = parseInt(ttCount, 10);\n      if (!isFiniteNumber(ttCount) || ttCount < 0) {\n        _this.log.info(LOG_PREFIX + (\"Could not validate traffic type existence of \" + trafficType + \" due to data corruption of some sorts.\"));\n        return false;\n      }\n      return ttCount > 0;\n    }).catch(function (e) {\n      _this.log.error(LOG_PREFIX + (\"Could not validate traffic type existence of \" + trafficType + \" due to an error: \" + e + \".\"));\n      // If there is an error, bypass the validation so the event can get tracked.\n      return true;\n    });\n  };\n  /**\n   * Set till number.\n   * The returned promise is resolved when the operation success,\n   * or rejected if it fails (e.g., wrapper operation fails).\n   */\n  SplitsCachePluggable.prototype.setChangeNumber = function (changeNumber) {\n    return this.wrapper.set(this.keys.buildSplitsTillKey(), changeNumber + '');\n  };\n  /**\n   * Get till number or -1 if it's not defined.\n   * The returned promise is resolved with the changeNumber or -1 if it doesn't exist or a wrapper operation fails.\n   * The promise will never be rejected.\n   */\n  SplitsCachePluggable.prototype.getChangeNumber = function () {\n    var _this = this;\n    return this.wrapper.get(this.keys.buildSplitsTillKey()).then(function (value) {\n      var i = parseInt(value, 10);\n      return isNaNNumber(i) ? -1 : i;\n    }).catch(function (e) {\n      _this.log.error(LOG_PREFIX + 'Could not retrieve changeNumber from storage. Error: ' + e);\n      return -1;\n    });\n  };\n  // @TODO implement if required by DataLoader or producer mode\n  SplitsCachePluggable.prototype.clear = function () {\n    return Promise.resolve(true);\n  };\n  return SplitsCachePluggable;\n}(AbstractSplitsCacheAsync);\nexport { SplitsCachePluggable };","map":{"version":3,"names":["__extends","isFiniteNumber","isNaNNumber","LOG_PREFIX","AbstractSplitsCacheAsync","SplitsCachePluggable","_super","log","keys","wrapper","_this","call","prototype","_decrementCounts","split","trafficTypeName","ttKey_1","buildTrafficTypeKey","decr","then","count","del","_incrementCounts","ttKey","incr","addSplit","name","splitKey","buildSplitKey","get","splitFromStorage","parsedPreviousSplit","parsedSplit","JSON","parse","undefined","e","Error","Promise","all","set","addSplits","entries","map","keyValuePair","removeSplit","getSplit","removeSplits","names","getSplits","getMany","splitDefinitions","splits","forEach","idx","resolve","getAll","getKeysByPrefix","buildSplitKeyPrefix","listOfKeys","getSplitNames","extractKey","trafficTypeExists","trafficType","ttCount","parseInt","info","catch","error","setChangeNumber","changeNumber","buildSplitsTillKey","getChangeNumber","value","i","clear"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/pluggable/SplitsCachePluggable.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { isFiniteNumber, isNaNNumber } from '../../utils/lang';\nimport { LOG_PREFIX } from './constants';\nimport { AbstractSplitsCacheAsync } from '../AbstractSplitsCacheAsync';\n/**\n * ISplitsCacheAsync implementation for pluggable storages.\n */\nvar SplitsCachePluggable = /** @class */ (function (_super) {\n    __extends(SplitsCachePluggable, _super);\n    /**\n     * Create a SplitsCache that uses a storage wrapper.\n     * @param log  Logger instance.\n     * @param keys  Key builder.\n     * @param wrapper  Adapted wrapper storage.\n     */\n    function SplitsCachePluggable(log, keys, wrapper) {\n        var _this = _super.call(this) || this;\n        _this.log = log;\n        _this.keys = keys;\n        _this.wrapper = wrapper;\n        return _this;\n    }\n    SplitsCachePluggable.prototype._decrementCounts = function (split) {\n        var _this = this;\n        if (split.trafficTypeName) {\n            var ttKey_1 = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n            return this.wrapper.decr(ttKey_1).then(function (count) {\n                if (count === 0)\n                    return _this.wrapper.del(ttKey_1);\n            });\n        }\n    };\n    SplitsCachePluggable.prototype._incrementCounts = function (split) {\n        if (split.trafficTypeName) {\n            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n            return this.wrapper.incr(ttKey);\n        }\n    };\n    /**\n     * Add a given split.\n     * The returned promise is resolved when the operation success\n     * or rejected if it fails (e.g., wrapper operation fails)\n     */\n    SplitsCachePluggable.prototype.addSplit = function (name, split) {\n        var _this = this;\n        var splitKey = this.keys.buildSplitKey(name);\n        return this.wrapper.get(splitKey).then(function (splitFromStorage) {\n            // handling parsing error\n            var parsedPreviousSplit, parsedSplit;\n            try {\n                parsedPreviousSplit = splitFromStorage ? JSON.parse(splitFromStorage) : undefined;\n                parsedSplit = JSON.parse(split);\n            }\n            catch (e) {\n                throw new Error('Error parsing split definition: ' + e);\n            }\n            return Promise.all([\n                _this.wrapper.set(splitKey, split),\n                _this._incrementCounts(parsedSplit),\n                // If it's an update, we decrement the traffic type and segment count of the existing split,\n                parsedPreviousSplit && _this._decrementCounts(parsedPreviousSplit)\n            ]);\n        }).then(function () { return true; });\n    };\n    /**\n     * Add a list of splits.\n     * The returned promise is resolved when the operation success\n     * or rejected if it fails (e.g., wrapper operation fails)\n     */\n    SplitsCachePluggable.prototype.addSplits = function (entries) {\n        var _this = this;\n        return Promise.all(entries.map(function (keyValuePair) { return _this.addSplit(keyValuePair[0], keyValuePair[1]); }));\n    };\n    /**\n     * Remove a given split.\n     * The returned promise is resolved when the operation success, with a boolean indicating if the split existed or not.\n     * or rejected if it fails (e.g., wrapper operation fails).\n     */\n    SplitsCachePluggable.prototype.removeSplit = function (name) {\n        var _this = this;\n        return this.getSplit(name).then(function (split) {\n            if (split) {\n                var parsedSplit = JSON.parse(split);\n                _this._decrementCounts(parsedSplit);\n            }\n            return _this.wrapper.del(_this.keys.buildSplitKey(name));\n        });\n    };\n    /**\n     * Remove a list of splits.\n     * The returned promise is resolved when the operation success, with a boolean array indicating if the splits existed or not.\n     * or rejected if it fails (e.g., wrapper operation fails).\n     */\n    SplitsCachePluggable.prototype.removeSplits = function (names) {\n        var _this = this;\n        return Promise.all(names.map(function (name) { return _this.removeSplit(name); }));\n    };\n    /**\n     * Get split.\n     * The returned promise is resolved with the split definition or null if it's not defined,\n     * or rejected if wrapper operation fails.\n     */\n    SplitsCachePluggable.prototype.getSplit = function (name) {\n        return this.wrapper.get(this.keys.buildSplitKey(name));\n    };\n    /**\n     * Get list of splits.\n     * The returned promise is resolved with a map of split names to their split definition or null if it's not defined,\n     * or rejected if wrapper operation fails.\n     */\n    SplitsCachePluggable.prototype.getSplits = function (names) {\n        var _this = this;\n        var keys = names.map(function (name) { return _this.keys.buildSplitKey(name); });\n        return this.wrapper.getMany(keys).then(function (splitDefinitions) {\n            var splits = {};\n            names.forEach(function (name, idx) {\n                splits[name] = splitDefinitions[idx];\n            });\n            return Promise.resolve(splits);\n        });\n    };\n    /**\n     * Get list of all split definitions.\n     * The returned promise is resolved with the list of split definitions,\n     * or rejected if wrapper operation fails.\n     */\n    SplitsCachePluggable.prototype.getAll = function () {\n        var _this = this;\n        return this.wrapper.getKeysByPrefix(this.keys.buildSplitKeyPrefix()).then(function (listOfKeys) { return Promise.all(listOfKeys.map(_this.wrapper.get)); });\n    };\n    /**\n     * Get list of split names.\n     * The returned promise is resolved with the list of split names,\n     * or rejected if wrapper operation fails.\n     */\n    SplitsCachePluggable.prototype.getSplitNames = function () {\n        var _this = this;\n        return this.wrapper.getKeysByPrefix(this.keys.buildSplitKeyPrefix()).then(function (listOfKeys) { return listOfKeys.map(_this.keys.extractKey); });\n    };\n    /**\n     * Check traffic type existence.\n     * The returned promise is resolved with a boolean indicating whether the TT exist or not.\n     * In case of wrapper operation failures, the promise resolves with a true value, assuming that the TT might exist.\n     * It will never be rejected.\n     */\n    SplitsCachePluggable.prototype.trafficTypeExists = function (trafficType) {\n        var _this = this;\n        // If there is a number there should be > 0, otherwise the TT is considered as not existent.\n        return this.wrapper.get(this.keys.buildTrafficTypeKey(trafficType))\n            .then(function (ttCount) {\n            if (ttCount === null)\n                return false; // if entry doesn't exist, means that TT doesn't exist\n            ttCount = parseInt(ttCount, 10);\n            if (!isFiniteNumber(ttCount) || ttCount < 0) {\n                _this.log.info(LOG_PREFIX + (\"Could not validate traffic type existence of \" + trafficType + \" due to data corruption of some sorts.\"));\n                return false;\n            }\n            return ttCount > 0;\n        }).catch(function (e) {\n            _this.log.error(LOG_PREFIX + (\"Could not validate traffic type existence of \" + trafficType + \" due to an error: \" + e + \".\"));\n            // If there is an error, bypass the validation so the event can get tracked.\n            return true;\n        });\n    };\n    /**\n     * Set till number.\n     * The returned promise is resolved when the operation success,\n     * or rejected if it fails (e.g., wrapper operation fails).\n     */\n    SplitsCachePluggable.prototype.setChangeNumber = function (changeNumber) {\n        return this.wrapper.set(this.keys.buildSplitsTillKey(), changeNumber + '');\n    };\n    /**\n     * Get till number or -1 if it's not defined.\n     * The returned promise is resolved with the changeNumber or -1 if it doesn't exist or a wrapper operation fails.\n     * The promise will never be rejected.\n     */\n    SplitsCachePluggable.prototype.getChangeNumber = function () {\n        var _this = this;\n        return this.wrapper.get(this.keys.buildSplitsTillKey()).then(function (value) {\n            var i = parseInt(value, 10);\n            return isNaNNumber(i) ? -1 : i;\n        }).catch(function (e) {\n            _this.log.error(LOG_PREFIX + 'Could not retrieve changeNumber from storage. Error: ' + e);\n            return -1;\n        });\n    };\n    // @TODO implement if required by DataLoader or producer mode\n    SplitsCachePluggable.prototype.clear = function () {\n        return Promise.resolve(true);\n    };\n    return SplitsCachePluggable;\n}(AbstractSplitsCacheAsync));\nexport { SplitsCachePluggable };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}