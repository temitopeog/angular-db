{"ast":null,"code":"import { findIndex } from '../../utils/lang';\nimport { thenable } from '../../utils/promise/thenable';\nimport * as LabelsConstants from '../../utils/labels';\nimport { CONTROL } from '../../utils/constants';\nimport { ENGINE_COMBINER_IFELSEIF, ENGINE_COMBINER_IFELSEIF_NO_TREATMENT, ERROR_ENGINE_COMBINER_IFELSEIF } from '../../logger/constants';\nexport function ifElseIfCombinerContext(log, predicates) {\n  function unexpectedInputHandler() {\n    log.error(ERROR_ENGINE_COMBINER_IFELSEIF);\n    return {\n      treatment: CONTROL,\n      label: LabelsConstants.EXCEPTION\n    };\n  }\n  function computeTreatment(predicateResults) {\n    var len = predicateResults.length;\n    for (var i = 0; i < len; i++) {\n      var evaluation = predicateResults[i];\n      if (evaluation !== undefined) {\n        log.debug(ENGINE_COMBINER_IFELSEIF, [evaluation.treatment]);\n        return evaluation;\n      }\n    }\n    log.debug(ENGINE_COMBINER_IFELSEIF_NO_TREATMENT);\n    return undefined;\n  }\n  function ifElseIfCombiner(key, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator) {\n    // In Async environments we are going to have async predicates. There is none way to know\n    // before hand so we need to evaluate all the predicates, verify for thenables, and finally,\n    // define how to return the treatment (wrap result into a Promise or not).\n    var predicateResults = predicates.map(function (evaluator) {\n      return evaluator(key, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator);\n    });\n    // if we find a thenable\n    if (findIndex(predicateResults, thenable) !== -1) {\n      return Promise.all(predicateResults).then(function (results) {\n        return computeTreatment(results);\n      });\n    }\n    return computeTreatment(predicateResults);\n  }\n  // if there is none predicates, then there was an error in parsing phase\n  if (!Array.isArray(predicates) || Array.isArray(predicates) && predicates.length === 0) {\n    return unexpectedInputHandler;\n  } else {\n    return ifElseIfCombiner;\n  }\n}","map":{"version":3,"names":["findIndex","thenable","LabelsConstants","CONTROL","ENGINE_COMBINER_IFELSEIF","ENGINE_COMBINER_IFELSEIF_NO_TREATMENT","ERROR_ENGINE_COMBINER_IFELSEIF","ifElseIfCombinerContext","log","predicates","unexpectedInputHandler","error","treatment","label","EXCEPTION","computeTreatment","predicateResults","len","length","i","evaluation","undefined","debug","ifElseIfCombiner","key","seed","trafficAllocation","trafficAllocationSeed","attributes","splitEvaluator","map","evaluator","Promise","all","then","results","Array","isArray"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/evaluator/combiners/ifelseif.js"],"sourcesContent":["import { findIndex } from '../../utils/lang';\nimport { thenable } from '../../utils/promise/thenable';\nimport * as LabelsConstants from '../../utils/labels';\nimport { CONTROL } from '../../utils/constants';\nimport { ENGINE_COMBINER_IFELSEIF, ENGINE_COMBINER_IFELSEIF_NO_TREATMENT, ERROR_ENGINE_COMBINER_IFELSEIF } from '../../logger/constants';\nexport function ifElseIfCombinerContext(log, predicates) {\n    function unexpectedInputHandler() {\n        log.error(ERROR_ENGINE_COMBINER_IFELSEIF);\n        return {\n            treatment: CONTROL,\n            label: LabelsConstants.EXCEPTION\n        };\n    }\n    function computeTreatment(predicateResults) {\n        var len = predicateResults.length;\n        for (var i = 0; i < len; i++) {\n            var evaluation = predicateResults[i];\n            if (evaluation !== undefined) {\n                log.debug(ENGINE_COMBINER_IFELSEIF, [evaluation.treatment]);\n                return evaluation;\n            }\n        }\n        log.debug(ENGINE_COMBINER_IFELSEIF_NO_TREATMENT);\n        return undefined;\n    }\n    function ifElseIfCombiner(key, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator) {\n        // In Async environments we are going to have async predicates. There is none way to know\n        // before hand so we need to evaluate all the predicates, verify for thenables, and finally,\n        // define how to return the treatment (wrap result into a Promise or not).\n        var predicateResults = predicates.map(function (evaluator) { return evaluator(key, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator); });\n        // if we find a thenable\n        if (findIndex(predicateResults, thenable) !== -1) {\n            return Promise.all(predicateResults).then(function (results) { return computeTreatment(results); });\n        }\n        return computeTreatment(predicateResults);\n    }\n    // if there is none predicates, then there was an error in parsing phase\n    if (!Array.isArray(predicates) || Array.isArray(predicates) && predicates.length === 0) {\n        return unexpectedInputHandler;\n    }\n    else {\n        return ifElseIfCombiner;\n    }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,kBAAkB;AAC5C,SAASC,QAAQ,QAAQ,8BAA8B;AACvD,OAAO,KAAKC,eAAe,MAAM,oBAAoB;AACrD,SAASC,OAAO,QAAQ,uBAAuB;AAC/C,SAASC,wBAAwB,EAAEC,qCAAqC,EAAEC,8BAA8B,QAAQ,wBAAwB;AACxI,OAAO,SAASC,uBAAuB,CAACC,GAAG,EAAEC,UAAU,EAAE;EACrD,SAASC,sBAAsB,GAAG;IAC9BF,GAAG,CAACG,KAAK,CAACL,8BAA8B,CAAC;IACzC,OAAO;MACHM,SAAS,EAAET,OAAO;MAClBU,KAAK,EAAEX,eAAe,CAACY;IAC3B,CAAC;EACL;EACA,SAASC,gBAAgB,CAACC,gBAAgB,EAAE;IACxC,IAAIC,GAAG,GAAGD,gBAAgB,CAACE,MAAM;IACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;MAC1B,IAAIC,UAAU,GAAGJ,gBAAgB,CAACG,CAAC,CAAC;MACpC,IAAIC,UAAU,KAAKC,SAAS,EAAE;QAC1Bb,GAAG,CAACc,KAAK,CAAClB,wBAAwB,EAAE,CAACgB,UAAU,CAACR,SAAS,CAAC,CAAC;QAC3D,OAAOQ,UAAU;MACrB;IACJ;IACAZ,GAAG,CAACc,KAAK,CAACjB,qCAAqC,CAAC;IAChD,OAAOgB,SAAS;EACpB;EACA,SAASE,gBAAgB,CAACC,GAAG,EAAEC,IAAI,EAAEC,iBAAiB,EAAEC,qBAAqB,EAAEC,UAAU,EAAEC,cAAc,EAAE;IACvG;IACA;IACA;IACA,IAAIb,gBAAgB,GAAGP,UAAU,CAACqB,GAAG,CAAC,UAAUC,SAAS,EAAE;MAAE,OAAOA,SAAS,CAACP,GAAG,EAAEC,IAAI,EAAEC,iBAAiB,EAAEC,qBAAqB,EAAEC,UAAU,EAAEC,cAAc,CAAC;IAAE,CAAC,CAAC;IAClK;IACA,IAAI7B,SAAS,CAACgB,gBAAgB,EAAEf,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;MAC9C,OAAO+B,OAAO,CAACC,GAAG,CAACjB,gBAAgB,CAAC,CAACkB,IAAI,CAAC,UAAUC,OAAO,EAAE;QAAE,OAAOpB,gBAAgB,CAACoB,OAAO,CAAC;MAAE,CAAC,CAAC;IACvG;IACA,OAAOpB,gBAAgB,CAACC,gBAAgB,CAAC;EAC7C;EACA;EACA,IAAI,CAACoB,KAAK,CAACC,OAAO,CAAC5B,UAAU,CAAC,IAAI2B,KAAK,CAACC,OAAO,CAAC5B,UAAU,CAAC,IAAIA,UAAU,CAACS,MAAM,KAAK,CAAC,EAAE;IACpF,OAAOR,sBAAsB;EACjC,CAAC,MACI;IACD,OAAOa,gBAAgB;EAC3B;AACJ"},"metadata":{},"sourceType":"module"}