{"ast":null,"code":"import { CONNECTION_ESTABLISHED, DISABLED, ENABLED, OCCUPANCY_PRI, OCCUPANCY_SEC, PAUSED, STREAMING_STATUS } from '../../../utils/constants';\nimport { ControlType, PUSH_SUBSYSTEM_UP, PUSH_NONRETRYABLE_ERROR, PUSH_SUBSYSTEM_DOWN } from '../constants';\nvar CONTROL_CHANNEL_REGEXS = [/control_pri$/, /control_sec$/];\nvar STREAMING_EVENT_TYPES = [OCCUPANCY_PRI, OCCUPANCY_SEC];\n/**\n * Factory of notification keeper, which process OCCUPANCY and CONTROL notifications and emits the corresponding push events.\n *\n * @param pushEmitter emitter for events related to streaming support\n */\n// @TODO update logic to handle OCCUPANCY for any region and rename according to new spec (e.g.: PUSH_SUBSYSTEM_UP --> PUSH_SUBSYSTEM_UP)\nexport function notificationKeeperFactory(pushEmitter, telemetryTracker) {\n  var channels = CONTROL_CHANNEL_REGEXS.map(function (regex) {\n    return {\n      regex: regex,\n      hasPublishers: true,\n      oTime: -1,\n      cTime: -1 // keep track of most recent control notification timestamp per channel\n    };\n  });\n  // false if the number of publishers is equal to 0 in all regions\n  var hasPublishers = true;\n  // false if last CONTROL event was STREAMING_PAUSED or STREAMING_DISABLED\n  var hasResumed = true;\n  function getHasPublishers() {\n    return channels.some(function (c) {\n      return c.hasPublishers;\n    });\n  }\n  return {\n    handleOpen: function () {\n      telemetryTracker.streamingEvent(CONNECTION_ESTABLISHED);\n      pushEmitter.emit(PUSH_SUBSYSTEM_UP);\n    },\n    isStreamingUp: function () {\n      return hasResumed && hasPublishers;\n    },\n    handleOccupancyEvent: function (publishers, channel, timestamp) {\n      for (var i = 0; i < channels.length; i++) {\n        var c = channels[i];\n        if (c.regex.test(channel)) {\n          telemetryTracker.streamingEvent(STREAMING_EVENT_TYPES[i], publishers);\n          if (timestamp > c.oTime) {\n            c.oTime = timestamp;\n            c.hasPublishers = publishers !== 0;\n            var hasPublishersNow = getHasPublishers();\n            if (hasResumed) {\n              if (!hasPublishersNow && hasPublishers) {\n                pushEmitter.emit(PUSH_SUBSYSTEM_DOWN);\n              } else if (hasPublishersNow && !hasPublishers) {\n                pushEmitter.emit(PUSH_SUBSYSTEM_UP);\n              }\n              // nothing to do when hasResumed === false:\n              // streaming is already down for `!hasPublishersNow`, and cannot be up for `hasPublishersNow`\n            }\n\n            hasPublishers = hasPublishersNow;\n          }\n          return;\n        }\n      }\n    },\n    handleControlEvent: function (controlType, channel, timestamp) {\n      /* STREAMING_RESET control event is handled by PushManager directly since it doesn't require\n       * tracking timestamp and state like OCCUPANCY or CONTROL. It also ignores previous\n       * OCCUPANCY and CONTROL notifications, and whether PUSH_SUBSYSTEM_DOWN has been emitted or not */\n      if (controlType === ControlType.STREAMING_RESET) {\n        pushEmitter.emit(controlType);\n        return;\n      }\n      for (var i = 0; i < channels.length; i++) {\n        var c = channels[i];\n        if (c.regex.test(channel)) {\n          if (timestamp > c.cTime) {\n            c.cTime = timestamp;\n            if (controlType === ControlType.STREAMING_DISABLED) {\n              telemetryTracker.streamingEvent(STREAMING_STATUS, DISABLED);\n              pushEmitter.emit(PUSH_NONRETRYABLE_ERROR);\n            } else if (hasPublishers) {\n              if (controlType === ControlType.STREAMING_PAUSED && hasResumed) {\n                telemetryTracker.streamingEvent(STREAMING_STATUS, PAUSED);\n                pushEmitter.emit(PUSH_SUBSYSTEM_DOWN);\n              } else if (controlType === ControlType.STREAMING_RESUMED && !hasResumed) {\n                telemetryTracker.streamingEvent(STREAMING_STATUS, ENABLED);\n                pushEmitter.emit(PUSH_SUBSYSTEM_UP);\n              }\n              // nothing to do when hasPublishers === false:\n              // streaming is already down for `STREAMING_PAUSED`, and cannot be up for `STREAMING_RESUMED`\n            }\n\n            hasResumed = controlType === ControlType.STREAMING_RESUMED;\n          }\n          return;\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["CONNECTION_ESTABLISHED","DISABLED","ENABLED","OCCUPANCY_PRI","OCCUPANCY_SEC","PAUSED","STREAMING_STATUS","ControlType","PUSH_SUBSYSTEM_UP","PUSH_NONRETRYABLE_ERROR","PUSH_SUBSYSTEM_DOWN","CONTROL_CHANNEL_REGEXS","STREAMING_EVENT_TYPES","notificationKeeperFactory","pushEmitter","telemetryTracker","channels","map","regex","hasPublishers","oTime","cTime","hasResumed","getHasPublishers","some","c","handleOpen","streamingEvent","emit","isStreamingUp","handleOccupancyEvent","publishers","channel","timestamp","i","length","test","hasPublishersNow","handleControlEvent","controlType","STREAMING_RESET","STREAMING_DISABLED","STREAMING_PAUSED","STREAMING_RESUMED"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/streaming/SSEHandler/NotificationKeeper.js"],"sourcesContent":["import { CONNECTION_ESTABLISHED, DISABLED, ENABLED, OCCUPANCY_PRI, OCCUPANCY_SEC, PAUSED, STREAMING_STATUS } from '../../../utils/constants';\nimport { ControlType, PUSH_SUBSYSTEM_UP, PUSH_NONRETRYABLE_ERROR, PUSH_SUBSYSTEM_DOWN } from '../constants';\nvar CONTROL_CHANNEL_REGEXS = [/control_pri$/, /control_sec$/];\nvar STREAMING_EVENT_TYPES = [OCCUPANCY_PRI, OCCUPANCY_SEC];\n/**\n * Factory of notification keeper, which process OCCUPANCY and CONTROL notifications and emits the corresponding push events.\n *\n * @param pushEmitter emitter for events related to streaming support\n */\n// @TODO update logic to handle OCCUPANCY for any region and rename according to new spec (e.g.: PUSH_SUBSYSTEM_UP --> PUSH_SUBSYSTEM_UP)\nexport function notificationKeeperFactory(pushEmitter, telemetryTracker) {\n    var channels = CONTROL_CHANNEL_REGEXS.map(function (regex) { return ({\n        regex: regex,\n        hasPublishers: true,\n        oTime: -1,\n        cTime: -1 // keep track of most recent control notification timestamp per channel\n    }); });\n    // false if the number of publishers is equal to 0 in all regions\n    var hasPublishers = true;\n    // false if last CONTROL event was STREAMING_PAUSED or STREAMING_DISABLED\n    var hasResumed = true;\n    function getHasPublishers() {\n        return channels.some(function (c) { return c.hasPublishers; });\n    }\n    return {\n        handleOpen: function () {\n            telemetryTracker.streamingEvent(CONNECTION_ESTABLISHED);\n            pushEmitter.emit(PUSH_SUBSYSTEM_UP);\n        },\n        isStreamingUp: function () {\n            return hasResumed && hasPublishers;\n        },\n        handleOccupancyEvent: function (publishers, channel, timestamp) {\n            for (var i = 0; i < channels.length; i++) {\n                var c = channels[i];\n                if (c.regex.test(channel)) {\n                    telemetryTracker.streamingEvent(STREAMING_EVENT_TYPES[i], publishers);\n                    if (timestamp > c.oTime) {\n                        c.oTime = timestamp;\n                        c.hasPublishers = publishers !== 0;\n                        var hasPublishersNow = getHasPublishers();\n                        if (hasResumed) {\n                            if (!hasPublishersNow && hasPublishers) {\n                                pushEmitter.emit(PUSH_SUBSYSTEM_DOWN);\n                            }\n                            else if (hasPublishersNow && !hasPublishers) {\n                                pushEmitter.emit(PUSH_SUBSYSTEM_UP);\n                            }\n                            // nothing to do when hasResumed === false:\n                            // streaming is already down for `!hasPublishersNow`, and cannot be up for `hasPublishersNow`\n                        }\n                        hasPublishers = hasPublishersNow;\n                    }\n                    return;\n                }\n            }\n        },\n        handleControlEvent: function (controlType, channel, timestamp) {\n            /* STREAMING_RESET control event is handled by PushManager directly since it doesn't require\n             * tracking timestamp and state like OCCUPANCY or CONTROL. It also ignores previous\n             * OCCUPANCY and CONTROL notifications, and whether PUSH_SUBSYSTEM_DOWN has been emitted or not */\n            if (controlType === ControlType.STREAMING_RESET) {\n                pushEmitter.emit(controlType);\n                return;\n            }\n            for (var i = 0; i < channels.length; i++) {\n                var c = channels[i];\n                if (c.regex.test(channel)) {\n                    if (timestamp > c.cTime) {\n                        c.cTime = timestamp;\n                        if (controlType === ControlType.STREAMING_DISABLED) {\n                            telemetryTracker.streamingEvent(STREAMING_STATUS, DISABLED);\n                            pushEmitter.emit(PUSH_NONRETRYABLE_ERROR);\n                        }\n                        else if (hasPublishers) {\n                            if (controlType === ControlType.STREAMING_PAUSED && hasResumed) {\n                                telemetryTracker.streamingEvent(STREAMING_STATUS, PAUSED);\n                                pushEmitter.emit(PUSH_SUBSYSTEM_DOWN);\n                            }\n                            else if (controlType === ControlType.STREAMING_RESUMED && !hasResumed) {\n                                telemetryTracker.streamingEvent(STREAMING_STATUS, ENABLED);\n                                pushEmitter.emit(PUSH_SUBSYSTEM_UP);\n                            }\n                            // nothing to do when hasPublishers === false:\n                            // streaming is already down for `STREAMING_PAUSED`, and cannot be up for `STREAMING_RESUMED`\n                        }\n                        hasResumed = controlType === ControlType.STREAMING_RESUMED;\n                    }\n                    return;\n                }\n            }\n        },\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}