{"ast":null,"code":"import { get } from '../utils/lang';\nimport { parser } from './parser';\nimport { keyParser } from '../utils/key';\nimport { thenable } from '../utils/promise/thenable';\nimport * as LabelsConstants from '../utils/labels';\nimport { CONTROL } from '../utils/constants';\nfunction evaluationResult(result, defaultTreatment) {\n  return {\n    treatment: get(result, 'treatment', defaultTreatment),\n    label: get(result, 'label', LabelsConstants.NO_CONDITION_MATCH)\n  };\n}\nvar Engine = /** @class */function () {\n  function Engine(baseInfo, evaluator) {\n    this.baseInfo = baseInfo;\n    this.evaluator = evaluator;\n    // in case we don't have a default treatment in the instanciation, use 'control'\n    if (typeof this.baseInfo.defaultTreatment !== 'string') {\n      this.baseInfo.defaultTreatment = CONTROL;\n    }\n  }\n  Engine.parse = function (log, splitFlatStructure, storage) {\n    var conditions = splitFlatStructure.conditions;\n    var evaluator = parser(log, conditions, storage);\n    return new Engine(splitFlatStructure, evaluator);\n  };\n  Engine.prototype.getKey = function () {\n    return this.baseInfo.name;\n  };\n  Engine.prototype.getTreatment = function (key, attributes, splitEvaluator) {\n    var _a = this.baseInfo,\n      killed = _a.killed,\n      seed = _a.seed,\n      defaultTreatment = _a.defaultTreatment,\n      trafficAllocation = _a.trafficAllocation,\n      trafficAllocationSeed = _a.trafficAllocationSeed;\n    var parsedKey;\n    var treatment;\n    var label;\n    try {\n      parsedKey = keyParser(key);\n    } catch (err) {\n      return {\n        treatment: CONTROL,\n        label: LabelsConstants.EXCEPTION\n      };\n    }\n    if (this.isGarbage()) {\n      treatment = CONTROL;\n      label = LabelsConstants.SPLIT_ARCHIVED;\n    } else if (killed) {\n      treatment = defaultTreatment;\n      label = LabelsConstants.SPLIT_KILLED;\n    } else {\n      var evaluation = this.evaluator(parsedKey, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator);\n      // Evaluation could be async, so we should handle that case checking for a\n      // thenable object\n      if (thenable(evaluation)) {\n        return evaluation.then(function (result) {\n          return evaluationResult(result, defaultTreatment);\n        });\n      } else {\n        return evaluationResult(evaluation, defaultTreatment);\n      }\n    }\n    return {\n      treatment: treatment,\n      label: label\n    };\n  };\n  Engine.prototype.isGarbage = function () {\n    return this.baseInfo.status === 'ARCHIVED';\n  };\n  Engine.prototype.getChangeNumber = function () {\n    return this.baseInfo.changeNumber;\n  };\n  return Engine;\n}();\nexport { Engine };","map":{"version":3,"names":["get","parser","keyParser","thenable","LabelsConstants","CONTROL","evaluationResult","result","defaultTreatment","treatment","label","NO_CONDITION_MATCH","Engine","baseInfo","evaluator","parse","log","splitFlatStructure","storage","conditions","prototype","getKey","name","getTreatment","key","attributes","splitEvaluator","_a","killed","seed","trafficAllocation","trafficAllocationSeed","parsedKey","err","EXCEPTION","isGarbage","SPLIT_ARCHIVED","SPLIT_KILLED","evaluation","then","status","getChangeNumber","changeNumber"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/evaluator/Engine.js"],"sourcesContent":["import { get } from '../utils/lang';\nimport { parser } from './parser';\nimport { keyParser } from '../utils/key';\nimport { thenable } from '../utils/promise/thenable';\nimport * as LabelsConstants from '../utils/labels';\nimport { CONTROL } from '../utils/constants';\nfunction evaluationResult(result, defaultTreatment) {\n    return {\n        treatment: get(result, 'treatment', defaultTreatment),\n        label: get(result, 'label', LabelsConstants.NO_CONDITION_MATCH)\n    };\n}\nvar Engine = /** @class */ (function () {\n    function Engine(baseInfo, evaluator) {\n        this.baseInfo = baseInfo;\n        this.evaluator = evaluator;\n        // in case we don't have a default treatment in the instanciation, use 'control'\n        if (typeof this.baseInfo.defaultTreatment !== 'string') {\n            this.baseInfo.defaultTreatment = CONTROL;\n        }\n    }\n    Engine.parse = function (log, splitFlatStructure, storage) {\n        var conditions = splitFlatStructure.conditions;\n        var evaluator = parser(log, conditions, storage);\n        return new Engine(splitFlatStructure, evaluator);\n    };\n    Engine.prototype.getKey = function () {\n        return this.baseInfo.name;\n    };\n    Engine.prototype.getTreatment = function (key, attributes, splitEvaluator) {\n        var _a = this.baseInfo, killed = _a.killed, seed = _a.seed, defaultTreatment = _a.defaultTreatment, trafficAllocation = _a.trafficAllocation, trafficAllocationSeed = _a.trafficAllocationSeed;\n        var parsedKey;\n        var treatment;\n        var label;\n        try {\n            parsedKey = keyParser(key);\n        }\n        catch (err) {\n            return {\n                treatment: CONTROL,\n                label: LabelsConstants.EXCEPTION\n            };\n        }\n        if (this.isGarbage()) {\n            treatment = CONTROL;\n            label = LabelsConstants.SPLIT_ARCHIVED;\n        }\n        else if (killed) {\n            treatment = defaultTreatment;\n            label = LabelsConstants.SPLIT_KILLED;\n        }\n        else {\n            var evaluation = this.evaluator(parsedKey, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator);\n            // Evaluation could be async, so we should handle that case checking for a\n            // thenable object\n            if (thenable(evaluation)) {\n                return evaluation.then(function (result) { return evaluationResult(result, defaultTreatment); });\n            }\n            else {\n                return evaluationResult(evaluation, defaultTreatment);\n            }\n        }\n        return {\n            treatment: treatment,\n            label: label\n        };\n    };\n    Engine.prototype.isGarbage = function () {\n        return this.baseInfo.status === 'ARCHIVED';\n    };\n    Engine.prototype.getChangeNumber = function () {\n        return this.baseInfo.changeNumber;\n    };\n    return Engine;\n}());\nexport { Engine };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}