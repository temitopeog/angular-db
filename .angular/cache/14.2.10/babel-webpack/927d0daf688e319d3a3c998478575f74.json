{"ast":null,"code":"import { ɵɵdefineInjectable, Injectable, ɵɵinject } from '@angular/core';\nimport { SplitFactory } from '@splitsoftware/splitio-browserjs';\nimport * as ɵngcc0 from '@angular/core';\nexport { DebugLogger, ErrorLogger, InLocalStorage, InfoLogger, LocalhostFromObject, WarnLogger } from '@splitsoftware/splitio-browserjs';\nimport { Observable, from } from 'rxjs';\n\n/**\n * SDK constant for control treatment\n */\nconst CONTROL = 'control';\n/**\n * string constant for observable to return when client exists for a key\n */\nconst INIT_CLIENT_EXISTS = 'init::clientExists';\n/**\n * string constant for observable to return when client is not initialized\n */\nconst INIT_CLIENT_FIRST = 'init::clientFirst';\nconst VERSION = 'angular-' + '0.3.0';\nconst ɵ0 = () => {\n    return CONTROL;\n  },\n  ɵ1 = () => {\n    return {\n      treatment: CONTROL,\n      config: null\n    };\n  },\n  ɵ2 = splitNames => {\n    let result = {};\n    splitNames.forEach(splitName => {\n      result = Object.assign(Object.assign({}, result), {\n        [splitName]: CONTROL\n      });\n    });\n    return result;\n  },\n  ɵ3 = splitNames => {\n    let result = {};\n    splitNames.forEach(splitName => {\n      result = Object.assign(Object.assign({}, result), {\n        [splitName]: {\n          treatment: CONTROL,\n          config: null\n        }\n      });\n    });\n    return result;\n  },\n  ɵ4 = () => {\n    return false;\n  };\n/**\n * client with methods that return default values\n */\nconst CONTROL_CLIENT = {\n  getTreatment: ɵ0,\n  getTreatmentWithConfig: ɵ1,\n  getTreatments: ɵ2,\n  getTreatmentsWithConfig: ɵ3,\n  track: ɵ4\n};\nconst ɵ5 = () => {\n    return [];\n  },\n  ɵ6 = () => {\n    return null;\n  },\n  ɵ7 = () => {\n    return [];\n  };\n/**\n *  with methods that return default values\n */\nconst DEFAULT_MANAGER = {\n  splits: ɵ5,\n  split: ɵ6,\n  names: ɵ7\n};\nfunction buildInstance(key) {\n  // @ts-ignore\n  if (!key.bucketingKey) return key;\n  // @ts-ignore\n  return `${key.matchingKey ? key.matchingKey : key}-${key.bucketingKey ? key.bucketingKey : key}-`;\n}\nfunction parseTreatmentParams(param1, param2, param3) {\n  if (isString(param2) || Array.isArray(param2)) return {\n    key: param1,\n    splitNames: param2,\n    attributes: param3\n  };\n  return {\n    key: undefined,\n    splitNames: param1,\n    attributes: param2\n  };\n}\nfunction parseTrackParams(param1, param2, param3, param4, param5) {\n  if (isString(param3)) return {\n    key: param1,\n    trafficType: param2,\n    eventType: param3,\n    value: param4,\n    properties: param5\n  };\n  return {\n    key: undefined,\n    trafficType: param1,\n    eventType: param2,\n    value: param3,\n    properties: param4\n  };\n}\nfunction isString(val) {\n  return typeof val === 'string' || val instanceof String;\n}\nclass SplitService {\n  constructor() {\n    /**\n     * Map of intialized clients\n     */\n    this.clientsMap = new Map();\n    /**\n     * Map of events status of intialized clients\n     */\n    this.emittedEvents = new Map();\n    /**\n     * Flag to determine if SDK is ready or not.\n     */\n    this.isSDKReady = false;\n  }\n  /**\n   * This method initializes the SDK with the required Browser APIKEY\n   * and the 'key' according to the Traffic type set (ex.: an user id).\n   * @function init\n   * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  init(config) {\n    if (this.splitio) {\n      console.log('[ERROR] There is another instance of the SDK.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    this.config = config;\n    // @ts-ignore. 2nd param is not part of type definitions. Used to overwrite the version of the SDK for correct tracking.\n    this.splitio = SplitFactory(config, modules => {\n      modules.settings.version = VERSION;\n    });\n    this.splitClient = this.splitio.client();\n    this.splitManager = this.splitio.manager();\n    this.sdkInitEventObservable();\n    const instanceKey = buildInstance(this.config.core.key);\n    const sdkReady = this.splitClient.Event.SDK_READY;\n    this.splitClient.on(sdkReady, () => {\n      this.emittedEvents.set(instanceKey + sdkReady, true);\n      this.isSDKReady = true;\n    });\n    this.clientsMap.set(instanceKey, this.splitClient);\n    return this.sdkReady$;\n  }\n  /**\n   * Returns a shared client of the SDK, associated with the given key\n   * @function initClient\n   * @param {SplitKey} key The key for the new client instance.\n   * @returns {Observable<string>} Returns when sdk is ready\n   */\n  initClient(key) {\n    let client = this.getSDKClient(key);\n    if (client) {\n      console.log('[WARN] client for key ' + buildInstance(key) + ' is already initialized.');\n      return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n    }\n    if (!this.splitio) return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    client = this.splitio.client(key);\n    this.clientsMap.set(buildInstance(key), client);\n    return this.toObservable(key, client, client.Event.SDK_READY);\n  }\n  getClientObservable(key, event, isOneTimeEvent = true) {\n    const client = this.getClient(key);\n    if (client === CONTROL_CLIENT) {\n      return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n    }\n    return this.toObservable(key, client, client.Event[event], isOneTimeEvent);\n  }\n  /**\n   * Returns an observable that calls back when the client is ready\n   * @function getClientSDKReady\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReady(key) {\n    return this.getClientObservable(key, 'SDK_READY');\n  }\n  /**\n   * Returns an observable that calls back when the client ready event is timed out\n   * @function getClientSDKReadyTimedOut\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyTimedOut(key) {\n    return this.getClientObservable(key, 'SDK_READY_TIMED_OUT');\n  }\n  /**\n   * Returns an observable that calls back when the client is ready from cache\n   * @function getClientSDKReadyFromCache\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKReadyFromCache(key) {\n    return this.getClientObservable(key, 'SDK_READY_FROM_CACHE');\n  }\n  /**\n   * Returns an observable that calls back when the client is updated\n   * @function getClientSDKUpdate\n   * @param {SplitKey} key The key for the client instance.\n   * @returns {Observable<string>}\n   */\n  getClientSDKUpdate(key) {\n    return this.getClientObservable(key, 'SDK_UPDATE', false);\n  }\n  /**\n   * initialize sdk Events into observables\n   */\n  sdkInitEventObservable() {\n    const client = this.splitClient;\n    const mainKey = this.config.core.key;\n    this.sdkReady$ = this.toObservable(mainKey, client, client.Event.SDK_READY);\n    this.sdkReadyTimedOut$ = this.toObservable(mainKey, client, client.Event.SDK_READY_TIMED_OUT);\n    this.sdkReadyFromCache$ = this.toObservable(mainKey, client, client.Event.SDK_READY_FROM_CACHE);\n    this.sdkUpdate$ = this.toObservable(mainKey, client, client.Event.SDK_UPDATE, false);\n  }\n  /**\n   * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).\n   * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,\n   * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.\n   * @returns Promise<void>\n   */\n  ready() {\n    return this.getClient().ready();\n  }\n  isInitialized() {\n    if (!this.splitio) {\n      console.log('[ERROR] plugin should be initialized');\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the SDK client\n   * @param {SplitKey=} key The key for the client instance.\n   * @returns {IClient} split client.\n   */\n  getSDKClient(key) {\n    if (!this.isInitialized()) return undefined;\n    key = key ? key : this.config.core.key;\n    return this.clientsMap.get(buildInstance(key));\n  }\n  /**\n   * Returns the SDK factory\n   * @returns {ISDK} split factory\n   */\n  getSDKFactory() {\n    if (!this.isInitialized()) return undefined;\n    return this.splitio;\n  }\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  getClient(key) {\n    const client = this.getSDKClient(key);\n    if (!client) {\n      console.log('[ERROR] client' + (key ? ' for key ' + buildInstance(key) : '') + ' should be initialized first.');\n      return CONTROL_CLIENT;\n    }\n    return client;\n  }\n  getTreatment(param1, param2, param3) {\n    const {\n      key,\n      splitNames,\n      attributes\n    } = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatment(splitNames, attributes);\n  }\n  getTreatmentWithConfig(param1, param2, param3) {\n    const {\n      key,\n      splitNames,\n      attributes\n    } = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentWithConfig(splitNames, attributes);\n  }\n  getTreatments(param1, param2, param3) {\n    const {\n      key,\n      splitNames,\n      attributes\n    } = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatments(splitNames, attributes);\n  }\n  getTreatmentsWithConfig(param1, param2, param3) {\n    const {\n      key,\n      splitNames,\n      attributes\n    } = parseTreatmentParams(param1, param2, param3);\n    return this.getClient(key).getTreatmentsWithConfig(splitNames, attributes);\n  }\n  track(param1, param2, param3, param4, param5) {\n    const {\n      key,\n      trafficType,\n      eventType,\n      value,\n      properties\n    } = parseTrackParams(param1, param2, param3, param4, param5);\n    return this.getClient(key).track(trafficType, eventType, value, properties);\n  }\n  /**\n   * Validates key and returns client if it is initialized for key or controlClient if it isn't\n   */\n  getManager() {\n    const client = this.getSDKClient();\n    if (!client) {\n      console.log('[ERROR] The SDK has not being initialized. Returning default response for method call.');\n      return DEFAULT_MANAGER;\n    }\n    return this.splitManager;\n  }\n  /**\n   * Get the array of splits data in SplitView format.\n   * @function getSplits\n   * @returns {SplitViews} The list of SplitIO.SplitView.\n   */\n  getSplits() {\n    return this.getManager().splits();\n  }\n  /**\n   * Get the data of a split in SplitView format.\n   * @function getSplit\n   * @param {string} splitName The name of the split we wan't to get info of.\n   * @returns {SplitView} The SplitIO.SplitView of the given split.\n   */\n  getSplit(splitName) {\n    return this.getManager().split(splitName);\n  }\n  /**\n   * Get the array of Split names.\n   * @function getSplitNames\n   * @returns {SplitNames} The lists of Split names.\n   */\n  getSplitNames() {\n    return this.getManager().names();\n  }\n  /**\n   * Destroy all clients instances.\n   * @function destroy\n   * @returns {Observable<unknown>}\n   */\n  destroy() {\n    const mainInstanceKey = buildInstance(this.config.core.key);\n    this.clientsMap.forEach((client, key) => {\n      if (buildInstance(key) !== mainInstanceKey) {\n        client.destroy();\n        this.clientsMap.delete(buildInstance(key));\n      }\n    });\n    this.clientsMap.delete(mainInstanceKey);\n    this.splitio = undefined;\n    return from(this.splitClient.destroy());\n  }\n  /**\n   * Private function to return as observable the event on parameter\n   * @param {string} event\n   * @param response\n   * @returns Observable<any>\n   */\n  toObservable(key, client, event, isOneTimeEvent = true) {\n    const eventKey = buildInstance(key) + event;\n    if (isOneTimeEvent) {\n      return new Observable(subscriber => {\n        const wasEventEmitted = this.emittedEvents.get(eventKey);\n        if (wasEventEmitted) {\n          Promise.resolve().then(() => subscriber.next(event));\n        } else {\n          client.once(event, () => {\n            this.emittedEvents.set(eventKey, true);\n            subscriber.next(event);\n          });\n        }\n      });\n    } else {\n      return new Observable(subscriber => {\n        client.on(event, () => {\n          subscriber.next(event);\n        });\n      });\n    }\n  }\n}\nSplitService.ɵfac = function SplitService_Factory(t) {\n  return new (t || SplitService)();\n};\nSplitService.ɵprov = ɵɵdefineInjectable({\n  factory: function SplitService_Factory() {\n    return new SplitService();\n  },\n  token: SplitService,\n  providedIn: \"root\"\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\nclass SplitioGuard {\n  constructor(splitService) {\n    this.splitService = splitService;\n  }\n  canActivate() {\n    return this.splitService.isSDKReady;\n  }\n  canLoad() {\n    return this.splitService.isSDKReady;\n  }\n  canActivateChild() {\n    return this.splitService.isSDKReady;\n  }\n}\nSplitioGuard.ɵfac = function SplitioGuard_Factory(t) {\n  return new (t || SplitioGuard)(ɵngcc0.ɵɵinject(SplitService));\n};\nSplitioGuard.ɵprov = ɵɵdefineInjectable({\n  factory: function SplitioGuard_Factory() {\n    return new SplitioGuard(ɵɵinject(SplitService));\n  },\n  token: SplitioGuard,\n  providedIn: \"root\"\n});\nSplitioGuard.ctorParameters = () => [{\n  type: SplitService\n}];\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitioGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: SplitService\n    }];\n  }, null);\n})();\n\n/*\n * Public API Surface of splitio\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SplitService, SplitioGuard };","map":{"version":3,"names":["ɵɵdefineInjectable","Injectable","ɵɵinject","SplitFactory","ɵngcc0","DebugLogger","ErrorLogger","InLocalStorage","InfoLogger","LocalhostFromObject","WarnLogger","Observable","from","CONTROL","INIT_CLIENT_EXISTS","INIT_CLIENT_FIRST","VERSION","ɵ0","ɵ1","treatment","config","ɵ2","splitNames","result","forEach","splitName","Object","assign","ɵ3","ɵ4","CONTROL_CLIENT","getTreatment","getTreatmentWithConfig","getTreatments","getTreatmentsWithConfig","track","ɵ5","ɵ6","ɵ7","DEFAULT_MANAGER","splits","split","names","buildInstance","key","bucketingKey","matchingKey","parseTreatmentParams","param1","param2","param3","isString","Array","isArray","attributes","undefined","parseTrackParams","param4","param5","trafficType","eventType","value","properties","val","String","SplitService","constructor","clientsMap","Map","emittedEvents","isSDKReady","init","splitio","console","log","observer","error","modules","settings","version","splitClient","client","splitManager","manager","sdkInitEventObservable","instanceKey","core","sdkReady","Event","SDK_READY","on","set","sdkReady$","initClient","getSDKClient","toObservable","getClientObservable","event","isOneTimeEvent","getClient","getClientSDKReady","getClientSDKReadyTimedOut","getClientSDKReadyFromCache","getClientSDKUpdate","mainKey","sdkReadyTimedOut$","SDK_READY_TIMED_OUT","sdkReadyFromCache$","SDK_READY_FROM_CACHE","sdkUpdate$","SDK_UPDATE","ready","isInitialized","get","getSDKFactory","getManager","getSplits","getSplit","getSplitNames","destroy","mainInstanceKey","delete","eventKey","subscriber","wasEventEmitted","Promise","resolve","then","next","once","ɵfac","SplitService_Factory","t","ɵprov","factory","token","providedIn","ngDevMode","ɵsetClassMetadata","type","args","SplitioGuard","splitService","canActivate","canLoad","canActivateChild","SplitioGuard_Factory","ctorParameters"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-angular/__ivy_ngcc__/fesm2015/splitsoftware-splitio-angular.js"],"sourcesContent":["import { ɵɵdefineInjectable, Injectable, ɵɵinject } from '@angular/core';\nimport { SplitFactory } from '@splitsoftware/splitio-browserjs';\nimport * as ɵngcc0 from '@angular/core';\nexport { DebugLogger, ErrorLogger, InLocalStorage, InfoLogger, LocalhostFromObject, WarnLogger } from '@splitsoftware/splitio-browserjs';\nimport { Observable, from } from 'rxjs';\n\n/**\n * SDK constant for control treatment\n */\nconst CONTROL = 'control';\n/**\n * string constant for observable to return when client exists for a key\n */\nconst INIT_CLIENT_EXISTS = 'init::clientExists';\n/**\n * string constant for observable to return when client is not initialized\n */\nconst INIT_CLIENT_FIRST = 'init::clientFirst';\nconst VERSION = 'angular-' + '0.3.0';\nconst ɵ0 = () => { return CONTROL; }, ɵ1 = () => { return { treatment: CONTROL, config: null }; }, ɵ2 = (splitNames) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n        result = Object.assign(Object.assign({}, result), { [splitName]: CONTROL });\n    });\n    return result;\n}, ɵ3 = (splitNames) => {\n    let result = {};\n    splitNames.forEach((splitName) => {\n        result = Object.assign(Object.assign({}, result), { [splitName]: { treatment: CONTROL, config: null } });\n    });\n    return result;\n}, ɵ4 = () => { return false; };\n/**\n * client with methods that return default values\n */\nconst CONTROL_CLIENT = {\n    getTreatment: ɵ0,\n    getTreatmentWithConfig: ɵ1,\n    getTreatments: ɵ2,\n    getTreatmentsWithConfig: ɵ3,\n    track: ɵ4\n};\nconst ɵ5 = () => { return []; }, ɵ6 = () => { return null; }, ɵ7 = () => { return []; };\n/**\n *  with methods that return default values\n */\nconst DEFAULT_MANAGER = {\n    splits: ɵ5,\n    split: ɵ6,\n    names: ɵ7\n};\n\nfunction buildInstance(key) {\n    // @ts-ignore\n    if (!key.bucketingKey)\n        return key;\n    // @ts-ignore\n    return `${key.matchingKey ? key.matchingKey : key}-${key.bucketingKey ? key.bucketingKey : key}-`;\n}\nfunction parseTreatmentParams(param1, param2, param3) {\n    if (isString(param2) || Array.isArray(param2))\n        return { key: param1, splitNames: param2, attributes: param3 };\n    return { key: undefined, splitNames: param1, attributes: param2 };\n}\nfunction parseTrackParams(param1, param2, param3, param4, param5) {\n    if (isString(param3))\n        return { key: param1, trafficType: param2, eventType: param3, value: param4, properties: param5 };\n    return { key: undefined, trafficType: param1, eventType: param2, value: param3, properties: param4 };\n}\nfunction isString(val) {\n    return typeof val === 'string' || val instanceof String;\n}\n\nclass SplitService {\n    constructor() {\n        /**\n         * Map of intialized clients\n         */\n        this.clientsMap = new Map();\n        /**\n         * Map of events status of intialized clients\n         */\n        this.emittedEvents = new Map();\n        /**\n         * Flag to determine if SDK is ready or not.\n         */\n        this.isSDKReady = false;\n    }\n    /**\n     * This method initializes the SDK with the required Browser APIKEY\n     * and the 'key' according to the Traffic type set (ex.: an user id).\n     * @function init\n     * @param {IBrowserSettings} config Should be an object that complies with the SplitIO.IBrowserSettings.\n     * @returns {Observable<string>} Returns when sdk is ready\n     */\n    init(config) {\n        if (this.splitio) {\n            console.log('[ERROR] There is another instance of the SDK.');\n            return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n        }\n        this.config = config;\n        // @ts-ignore. 2nd param is not part of type definitions. Used to overwrite the version of the SDK for correct tracking.\n        this.splitio = SplitFactory(config, (modules) => {\n            modules.settings.version = VERSION;\n        });\n        this.splitClient = this.splitio.client();\n        this.splitManager = this.splitio.manager();\n        this.sdkInitEventObservable();\n        const instanceKey = buildInstance(this.config.core.key);\n        const sdkReady = this.splitClient.Event.SDK_READY;\n        this.splitClient.on(sdkReady, () => {\n            this.emittedEvents.set(instanceKey + sdkReady, true);\n            this.isSDKReady = true;\n        });\n        this.clientsMap.set(instanceKey, this.splitClient);\n        return this.sdkReady$;\n    }\n    /**\n     * Returns a shared client of the SDK, associated with the given key\n     * @function initClient\n     * @param {SplitKey} key The key for the new client instance.\n     * @returns {Observable<string>} Returns when sdk is ready\n     */\n    initClient(key) {\n        let client = this.getSDKClient(key);\n        if (client) {\n            console.log('[WARN] client for key ' + buildInstance(key) + ' is already initialized.');\n            return new Observable(observer => observer.error(INIT_CLIENT_EXISTS));\n        }\n        if (!this.splitio)\n            return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n        client = this.splitio.client(key);\n        this.clientsMap.set(buildInstance(key), client);\n        return this.toObservable(key, client, client.Event.SDK_READY);\n    }\n    getClientObservable(key, event, isOneTimeEvent = true) {\n        const client = this.getClient(key);\n        if (client === CONTROL_CLIENT) {\n            return new Observable(observer => observer.error(INIT_CLIENT_FIRST));\n        }\n        return this.toObservable(key, client, client.Event[event], isOneTimeEvent);\n    }\n    /**\n     * Returns an observable that calls back when the client is ready\n     * @function getClientSDKReady\n     * @param {SplitKey} key The key for the client instance.\n     * @returns {Observable<string>}\n     */\n    getClientSDKReady(key) {\n        return this.getClientObservable(key, 'SDK_READY');\n    }\n    /**\n     * Returns an observable that calls back when the client ready event is timed out\n     * @function getClientSDKReadyTimedOut\n     * @param {SplitKey} key The key for the client instance.\n     * @returns {Observable<string>}\n     */\n    getClientSDKReadyTimedOut(key) {\n        return this.getClientObservable(key, 'SDK_READY_TIMED_OUT');\n    }\n    /**\n     * Returns an observable that calls back when the client is ready from cache\n     * @function getClientSDKReadyFromCache\n     * @param {SplitKey} key The key for the client instance.\n     * @returns {Observable<string>}\n     */\n    getClientSDKReadyFromCache(key) {\n        return this.getClientObservable(key, 'SDK_READY_FROM_CACHE');\n    }\n    /**\n     * Returns an observable that calls back when the client is updated\n     * @function getClientSDKUpdate\n     * @param {SplitKey} key The key for the client instance.\n     * @returns {Observable<string>}\n     */\n    getClientSDKUpdate(key) {\n        return this.getClientObservable(key, 'SDK_UPDATE', false);\n    }\n    /**\n     * initialize sdk Events into observables\n     */\n    sdkInitEventObservable() {\n        const client = this.splitClient;\n        const mainKey = this.config.core.key;\n        this.sdkReady$ = this.toObservable(mainKey, client, client.Event.SDK_READY);\n        this.sdkReadyTimedOut$ = this.toObservable(mainKey, client, client.Event.SDK_READY_TIMED_OUT);\n        this.sdkReadyFromCache$ = this.toObservable(mainKey, client, client.Event.SDK_READY_FROM_CACHE);\n        this.sdkUpdate$ = this.toObservable(mainKey, client, client.Event.SDK_UPDATE, false);\n    }\n    /**\n     * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).\n     * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event,\n     * calling the ready method after the SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.\n     * @returns Promise<void>\n     */\n    ready() {\n        return this.getClient().ready();\n    }\n    isInitialized() {\n        if (!this.splitio) {\n            console.log('[ERROR] plugin should be initialized');\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the SDK client\n     * @param {SplitKey=} key The key for the client instance.\n     * @returns {IClient} split client.\n     */\n    getSDKClient(key) {\n        if (!this.isInitialized())\n            return undefined;\n        key = key ? key : this.config.core.key;\n        return this.clientsMap.get(buildInstance(key));\n    }\n    /**\n     * Returns the SDK factory\n     * @returns {ISDK} split factory\n     */\n    getSDKFactory() {\n        if (!this.isInitialized())\n            return undefined;\n        return this.splitio;\n    }\n    /**\n     * Validates key and returns client if it is initialized for key or controlClient if it isn't\n     */\n    getClient(key) {\n        const client = this.getSDKClient(key);\n        if (!client) {\n            console.log('[ERROR] client' + (key ? ' for key ' + buildInstance(key) : '') + ' should be initialized first.');\n            return CONTROL_CLIENT;\n        }\n        return client;\n    }\n    getTreatment(param1, param2, param3) {\n        const { key, splitNames, attributes } = parseTreatmentParams(param1, param2, param3);\n        return this.getClient(key).getTreatment(splitNames, attributes);\n    }\n    getTreatmentWithConfig(param1, param2, param3) {\n        const { key, splitNames, attributes } = parseTreatmentParams(param1, param2, param3);\n        return this.getClient(key).getTreatmentWithConfig(splitNames, attributes);\n    }\n    getTreatments(param1, param2, param3) {\n        const { key, splitNames, attributes } = parseTreatmentParams(param1, param2, param3);\n        return this.getClient(key).getTreatments(splitNames, attributes);\n    }\n    getTreatmentsWithConfig(param1, param2, param3) {\n        const { key, splitNames, attributes } = parseTreatmentParams(param1, param2, param3);\n        return this.getClient(key).getTreatmentsWithConfig(splitNames, attributes);\n    }\n    track(param1, param2, param3, param4, param5) {\n        const { key, trafficType, eventType, value, properties } = parseTrackParams(param1, param2, param3, param4, param5);\n        return this.getClient(key).track(trafficType, eventType, value, properties);\n    }\n    /**\n     * Validates key and returns client if it is initialized for key or controlClient if it isn't\n     */\n    getManager() {\n        const client = this.getSDKClient();\n        if (!client) {\n            console.log('[ERROR] The SDK has not being initialized. Returning default response for method call.');\n            return DEFAULT_MANAGER;\n        }\n        return this.splitManager;\n    }\n    /**\n     * Get the array of splits data in SplitView format.\n     * @function getSplits\n     * @returns {SplitViews} The list of SplitIO.SplitView.\n     */\n    getSplits() {\n        return this.getManager().splits();\n    }\n    /**\n     * Get the data of a split in SplitView format.\n     * @function getSplit\n     * @param {string} splitName The name of the split we wan't to get info of.\n     * @returns {SplitView} The SplitIO.SplitView of the given split.\n     */\n    getSplit(splitName) {\n        return this.getManager().split(splitName);\n    }\n    /**\n     * Get the array of Split names.\n     * @function getSplitNames\n     * @returns {SplitNames} The lists of Split names.\n     */\n    getSplitNames() {\n        return this.getManager().names();\n    }\n    /**\n     * Destroy all clients instances.\n     * @function destroy\n     * @returns {Observable<unknown>}\n     */\n    destroy() {\n        const mainInstanceKey = buildInstance(this.config.core.key);\n        this.clientsMap.forEach((client, key) => {\n            if (buildInstance(key) !== mainInstanceKey) {\n                client.destroy();\n                this.clientsMap.delete(buildInstance(key));\n            }\n        });\n        this.clientsMap.delete(mainInstanceKey);\n        this.splitio = undefined;\n        return from(this.splitClient.destroy());\n    }\n    /**\n     * Private function to return as observable the event on parameter\n     * @param {string} event\n     * @param response\n     * @returns Observable<any>\n     */\n    toObservable(key, client, event, isOneTimeEvent = true) {\n        const eventKey = buildInstance(key) + event;\n        if (isOneTimeEvent) {\n            return new Observable(subscriber => {\n                const wasEventEmitted = this.emittedEvents.get(eventKey);\n                if (wasEventEmitted) {\n                    Promise.resolve().then(() => subscriber.next(event));\n                }\n                else {\n                    client.once(event, () => {\n                        this.emittedEvents.set(eventKey, true);\n                        subscriber.next(event);\n                    });\n                }\n            });\n        }\n        else {\n            return new Observable(subscriber => {\n                client.on(event, () => {\n                    subscriber.next(event);\n                });\n            });\n        }\n    }\n}\nSplitService.ɵfac = function SplitService_Factory(t) { return new (t || SplitService)(); };\nSplitService.ɵprov = ɵɵdefineInjectable({ factory: function SplitService_Factory() { return new SplitService(); }, token: SplitService, providedIn: \"root\" });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return []; }, null); })();\n\nclass SplitioGuard {\n    constructor(splitService) {\n        this.splitService = splitService;\n    }\n    canActivate() {\n        return this.splitService.isSDKReady;\n    }\n    canLoad() {\n        return this.splitService.isSDKReady;\n    }\n    canActivateChild() {\n        return this.splitService.isSDKReady;\n    }\n}\nSplitioGuard.ɵfac = function SplitioGuard_Factory(t) { return new (t || SplitioGuard)(ɵngcc0.ɵɵinject(SplitService)); };\nSplitioGuard.ɵprov = ɵɵdefineInjectable({ factory: function SplitioGuard_Factory() { return new SplitioGuard(ɵɵinject(SplitService)); }, token: SplitioGuard, providedIn: \"root\" });\nSplitioGuard.ctorParameters = () => [\n    { type: SplitService }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SplitioGuard, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: SplitService }]; }, null); })();\n\n/*\n * Public API Surface of splitio\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SplitService, SplitioGuard };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}