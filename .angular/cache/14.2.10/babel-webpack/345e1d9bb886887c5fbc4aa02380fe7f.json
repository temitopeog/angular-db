{"ast":null,"code":"import { objectAssign } from '../utils/lang/objectAssign';\nimport { promiseWrapper } from '../utils/promise/wrapper';\nimport { readinessManagerFactory } from './readinessManager';\nimport { SDK_READY, SDK_READY_TIMED_OUT, SDK_READY_FROM_CACHE, SDK_UPDATE } from './constants';\nimport { ERROR_CLIENT_LISTENER, CLIENT_READY_FROM_CACHE, CLIENT_READY, CLIENT_NO_LISTENER } from '../logger/constants';\nvar NEW_LISTENER_EVENT = 'newListener';\nvar REMOVE_LISTENER_EVENT = 'removeListener';\n/**\n * SdkReadinessManager factory, which provides the public status API of SDK clients and manager: ready promise, readiness event emitter and constants (SDK_READY, etc).\n * It also updates logs related warnings and errors.\n *\n * @param readyTimeout time in millis to emit SDK_READY_TIME_OUT event\n * @param readinessManager optional readinessManager to use. only used internally for `shared` method\n */\nexport function sdkReadinessManagerFactory(log, EventEmitter, readyTimeout, readinessManager) {\n  if (readyTimeout === void 0) {\n    readyTimeout = 0;\n  }\n  if (readinessManager === void 0) {\n    readinessManager = readinessManagerFactory(EventEmitter, readyTimeout);\n  }\n  /** Ready callback warning */\n  var internalReadyCbCount = 0;\n  var readyCbCount = 0;\n  readinessManager.gate.on(REMOVE_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY) readyCbCount--;\n  });\n  readinessManager.gate.on(NEW_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY || event === SDK_READY_TIMED_OUT) {\n      if (readinessManager.isReady()) {\n        log.error(ERROR_CLIENT_LISTENER, [event === SDK_READY ? 'SDK_READY' : 'SDK_READY_TIMED_OUT']);\n      } else if (event === SDK_READY) {\n        readyCbCount++;\n      }\n    }\n  });\n  /** Ready promise */\n  var readyPromise = generateReadyPromise();\n  readinessManager.gate.once(SDK_READY_FROM_CACHE, function () {\n    log.info(CLIENT_READY_FROM_CACHE);\n  });\n  // default onRejected handler, that just logs the error, if ready promise doesn't have one.\n  function defaultOnRejected(err) {\n    log.error(err && err.message);\n  }\n  function generateReadyPromise() {\n    var promise = promiseWrapper(new Promise(function (resolve, reject) {\n      readinessManager.gate.once(SDK_READY, function () {\n        log.info(CLIENT_READY);\n        if (readyCbCount === internalReadyCbCount && !promise.hasOnFulfilled()) log.warn(CLIENT_NO_LISTENER);\n        resolve();\n      });\n      readinessManager.gate.once(SDK_READY_TIMED_OUT, function (message) {\n        reject(new Error(message));\n      });\n    }), defaultOnRejected);\n    return promise;\n  }\n  return {\n    readinessManager: readinessManager,\n    shared: function (readyTimeout) {\n      if (readyTimeout === void 0) {\n        readyTimeout = 0;\n      }\n      return sdkReadinessManagerFactory(log, EventEmitter, readyTimeout, readinessManager.shared(readyTimeout));\n    },\n    incInternalReadyCbCount: function () {\n      internalReadyCbCount++;\n    },\n    sdkStatus: objectAssign(\n    // Expose Event Emitter functionality\n    Object.create(readinessManager.gate), {\n      // Expose the event constants without changing the interface\n      Event: {\n        SDK_READY: SDK_READY,\n        SDK_READY_FROM_CACHE: SDK_READY_FROM_CACHE,\n        SDK_UPDATE: SDK_UPDATE,\n        SDK_READY_TIMED_OUT: SDK_READY_TIMED_OUT\n      },\n      /**\n       * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).\n       * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event, calling the `ready` method after the\n       * SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.\n       *\n       * Caveats: the method was designed to avoid an unhandled Promise rejection if the rejection case is not handled, so that `onRejected` handler is optional when using promises.\n       * However, when using async/await syntax, the rejection should be explicitly propagated like in the following example:\n       * ```\n       * try {\n       *   await client.ready().catch((e) => { throw e; });\n       *   // SDK is ready\n       * } catch(e) {\n       *   // SDK has timedout\n       * }\n       * ```\n       *\n       * @function ready\n       * @returns {Promise<void>}\n       */\n      ready: function () {\n        if (readinessManager.hasTimedout()) {\n          if (!readinessManager.isReady()) {\n            return promiseWrapper(Promise.reject(new Error('Split SDK has emitted SDK_READY_TIMED_OUT event.')), defaultOnRejected);\n          } else {\n            return Promise.resolve();\n          }\n        }\n        return readyPromise;\n      },\n      // Expose status for internal purposes only. Not considered part of the public API, and might be updated eventually.\n      __getStatus: function () {\n        return {\n          isReady: readinessManager.isReady(),\n          isReadyFromCache: readinessManager.isReadyFromCache(),\n          isOperational: readinessManager.isOperational(),\n          hasTimedout: readinessManager.hasTimedout(),\n          isDestroyed: readinessManager.isDestroyed()\n        };\n      }\n    })\n  };\n}","map":{"version":3,"names":["objectAssign","promiseWrapper","readinessManagerFactory","SDK_READY","SDK_READY_TIMED_OUT","SDK_READY_FROM_CACHE","SDK_UPDATE","ERROR_CLIENT_LISTENER","CLIENT_READY_FROM_CACHE","CLIENT_READY","CLIENT_NO_LISTENER","NEW_LISTENER_EVENT","REMOVE_LISTENER_EVENT","sdkReadinessManagerFactory","log","EventEmitter","readyTimeout","readinessManager","internalReadyCbCount","readyCbCount","gate","on","event","isReady","error","readyPromise","generateReadyPromise","once","info","defaultOnRejected","err","message","promise","Promise","resolve","reject","hasOnFulfilled","warn","Error","shared","incInternalReadyCbCount","sdkStatus","Object","create","Event","ready","hasTimedout","__getStatus","isReadyFromCache","isOperational","isDestroyed"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/readiness/sdkReadinessManager.js"],"sourcesContent":["import { objectAssign } from '../utils/lang/objectAssign';\nimport { promiseWrapper } from '../utils/promise/wrapper';\nimport { readinessManagerFactory } from './readinessManager';\nimport { SDK_READY, SDK_READY_TIMED_OUT, SDK_READY_FROM_CACHE, SDK_UPDATE } from './constants';\nimport { ERROR_CLIENT_LISTENER, CLIENT_READY_FROM_CACHE, CLIENT_READY, CLIENT_NO_LISTENER } from '../logger/constants';\nvar NEW_LISTENER_EVENT = 'newListener';\nvar REMOVE_LISTENER_EVENT = 'removeListener';\n/**\n * SdkReadinessManager factory, which provides the public status API of SDK clients and manager: ready promise, readiness event emitter and constants (SDK_READY, etc).\n * It also updates logs related warnings and errors.\n *\n * @param readyTimeout time in millis to emit SDK_READY_TIME_OUT event\n * @param readinessManager optional readinessManager to use. only used internally for `shared` method\n */\nexport function sdkReadinessManagerFactory(log, EventEmitter, readyTimeout, readinessManager) {\n    if (readyTimeout === void 0) { readyTimeout = 0; }\n    if (readinessManager === void 0) { readinessManager = readinessManagerFactory(EventEmitter, readyTimeout); }\n    /** Ready callback warning */\n    var internalReadyCbCount = 0;\n    var readyCbCount = 0;\n    readinessManager.gate.on(REMOVE_LISTENER_EVENT, function (event) {\n        if (event === SDK_READY)\n            readyCbCount--;\n    });\n    readinessManager.gate.on(NEW_LISTENER_EVENT, function (event) {\n        if (event === SDK_READY || event === SDK_READY_TIMED_OUT) {\n            if (readinessManager.isReady()) {\n                log.error(ERROR_CLIENT_LISTENER, [event === SDK_READY ? 'SDK_READY' : 'SDK_READY_TIMED_OUT']);\n            }\n            else if (event === SDK_READY) {\n                readyCbCount++;\n            }\n        }\n    });\n    /** Ready promise */\n    var readyPromise = generateReadyPromise();\n    readinessManager.gate.once(SDK_READY_FROM_CACHE, function () {\n        log.info(CLIENT_READY_FROM_CACHE);\n    });\n    // default onRejected handler, that just logs the error, if ready promise doesn't have one.\n    function defaultOnRejected(err) {\n        log.error(err && err.message);\n    }\n    function generateReadyPromise() {\n        var promise = promiseWrapper(new Promise(function (resolve, reject) {\n            readinessManager.gate.once(SDK_READY, function () {\n                log.info(CLIENT_READY);\n                if (readyCbCount === internalReadyCbCount && !promise.hasOnFulfilled())\n                    log.warn(CLIENT_NO_LISTENER);\n                resolve();\n            });\n            readinessManager.gate.once(SDK_READY_TIMED_OUT, function (message) {\n                reject(new Error(message));\n            });\n        }), defaultOnRejected);\n        return promise;\n    }\n    return {\n        readinessManager: readinessManager,\n        shared: function (readyTimeout) {\n            if (readyTimeout === void 0) { readyTimeout = 0; }\n            return sdkReadinessManagerFactory(log, EventEmitter, readyTimeout, readinessManager.shared(readyTimeout));\n        },\n        incInternalReadyCbCount: function () {\n            internalReadyCbCount++;\n        },\n        sdkStatus: objectAssign(\n        // Expose Event Emitter functionality\n        Object.create(readinessManager.gate), {\n            // Expose the event constants without changing the interface\n            Event: {\n                SDK_READY: SDK_READY,\n                SDK_READY_FROM_CACHE: SDK_READY_FROM_CACHE,\n                SDK_UPDATE: SDK_UPDATE,\n                SDK_READY_TIMED_OUT: SDK_READY_TIMED_OUT,\n            },\n            /**\n             * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).\n             * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event, calling the `ready` method after the\n             * SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.\n             *\n             * Caveats: the method was designed to avoid an unhandled Promise rejection if the rejection case is not handled, so that `onRejected` handler is optional when using promises.\n             * However, when using async/await syntax, the rejection should be explicitly propagated like in the following example:\n             * ```\n             * try {\n             *   await client.ready().catch((e) => { throw e; });\n             *   // SDK is ready\n             * } catch(e) {\n             *   // SDK has timedout\n             * }\n             * ```\n             *\n             * @function ready\n             * @returns {Promise<void>}\n             */\n            ready: function () {\n                if (readinessManager.hasTimedout()) {\n                    if (!readinessManager.isReady()) {\n                        return promiseWrapper(Promise.reject(new Error('Split SDK has emitted SDK_READY_TIMED_OUT event.')), defaultOnRejected);\n                    }\n                    else {\n                        return Promise.resolve();\n                    }\n                }\n                return readyPromise;\n            },\n            // Expose status for internal purposes only. Not considered part of the public API, and might be updated eventually.\n            __getStatus: function () {\n                return {\n                    isReady: readinessManager.isReady(),\n                    isReadyFromCache: readinessManager.isReadyFromCache(),\n                    isOperational: readinessManager.isOperational(),\n                    hasTimedout: readinessManager.hasTimedout(),\n                    isDestroyed: readinessManager.isDestroyed(),\n                };\n            },\n        })\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}