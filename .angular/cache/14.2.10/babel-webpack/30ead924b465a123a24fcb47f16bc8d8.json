{"ast":null,"code":"import { findIndex } from '../../utils/lang';\nimport { matcherTypes, matcherTypesMapper, matcherDataTypes } from '../matchers/matcherTypes';\nimport { segmentTransform } from './segment';\nimport { whitelistTransform } from './whitelist';\nimport { setTransform } from './set';\nimport { numericTransform } from './unaryNumeric';\nimport { zeroSinceHH, zeroSinceSS } from '../convertions';\n/**\n * Flat the complex matcherGroup structure into something handy.\n */\nexport function matchersTransform(matchers) {\n  var parsedMatchers = matchers.map(function (matcher) {\n    var matcherType = matcher.matcherType /* string */,\n      negate = matcher.negate /* boolean */,\n      keySelector = matcher.keySelector /* keySelectorObject */,\n      segmentObject = matcher.userDefinedSegmentMatcherData /* segmentObject */,\n      whitelistObject = matcher.whitelistMatcherData /* whiteListObject, provided by 'WHITELIST', set and string matchers */,\n      unaryNumericObject = matcher.unaryNumericMatcherData /* unaryNumericObject */,\n      betweenObject = matcher.betweenMatcherData /* betweenObject */,\n      dependencyObject = matcher.dependencyMatcherData /* dependencyObject */,\n      booleanMatcherData = matcher.booleanMatcherData,\n      stringMatcherData = matcher.stringMatcherData;\n    var attribute = keySelector && keySelector.attribute;\n    var type = matcherTypesMapper(matcherType);\n    // As default input data type we use string (even for ALL_KEYS)\n    var dataType = matcherDataTypes.STRING;\n    var value = undefined;\n    if (type === matcherTypes.IN_SEGMENT) {\n      value = segmentTransform(segmentObject);\n    } else if (type === matcherTypes.WHITELIST) {\n      value = whitelistTransform(whitelistObject);\n    } else if (type === matcherTypes.EQUAL_TO) {\n      value = numericTransform(unaryNumericObject);\n      dataType = matcherDataTypes.NUMBER;\n      if (unaryNumericObject.dataType === 'DATETIME') {\n        value = zeroSinceHH(value);\n        dataType = matcherDataTypes.DATETIME;\n      }\n    } else if (type === matcherTypes.GREATER_THAN_OR_EQUAL_TO || type === matcherTypes.LESS_THAN_OR_EQUAL_TO) {\n      value = numericTransform(unaryNumericObject);\n      dataType = matcherDataTypes.NUMBER;\n      if (unaryNumericObject.dataType === 'DATETIME') {\n        value = zeroSinceSS(value);\n        dataType = matcherDataTypes.DATETIME;\n      }\n    } else if (type === matcherTypes.BETWEEN) {\n      value = betweenObject;\n      dataType = matcherDataTypes.NUMBER;\n      if (value.dataType === 'DATETIME') {\n        value.start = zeroSinceSS(value.start);\n        value.end = zeroSinceSS(value.end);\n        dataType = matcherDataTypes.DATETIME;\n      }\n    } else if (type === matcherTypes.EQUAL_TO_SET || type === matcherTypes.CONTAINS_ANY_OF_SET || type === matcherTypes.CONTAINS_ALL_OF_SET || type === matcherTypes.PART_OF_SET) {\n      value = setTransform(whitelistObject);\n      dataType = matcherDataTypes.SET;\n    } else if (type === matcherTypes.STARTS_WITH || type === matcherTypes.ENDS_WITH || type === matcherTypes.CONTAINS_STRING) {\n      value = setTransform(whitelistObject);\n    } else if (type === matcherTypes.IN_SPLIT_TREATMENT) {\n      value = dependencyObject;\n      dataType = matcherDataTypes.NOT_SPECIFIED;\n    } else if (type === matcherTypes.EQUAL_TO_BOOLEAN) {\n      dataType = matcherDataTypes.BOOLEAN;\n      value = booleanMatcherData;\n    } else if (type === matcherTypes.MATCHES_STRING) {\n      value = stringMatcherData;\n    }\n    return {\n      attribute: attribute,\n      negate: negate,\n      type: type,\n      value: value,\n      dataType: dataType // runtime input data type\n    };\n  });\n\n  if (findIndex(parsedMatchers, function (m) {\n    return m.type === matcherTypes.UNDEFINED;\n  }) === -1) {\n    return parsedMatchers;\n  } else {\n    return [];\n  }\n}","map":{"version":3,"names":["findIndex","matcherTypes","matcherTypesMapper","matcherDataTypes","segmentTransform","whitelistTransform","setTransform","numericTransform","zeroSinceHH","zeroSinceSS","matchersTransform","matchers","parsedMatchers","map","matcher","matcherType","negate","keySelector","segmentObject","userDefinedSegmentMatcherData","whitelistObject","whitelistMatcherData","unaryNumericObject","unaryNumericMatcherData","betweenObject","betweenMatcherData","dependencyObject","dependencyMatcherData","booleanMatcherData","stringMatcherData","attribute","type","dataType","STRING","value","undefined","IN_SEGMENT","WHITELIST","EQUAL_TO","NUMBER","DATETIME","GREATER_THAN_OR_EQUAL_TO","LESS_THAN_OR_EQUAL_TO","BETWEEN","start","end","EQUAL_TO_SET","CONTAINS_ANY_OF_SET","CONTAINS_ALL_OF_SET","PART_OF_SET","SET","STARTS_WITH","ENDS_WITH","CONTAINS_STRING","IN_SPLIT_TREATMENT","NOT_SPECIFIED","EQUAL_TO_BOOLEAN","BOOLEAN","MATCHES_STRING","m","UNDEFINED"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/evaluator/matchersTransform/index.js"],"sourcesContent":["import { findIndex } from '../../utils/lang';\nimport { matcherTypes, matcherTypesMapper, matcherDataTypes } from '../matchers/matcherTypes';\nimport { segmentTransform } from './segment';\nimport { whitelistTransform } from './whitelist';\nimport { setTransform } from './set';\nimport { numericTransform } from './unaryNumeric';\nimport { zeroSinceHH, zeroSinceSS } from '../convertions';\n/**\n * Flat the complex matcherGroup structure into something handy.\n */\nexport function matchersTransform(matchers) {\n    var parsedMatchers = matchers.map(function (matcher) {\n        var matcherType = matcher.matcherType /* string */, negate = matcher.negate /* boolean */, keySelector = matcher.keySelector /* keySelectorObject */, segmentObject = matcher.userDefinedSegmentMatcherData /* segmentObject */, whitelistObject = matcher.whitelistMatcherData /* whiteListObject, provided by 'WHITELIST', set and string matchers */, unaryNumericObject = matcher.unaryNumericMatcherData /* unaryNumericObject */, betweenObject = matcher.betweenMatcherData /* betweenObject */, dependencyObject = matcher.dependencyMatcherData /* dependencyObject */, booleanMatcherData = matcher.booleanMatcherData, stringMatcherData = matcher.stringMatcherData;\n        var attribute = keySelector && keySelector.attribute;\n        var type = matcherTypesMapper(matcherType);\n        // As default input data type we use string (even for ALL_KEYS)\n        var dataType = matcherDataTypes.STRING;\n        var value = undefined;\n        if (type === matcherTypes.IN_SEGMENT) {\n            value = segmentTransform(segmentObject);\n        }\n        else if (type === matcherTypes.WHITELIST) {\n            value = whitelistTransform(whitelistObject);\n        }\n        else if (type === matcherTypes.EQUAL_TO) {\n            value = numericTransform(unaryNumericObject);\n            dataType = matcherDataTypes.NUMBER;\n            if (unaryNumericObject.dataType === 'DATETIME') {\n                value = zeroSinceHH(value);\n                dataType = matcherDataTypes.DATETIME;\n            }\n        }\n        else if (type === matcherTypes.GREATER_THAN_OR_EQUAL_TO ||\n            type === matcherTypes.LESS_THAN_OR_EQUAL_TO) {\n            value = numericTransform(unaryNumericObject);\n            dataType = matcherDataTypes.NUMBER;\n            if (unaryNumericObject.dataType === 'DATETIME') {\n                value = zeroSinceSS(value);\n                dataType = matcherDataTypes.DATETIME;\n            }\n        }\n        else if (type === matcherTypes.BETWEEN) {\n            value = betweenObject;\n            dataType = matcherDataTypes.NUMBER;\n            if (value.dataType === 'DATETIME') {\n                value.start = zeroSinceSS(value.start);\n                value.end = zeroSinceSS(value.end);\n                dataType = matcherDataTypes.DATETIME;\n            }\n        }\n        else if (type === matcherTypes.EQUAL_TO_SET ||\n            type === matcherTypes.CONTAINS_ANY_OF_SET ||\n            type === matcherTypes.CONTAINS_ALL_OF_SET ||\n            type === matcherTypes.PART_OF_SET) {\n            value = setTransform(whitelistObject);\n            dataType = matcherDataTypes.SET;\n        }\n        else if (type === matcherTypes.STARTS_WITH ||\n            type === matcherTypes.ENDS_WITH ||\n            type === matcherTypes.CONTAINS_STRING) {\n            value = setTransform(whitelistObject);\n        }\n        else if (type === matcherTypes.IN_SPLIT_TREATMENT) {\n            value = dependencyObject;\n            dataType = matcherDataTypes.NOT_SPECIFIED;\n        }\n        else if (type === matcherTypes.EQUAL_TO_BOOLEAN) {\n            dataType = matcherDataTypes.BOOLEAN;\n            value = booleanMatcherData;\n        }\n        else if (type === matcherTypes.MATCHES_STRING) {\n            value = stringMatcherData;\n        }\n        return {\n            attribute: attribute,\n            negate: negate,\n            type: type,\n            value: value,\n            dataType: dataType // runtime input data type\n        };\n    });\n    if (findIndex(parsedMatchers, function (m) { return m.type === matcherTypes.UNDEFINED; }) === -1) {\n        return parsedMatchers;\n    }\n    else {\n        return [];\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}