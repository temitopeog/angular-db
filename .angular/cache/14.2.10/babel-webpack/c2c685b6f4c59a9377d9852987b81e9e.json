{"ast":null,"code":"import { Backoff } from '../../../utils/Backoff';\n/**\n * SegmentUpdateWorker class\n */\nvar SegmentsUpdateWorker = /** @class */function () {\n  /**\n   * @param {Object} segmentsCache segments data cache\n   * @param {Object} segmentsSyncTask task for syncing segments data\n   */\n  function SegmentsUpdateWorker(segmentsSyncTask, segmentsCache) {\n    this.segmentsCache = segmentsCache;\n    this.segmentsSyncTask = segmentsSyncTask;\n    this.maxChangeNumbers = {};\n    this.handleNewEvent = false;\n    this.put = this.put.bind(this);\n    this.__handleSegmentUpdateCall = this.__handleSegmentUpdateCall.bind(this);\n    this.backoff = new Backoff(this.__handleSegmentUpdateCall);\n  }\n  // Private method\n  // Precondition: this.segmentsSyncTask.isSynchronizingSegments === false\n  // Approach similar to MySegmentsUpdateWorker due to differences on Segments notifications and endpoint changeNumbers\n  SegmentsUpdateWorker.prototype.__handleSegmentUpdateCall = function () {\n    var _this = this;\n    var segmentsToFetch = Object.keys(this.maxChangeNumbers).filter(function (segmentName) {\n      return _this.maxChangeNumbers[segmentName] > _this.segmentsCache.getChangeNumber(segmentName);\n    });\n    if (segmentsToFetch.length > 0) {\n      this.handleNewEvent = false;\n      var currentMaxChangeNumbers_1 = segmentsToFetch.map(function (segmentToFetch) {\n        return _this.maxChangeNumbers[segmentToFetch];\n      });\n      // fetch segments revalidating data if cached\n      this.segmentsSyncTask.execute(segmentsToFetch, true).then(function (result) {\n        // Unlike `SplitUpdateWorker` where changeNumber is consistent between notification and endpoint, if there is no error,\n        // we must clean the `maxChangeNumbers` of those segments that didn't receive a new update notification during the fetch.\n        if (result !== false) {\n          segmentsToFetch.forEach(function (fetchedSegment, index) {\n            if (_this.maxChangeNumbers[fetchedSegment] === currentMaxChangeNumbers_1[index]) _this.maxChangeNumbers[fetchedSegment] = -1;\n          });\n        } else {\n          // recursive invocation with backoff if there was some error\n          _this.backoff.scheduleCall();\n        }\n        // immediate recursive invocation if a new notification was queued during fetch\n        if (_this.handleNewEvent) {\n          _this.__handleSegmentUpdateCall();\n        }\n      });\n    }\n  };\n  /**\n   * Invoked by NotificationProcessor on SEGMENT_UPDATE event\n   *\n   * @param {number} changeNumber change number of the SEGMENT_UPDATE notification\n   * @param {string} segmentName segment name of the SEGMENT_UPDATE notification\n   */\n  SegmentsUpdateWorker.prototype.put = function (_a) {\n    var changeNumber = _a.changeNumber,\n      segmentName = _a.segmentName;\n    var currentChangeNumber = this.segmentsCache.getChangeNumber(segmentName);\n    if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumbers[segmentName]) return;\n    this.maxChangeNumbers[segmentName] = changeNumber;\n    this.handleNewEvent = true;\n    this.backoff.reset();\n    if (this.segmentsSyncTask.isExecuting()) return;\n    this.__handleSegmentUpdateCall();\n  };\n  return SegmentsUpdateWorker;\n}();\nexport { SegmentsUpdateWorker };","map":{"version":3,"names":["Backoff","SegmentsUpdateWorker","segmentsSyncTask","segmentsCache","maxChangeNumbers","handleNewEvent","put","bind","__handleSegmentUpdateCall","backoff","prototype","_this","segmentsToFetch","Object","keys","filter","segmentName","getChangeNumber","length","currentMaxChangeNumbers_1","map","segmentToFetch","execute","then","result","forEach","fetchedSegment","index","scheduleCall","_a","changeNumber","currentChangeNumber","reset","isExecuting"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/streaming/UpdateWorkers/SegmentsUpdateWorker.js"],"sourcesContent":["import { Backoff } from '../../../utils/Backoff';\n/**\n * SegmentUpdateWorker class\n */\nvar SegmentsUpdateWorker = /** @class */ (function () {\n    /**\n     * @param {Object} segmentsCache segments data cache\n     * @param {Object} segmentsSyncTask task for syncing segments data\n     */\n    function SegmentsUpdateWorker(segmentsSyncTask, segmentsCache) {\n        this.segmentsCache = segmentsCache;\n        this.segmentsSyncTask = segmentsSyncTask;\n        this.maxChangeNumbers = {};\n        this.handleNewEvent = false;\n        this.put = this.put.bind(this);\n        this.__handleSegmentUpdateCall = this.__handleSegmentUpdateCall.bind(this);\n        this.backoff = new Backoff(this.__handleSegmentUpdateCall);\n    }\n    // Private method\n    // Precondition: this.segmentsSyncTask.isSynchronizingSegments === false\n    // Approach similar to MySegmentsUpdateWorker due to differences on Segments notifications and endpoint changeNumbers\n    SegmentsUpdateWorker.prototype.__handleSegmentUpdateCall = function () {\n        var _this = this;\n        var segmentsToFetch = Object.keys(this.maxChangeNumbers).filter(function (segmentName) {\n            return _this.maxChangeNumbers[segmentName] > _this.segmentsCache.getChangeNumber(segmentName);\n        });\n        if (segmentsToFetch.length > 0) {\n            this.handleNewEvent = false;\n            var currentMaxChangeNumbers_1 = segmentsToFetch.map(function (segmentToFetch) { return _this.maxChangeNumbers[segmentToFetch]; });\n            // fetch segments revalidating data if cached\n            this.segmentsSyncTask.execute(segmentsToFetch, true).then(function (result) {\n                // Unlike `SplitUpdateWorker` where changeNumber is consistent between notification and endpoint, if there is no error,\n                // we must clean the `maxChangeNumbers` of those segments that didn't receive a new update notification during the fetch.\n                if (result !== false) {\n                    segmentsToFetch.forEach(function (fetchedSegment, index) {\n                        if (_this.maxChangeNumbers[fetchedSegment] === currentMaxChangeNumbers_1[index])\n                            _this.maxChangeNumbers[fetchedSegment] = -1;\n                    });\n                }\n                else {\n                    // recursive invocation with backoff if there was some error\n                    _this.backoff.scheduleCall();\n                }\n                // immediate recursive invocation if a new notification was queued during fetch\n                if (_this.handleNewEvent) {\n                    _this.__handleSegmentUpdateCall();\n                }\n            });\n        }\n    };\n    /**\n     * Invoked by NotificationProcessor on SEGMENT_UPDATE event\n     *\n     * @param {number} changeNumber change number of the SEGMENT_UPDATE notification\n     * @param {string} segmentName segment name of the SEGMENT_UPDATE notification\n     */\n    SegmentsUpdateWorker.prototype.put = function (_a) {\n        var changeNumber = _a.changeNumber, segmentName = _a.segmentName;\n        var currentChangeNumber = this.segmentsCache.getChangeNumber(segmentName);\n        if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumbers[segmentName])\n            return;\n        this.maxChangeNumbers[segmentName] = changeNumber;\n        this.handleNewEvent = true;\n        this.backoff.reset();\n        if (this.segmentsSyncTask.isExecuting())\n            return;\n        this.__handleSegmentUpdateCall();\n    };\n    return SegmentsUpdateWorker;\n}());\nexport { SegmentsUpdateWorker };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}