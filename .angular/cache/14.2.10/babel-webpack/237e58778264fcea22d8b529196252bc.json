{"ast":null,"code":"import { objectAssign } from '../utils/lang/objectAssign';\nimport { thenable } from '../utils/promise/thenable';\nimport { truncateTimeFrame } from '../utils/time';\nimport { IMPRESSIONS_TRACKER_SUCCESS, ERROR_IMPRESSIONS_TRACKER, ERROR_IMPRESSIONS_LISTENER } from '../logger/constants';\nimport { CONSENT_DECLINED, DEDUPED, QUEUED } from '../utils/constants';\n/**\n * Impressions tracker stores impressions in cache and pass them to the listener and integrations manager if provided.\n *\n * @param impressionsCache cache to save impressions\n * @param metadata runtime metadata (ip, hostname and version)\n * @param impressionListener optional impression listener\n * @param integrationsManager optional integrations manager\n * @param observer optional impression observer. If provided, previous time (pt property) is included in impression instances\n * @param countsCache optional cache to save impressions count. If provided, impressions will be deduped (OPTIMIZED mode)\n */\nexport function impressionsTrackerFactory(settings, impressionsCache, integrationsManager,\n// if observer is provided, it implies `shouldAddPreviousTime` flag (i.e., if impressions previous time should be added or not)\nobserver,\n// if countsCache is provided, it implies `isOptimized` flag (i.e., if impressions should be deduped or not)\ncountsCache, telemetryCache) {\n  var log = settings.log,\n    impressionListener = settings.impressionListener,\n    _a = settings.runtime,\n    ip = _a.ip,\n    hostname = _a.hostname,\n    version = settings.version;\n  return {\n    track: function (impressions, attributes) {\n      if (settings.userConsent === CONSENT_DECLINED) return;\n      var impressionsCount = impressions.length;\n      var impressionsToStore = []; // Track only the impressions that are going to be stored\n      // Wraps impressions to store and adds previousTime if it corresponds\n      impressions.forEach(function (impression) {\n        if (observer) {\n          // Adds previous time if it is enabled\n          impression.pt = observer.testAndSet(impression);\n        }\n        var now = Date.now();\n        if (countsCache) {\n          // Increments impression counter per featureName\n          countsCache.track(impression.feature, now, 1);\n        }\n        // Checks if the impression should be added in queue to be sent\n        if (!countsCache || !impression.pt || impression.pt < truncateTimeFrame(now)) {\n          impressionsToStore.push(impression);\n        }\n      });\n      var res = impressionsCache.track(impressionsToStore);\n      // If we're on an async storage, handle error and log it.\n      if (thenable(res)) {\n        res.then(function () {\n          log.info(IMPRESSIONS_TRACKER_SUCCESS, [impressionsCount]);\n        }).catch(function (err) {\n          log.error(ERROR_IMPRESSIONS_TRACKER, [impressionsCount, err]);\n        });\n      } else {\n        // Record when impressionsCache is sync only (standalone mode)\n        // @TODO we are not dropping impressions on full queue yet, so DROPPED stats are not recorded\n        if (telemetryCache) {\n          telemetryCache.recordImpressionStats(QUEUED, impressionsToStore.length);\n          telemetryCache.recordImpressionStats(DEDUPED, impressions.length - impressionsToStore.length);\n        }\n      }\n      // @TODO next block might be handled by the integration manager. In that case, the metadata object doesn't need to be passed in the constructor\n      if (impressionListener || integrationsManager) {\n        var _loop_1 = function (i) {\n          var impressionData = {\n            // copy of impression, to avoid unexpected behaviour if modified by integrations or impressionListener\n            impression: objectAssign({}, impressions[i]),\n            attributes: attributes,\n            ip: ip,\n            hostname: hostname,\n            sdkLanguageVersion: version\n          };\n          // Wrap in a timeout because we don't want it to be blocking.\n          setTimeout(function () {\n            // integrationsManager.handleImpression does not throw errors\n            if (integrationsManager) integrationsManager.handleImpression(impressionData);\n            try {\n              // @ts-ignore. An exception on the listeners should not break the SDK.\n              if (impressionListener) impressionListener.logImpression(impressionData);\n            } catch (err) {\n              log.error(ERROR_IMPRESSIONS_LISTENER, [err]);\n            }\n          }, 0);\n        };\n        for (var i = 0; i < impressionsCount; i++) {\n          _loop_1(i);\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["objectAssign","thenable","truncateTimeFrame","IMPRESSIONS_TRACKER_SUCCESS","ERROR_IMPRESSIONS_TRACKER","ERROR_IMPRESSIONS_LISTENER","CONSENT_DECLINED","DEDUPED","QUEUED","impressionsTrackerFactory","settings","impressionsCache","integrationsManager","observer","countsCache","telemetryCache","log","impressionListener","_a","runtime","ip","hostname","version","track","impressions","attributes","userConsent","impressionsCount","length","impressionsToStore","forEach","impression","pt","testAndSet","now","Date","feature","push","res","then","info","catch","err","error","recordImpressionStats","_loop_1","i","impressionData","sdkLanguageVersion","setTimeout","handleImpression","logImpression"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/trackers/impressionsTracker.js"],"sourcesContent":["import { objectAssign } from '../utils/lang/objectAssign';\nimport { thenable } from '../utils/promise/thenable';\nimport { truncateTimeFrame } from '../utils/time';\nimport { IMPRESSIONS_TRACKER_SUCCESS, ERROR_IMPRESSIONS_TRACKER, ERROR_IMPRESSIONS_LISTENER } from '../logger/constants';\nimport { CONSENT_DECLINED, DEDUPED, QUEUED } from '../utils/constants';\n/**\n * Impressions tracker stores impressions in cache and pass them to the listener and integrations manager if provided.\n *\n * @param impressionsCache cache to save impressions\n * @param metadata runtime metadata (ip, hostname and version)\n * @param impressionListener optional impression listener\n * @param integrationsManager optional integrations manager\n * @param observer optional impression observer. If provided, previous time (pt property) is included in impression instances\n * @param countsCache optional cache to save impressions count. If provided, impressions will be deduped (OPTIMIZED mode)\n */\nexport function impressionsTrackerFactory(settings, impressionsCache, integrationsManager, \n// if observer is provided, it implies `shouldAddPreviousTime` flag (i.e., if impressions previous time should be added or not)\nobserver, \n// if countsCache is provided, it implies `isOptimized` flag (i.e., if impressions should be deduped or not)\ncountsCache, telemetryCache) {\n    var log = settings.log, impressionListener = settings.impressionListener, _a = settings.runtime, ip = _a.ip, hostname = _a.hostname, version = settings.version;\n    return {\n        track: function (impressions, attributes) {\n            if (settings.userConsent === CONSENT_DECLINED)\n                return;\n            var impressionsCount = impressions.length;\n            var impressionsToStore = []; // Track only the impressions that are going to be stored\n            // Wraps impressions to store and adds previousTime if it corresponds\n            impressions.forEach(function (impression) {\n                if (observer) {\n                    // Adds previous time if it is enabled\n                    impression.pt = observer.testAndSet(impression);\n                }\n                var now = Date.now();\n                if (countsCache) {\n                    // Increments impression counter per featureName\n                    countsCache.track(impression.feature, now, 1);\n                }\n                // Checks if the impression should be added in queue to be sent\n                if (!countsCache || !impression.pt || impression.pt < truncateTimeFrame(now)) {\n                    impressionsToStore.push(impression);\n                }\n            });\n            var res = impressionsCache.track(impressionsToStore);\n            // If we're on an async storage, handle error and log it.\n            if (thenable(res)) {\n                res.then(function () {\n                    log.info(IMPRESSIONS_TRACKER_SUCCESS, [impressionsCount]);\n                }).catch(function (err) {\n                    log.error(ERROR_IMPRESSIONS_TRACKER, [impressionsCount, err]);\n                });\n            }\n            else {\n                // Record when impressionsCache is sync only (standalone mode)\n                // @TODO we are not dropping impressions on full queue yet, so DROPPED stats are not recorded\n                if (telemetryCache) {\n                    telemetryCache.recordImpressionStats(QUEUED, impressionsToStore.length);\n                    telemetryCache.recordImpressionStats(DEDUPED, impressions.length - impressionsToStore.length);\n                }\n            }\n            // @TODO next block might be handled by the integration manager. In that case, the metadata object doesn't need to be passed in the constructor\n            if (impressionListener || integrationsManager) {\n                var _loop_1 = function (i) {\n                    var impressionData = {\n                        // copy of impression, to avoid unexpected behaviour if modified by integrations or impressionListener\n                        impression: objectAssign({}, impressions[i]),\n                        attributes: attributes,\n                        ip: ip,\n                        hostname: hostname,\n                        sdkLanguageVersion: version\n                    };\n                    // Wrap in a timeout because we don't want it to be blocking.\n                    setTimeout(function () {\n                        // integrationsManager.handleImpression does not throw errors\n                        if (integrationsManager)\n                            integrationsManager.handleImpression(impressionData);\n                        try { // @ts-ignore. An exception on the listeners should not break the SDK.\n                            if (impressionListener)\n                                impressionListener.logImpression(impressionData);\n                        }\n                        catch (err) {\n                            log.error(ERROR_IMPRESSIONS_LISTENER, [err]);\n                        }\n                    }, 0);\n                };\n                for (var i = 0; i < impressionsCount; i++) {\n                    _loop_1(i);\n                }\n            }\n        }\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}