{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { AbstractSegmentsCacheSync } from '../AbstractSegmentsCacheSync';\n/**\n * Default MySegmentsCacheInMemory implementation that stores MySegments in memory.\n * Supported by all JS runtimes.\n */\nvar MySegmentsCacheInMemory = /** @class */function (_super) {\n  __extends(MySegmentsCacheInMemory, _super);\n  function MySegmentsCacheInMemory() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.segmentCache = {};\n    return _this;\n  }\n  MySegmentsCacheInMemory.prototype.clear = function () {\n    this.segmentCache = {};\n  };\n  MySegmentsCacheInMemory.prototype.addToSegment = function (name) {\n    this.segmentCache[name] = true;\n    return true;\n  };\n  MySegmentsCacheInMemory.prototype.removeFromSegment = function (name) {\n    delete this.segmentCache[name];\n    return true;\n  };\n  MySegmentsCacheInMemory.prototype.isInSegment = function (name) {\n    return this.segmentCache[name] === true;\n  };\n  /**\n   * Reset (update) the cached list of segments with the given list, removing and adding segments if necessary.\n   * @NOTE based on the way we use segments in the browser, this way is the best option\n   *\n   * @param {string[]} names list of segment names\n   * @returns boolean indicating if the cache was updated (i.e., given list was different from the cached one)\n   */\n  MySegmentsCacheInMemory.prototype.resetSegments = function (names) {\n    var _this = this;\n    var isDiff = false;\n    var index;\n    var storedSegmentKeys = Object.keys(this.segmentCache);\n    // Extreme fast => everything is empty\n    if (names.length === 0 && storedSegmentKeys.length === names.length) return isDiff;\n    // Quick path\n    if (storedSegmentKeys.length !== names.length) {\n      isDiff = true;\n      this.segmentCache = {};\n      names.forEach(function (s) {\n        _this.addToSegment(s);\n      });\n    } else {\n      // Slowest path => we need to find at least 1 difference because\n      for (index = 0; index < names.length && this.isInSegment(names[index]); index++) {\n        // TODO: why empty statement?\n      }\n      if (index < names.length) {\n        isDiff = true;\n        this.segmentCache = {};\n        names.forEach(function (s) {\n          _this.addToSegment(s);\n        });\n      }\n    }\n    return isDiff;\n  };\n  MySegmentsCacheInMemory.prototype.getRegisteredSegments = function () {\n    return Object.keys(this.segmentCache);\n  };\n  MySegmentsCacheInMemory.prototype.getKeysCount = function () {\n    return 1;\n  };\n  return MySegmentsCacheInMemory;\n}(AbstractSegmentsCacheSync);\nexport { MySegmentsCacheInMemory };","map":{"version":3,"names":["__extends","AbstractSegmentsCacheSync","MySegmentsCacheInMemory","_super","_this","apply","arguments","segmentCache","prototype","clear","addToSegment","name","removeFromSegment","isInSegment","resetSegments","names","isDiff","index","storedSegmentKeys","Object","keys","length","forEach","s","getRegisteredSegments","getKeysCount"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/inMemory/MySegmentsCacheInMemory.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { AbstractSegmentsCacheSync } from '../AbstractSegmentsCacheSync';\n/**\n * Default MySegmentsCacheInMemory implementation that stores MySegments in memory.\n * Supported by all JS runtimes.\n */\nvar MySegmentsCacheInMemory = /** @class */ (function (_super) {\n    __extends(MySegmentsCacheInMemory, _super);\n    function MySegmentsCacheInMemory() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.segmentCache = {};\n        return _this;\n    }\n    MySegmentsCacheInMemory.prototype.clear = function () {\n        this.segmentCache = {};\n    };\n    MySegmentsCacheInMemory.prototype.addToSegment = function (name) {\n        this.segmentCache[name] = true;\n        return true;\n    };\n    MySegmentsCacheInMemory.prototype.removeFromSegment = function (name) {\n        delete this.segmentCache[name];\n        return true;\n    };\n    MySegmentsCacheInMemory.prototype.isInSegment = function (name) {\n        return this.segmentCache[name] === true;\n    };\n    /**\n     * Reset (update) the cached list of segments with the given list, removing and adding segments if necessary.\n     * @NOTE based on the way we use segments in the browser, this way is the best option\n     *\n     * @param {string[]} names list of segment names\n     * @returns boolean indicating if the cache was updated (i.e., given list was different from the cached one)\n     */\n    MySegmentsCacheInMemory.prototype.resetSegments = function (names) {\n        var _this = this;\n        var isDiff = false;\n        var index;\n        var storedSegmentKeys = Object.keys(this.segmentCache);\n        // Extreme fast => everything is empty\n        if (names.length === 0 && storedSegmentKeys.length === names.length)\n            return isDiff;\n        // Quick path\n        if (storedSegmentKeys.length !== names.length) {\n            isDiff = true;\n            this.segmentCache = {};\n            names.forEach(function (s) {\n                _this.addToSegment(s);\n            });\n        }\n        else {\n            // Slowest path => we need to find at least 1 difference because\n            for (index = 0; index < names.length && this.isInSegment(names[index]); index++) {\n                // TODO: why empty statement?\n            }\n            if (index < names.length) {\n                isDiff = true;\n                this.segmentCache = {};\n                names.forEach(function (s) {\n                    _this.addToSegment(s);\n                });\n            }\n        }\n        return isDiff;\n    };\n    MySegmentsCacheInMemory.prototype.getRegisteredSegments = function () {\n        return Object.keys(this.segmentCache);\n    };\n    MySegmentsCacheInMemory.prototype.getKeysCount = function () {\n        return 1;\n    };\n    return MySegmentsCacheInMemory;\n}(AbstractSegmentsCacheSync));\nexport { MySegmentsCacheInMemory };\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,OAAO;AACjC,SAASC,yBAAyB,QAAQ,8BAA8B;AACxE;AACA;AACA;AACA;AACA,IAAIC,uBAAuB,GAAG,aAAe,UAAUC,MAAM,EAAE;EAC3DH,SAAS,CAACE,uBAAuB,EAAEC,MAAM,CAAC;EAC1C,SAASD,uBAAuB,GAAG;IAC/B,IAAIE,KAAK,GAAGD,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC,IAAI,IAAI;IACpEF,KAAK,CAACG,YAAY,GAAG,CAAC,CAAC;IACvB,OAAOH,KAAK;EAChB;EACAF,uBAAuB,CAACM,SAAS,CAACC,KAAK,GAAG,YAAY;IAClD,IAAI,CAACF,YAAY,GAAG,CAAC,CAAC;EAC1B,CAAC;EACDL,uBAAuB,CAACM,SAAS,CAACE,YAAY,GAAG,UAAUC,IAAI,EAAE;IAC7D,IAAI,CAACJ,YAAY,CAACI,IAAI,CAAC,GAAG,IAAI;IAC9B,OAAO,IAAI;EACf,CAAC;EACDT,uBAAuB,CAACM,SAAS,CAACI,iBAAiB,GAAG,UAAUD,IAAI,EAAE;IAClE,OAAO,IAAI,CAACJ,YAAY,CAACI,IAAI,CAAC;IAC9B,OAAO,IAAI;EACf,CAAC;EACDT,uBAAuB,CAACM,SAAS,CAACK,WAAW,GAAG,UAAUF,IAAI,EAAE;IAC5D,OAAO,IAAI,CAACJ,YAAY,CAACI,IAAI,CAAC,KAAK,IAAI;EAC3C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIT,uBAAuB,CAACM,SAAS,CAACM,aAAa,GAAG,UAAUC,KAAK,EAAE;IAC/D,IAAIX,KAAK,GAAG,IAAI;IAChB,IAAIY,MAAM,GAAG,KAAK;IAClB,IAAIC,KAAK;IACT,IAAIC,iBAAiB,GAAGC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACb,YAAY,CAAC;IACtD;IACA,IAAIQ,KAAK,CAACM,MAAM,KAAK,CAAC,IAAIH,iBAAiB,CAACG,MAAM,KAAKN,KAAK,CAACM,MAAM,EAC/D,OAAOL,MAAM;IACjB;IACA,IAAIE,iBAAiB,CAACG,MAAM,KAAKN,KAAK,CAACM,MAAM,EAAE;MAC3CL,MAAM,GAAG,IAAI;MACb,IAAI,CAACT,YAAY,GAAG,CAAC,CAAC;MACtBQ,KAAK,CAACO,OAAO,CAAC,UAAUC,CAAC,EAAE;QACvBnB,KAAK,CAACM,YAAY,CAACa,CAAC,CAAC;MACzB,CAAC,CAAC;IACN,CAAC,MACI;MACD;MACA,KAAKN,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,KAAK,CAACM,MAAM,IAAI,IAAI,CAACR,WAAW,CAACE,KAAK,CAACE,KAAK,CAAC,CAAC,EAAEA,KAAK,EAAE,EAAE;QAC7E;MAAA;MAEJ,IAAIA,KAAK,GAAGF,KAAK,CAACM,MAAM,EAAE;QACtBL,MAAM,GAAG,IAAI;QACb,IAAI,CAACT,YAAY,GAAG,CAAC,CAAC;QACtBQ,KAAK,CAACO,OAAO,CAAC,UAAUC,CAAC,EAAE;UACvBnB,KAAK,CAACM,YAAY,CAACa,CAAC,CAAC;QACzB,CAAC,CAAC;MACN;IACJ;IACA,OAAOP,MAAM;EACjB,CAAC;EACDd,uBAAuB,CAACM,SAAS,CAACgB,qBAAqB,GAAG,YAAY;IAClE,OAAOL,MAAM,CAACC,IAAI,CAAC,IAAI,CAACb,YAAY,CAAC;EACzC,CAAC;EACDL,uBAAuB,CAACM,SAAS,CAACiB,YAAY,GAAG,YAAY;IACzD,OAAO,CAAC;EACZ,CAAC;EACD,OAAOvB,uBAAuB;AAClC,CAAC,CAACD,yBAAyB,CAAE;AAC7B,SAASC,uBAAuB"},"metadata":{},"sourceType":"module"}