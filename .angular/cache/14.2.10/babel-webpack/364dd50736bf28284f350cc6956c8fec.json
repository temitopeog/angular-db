{"ast":null,"code":"import { _Set, setToArray } from '../../../utils/lang/sets';\nimport { timeout } from '../../../utils/promise/timeout';\nimport { SDK_SPLITS_ARRIVED, SDK_SPLITS_CACHE_LOADED } from '../../../readiness/constants';\nimport { SYNC_SPLITS_FETCH, SYNC_SPLITS_NEW, SYNC_SPLITS_REMOVED, SYNC_SPLITS_SEGMENTS, SYNC_SPLITS_FETCH_FAILS, SYNC_SPLITS_FETCH_RETRY } from '../../../logger/constants';\n// Checks that all registered segments have been fetched (changeNumber !== -1 for every segment).\n// Returns a promise that could be rejected.\n// @TODO review together with Segments and MySegments storage APIs\nfunction checkAllSegmentsExist(segments) {\n  var registeredSegments = Promise.resolve(segments.getRegisteredSegments());\n  return registeredSegments.then(function (segmentNames) {\n    return Promise.all(segmentNames.map(function (segmentName) {\n      return segments.getChangeNumber(segmentName);\n    })).then(function (changeNumbers) {\n      return changeNumbers.every(function (changeNumber) {\n        return changeNumber !== -1;\n      });\n    });\n  });\n}\n/**\n * Collect segments from a raw split definition.\n * Exported for testing purposes.\n */\nexport function parseSegments(_a) {\n  var conditions = _a.conditions;\n  var segments = new _Set();\n  for (var i = 0; i < conditions.length; i++) {\n    var matchers = conditions[i].matcherGroup.matchers;\n    matchers.forEach(function (matcher) {\n      if (matcher.matcherType === 'IN_SEGMENT') segments.add(matcher.userDefinedSegmentMatcherData.segmentName);\n    });\n  }\n  return segments;\n}\n/**\n * Given the list of splits from /splitChanges endpoint, it returns the mutations,\n * i.e., an object with added splits, removed splits and used segments.\n * Exported for testing purposes.\n */\nexport function computeSplitsMutation(entries) {\n  var segments = new _Set();\n  var computed = entries.reduce(function (accum, split) {\n    if (split.status === 'ACTIVE') {\n      accum.added.push([split.name, JSON.stringify(split)]);\n      parseSegments(split).forEach(function (segmentName) {\n        segments.add(segmentName);\n      });\n    } else {\n      accum.removed.push(split.name);\n    }\n    return accum;\n  }, {\n    added: [],\n    removed: [],\n    segments: []\n  });\n  computed.segments = setToArray(segments);\n  return computed;\n}\n/**\n * factory of SplitChanges updater, a task that:\n *  - fetches split changes using `splitChangesFetcher`\n *  - updates `splitsCache`\n *  - uses `splitsEventEmitter` to emit events related to split data updates\n *\n * @param log  Logger instance\n * @param splitChangesFetcher  Fetcher of `/splitChanges`\n * @param splits  Splits storage, with sync or async methods\n * @param segments  Segments storage, with sync or async methods\n * @param splitsEventEmitter  Optional readiness manager. Not required for synchronizer or producer mode.\n * @param requestTimeoutBeforeReady  How long the updater will wait for the request to timeout. Default 0, i.e., never timeout.\n * @param retriesOnFailureBeforeReady  How many retries on `/splitChanges` we the updater do in case of failure or timeout. Default 0, i.e., no retries.\n */\nexport function splitChangesUpdaterFactory(log, splitChangesFetcher, splits, segments, splitsEventEmitter, requestTimeoutBeforeReady, retriesOnFailureBeforeReady, isClientSide) {\n  if (requestTimeoutBeforeReady === void 0) {\n    requestTimeoutBeforeReady = 0;\n  }\n  if (retriesOnFailureBeforeReady === void 0) {\n    retriesOnFailureBeforeReady = 0;\n  }\n  var startingUp = true;\n  /** timeout decorator for `splitChangesFetcher` promise  */\n  function _promiseDecorator(promise) {\n    if (startingUp && requestTimeoutBeforeReady) promise = timeout(requestTimeoutBeforeReady, promise);\n    return promise;\n  }\n  /**\n   * SplitChanges updater returns a promise that resolves with a `false` boolean value if it fails to fetch splits or synchronize them with the storage.\n   * Returned promise will not be rejected.\n   *\n   * @param {boolean | undefined} noCache true to revalidate data to fetch\n   */\n  return function splitChangesUpdater(noCache) {\n    /**\n     * @param {number} since current changeNumber at splitsCache\n     * @param {number} retry current number of retry attemps\n     */\n    function _splitChangesUpdater(since, retry) {\n      if (retry === void 0) {\n        retry = 0;\n      }\n      log.debug(SYNC_SPLITS_FETCH, [since]);\n      var fetcherPromise = splitChangesFetcher(since, noCache, _promiseDecorator).then(function (splitChanges) {\n        startingUp = false;\n        var mutation = computeSplitsMutation(splitChanges.splits);\n        log.debug(SYNC_SPLITS_NEW, [mutation.added.length]);\n        log.debug(SYNC_SPLITS_REMOVED, [mutation.removed.length]);\n        log.debug(SYNC_SPLITS_SEGMENTS, [mutation.segments.length]);\n        // Write into storage\n        // @TODO call `setChangeNumber` only if the other storage operations have succeeded, in order to keep storage consistency\n        return Promise.all([\n        // calling first `setChangenumber` method, to perform cache flush if split filter queryString changed\n        splits.setChangeNumber(splitChanges.till), splits.addSplits(mutation.added), splits.removeSplits(mutation.removed), segments.registerSegments(mutation.segments)]).then(function () {\n          if (splitsEventEmitter) {\n            // To emit SDK_SPLITS_ARRIVED for server-side SDK, we must check that all registered segments have been fetched\n            return Promise.resolve(!splitsEventEmitter.splitsArrived || since !== splitChanges.till && (isClientSide || checkAllSegmentsExist(segments))).catch(function () {\n              return false;\n            } /** noop. just to handle a possible `checkAllSegmentsExist` rejection, before emitting SDK event */).then(function (emitSplitsArrivedEvent) {\n              // emit SDK events\n              if (emitSplitsArrivedEvent) splitsEventEmitter.emit(SDK_SPLITS_ARRIVED);\n              return true;\n            });\n          }\n          return true;\n        });\n      }).catch(function (error) {\n        log.warn(SYNC_SPLITS_FETCH_FAILS, [error]);\n        if (startingUp && retriesOnFailureBeforeReady > retry) {\n          retry += 1;\n          log.info(SYNC_SPLITS_FETCH_RETRY, [retry, error]);\n          return _splitChangesUpdater(since, retry);\n        } else {\n          startingUp = false;\n        }\n        return false;\n      });\n      // After triggering the requests, if we have cached splits information let's notify that to emit SDK_READY_FROM_CACHE.\n      // Wrapping in a promise since checkCache can be async.\n      if (splitsEventEmitter && startingUp) {\n        Promise.resolve(splits.checkCache()).then(function (isCacheReady) {\n          if (isCacheReady) splitsEventEmitter.emit(SDK_SPLITS_CACHE_LOADED);\n        });\n      }\n      return fetcherPromise;\n    }\n    var sincePromise = Promise.resolve(splits.getChangeNumber()); // `getChangeNumber` never rejects or throws error\n    return sincePromise.then(_splitChangesUpdater);\n  };\n}","map":{"version":3,"names":["_Set","setToArray","timeout","SDK_SPLITS_ARRIVED","SDK_SPLITS_CACHE_LOADED","SYNC_SPLITS_FETCH","SYNC_SPLITS_NEW","SYNC_SPLITS_REMOVED","SYNC_SPLITS_SEGMENTS","SYNC_SPLITS_FETCH_FAILS","SYNC_SPLITS_FETCH_RETRY","checkAllSegmentsExist","segments","registeredSegments","Promise","resolve","getRegisteredSegments","then","segmentNames","all","map","segmentName","getChangeNumber","changeNumbers","every","changeNumber","parseSegments","_a","conditions","i","length","matchers","matcherGroup","forEach","matcher","matcherType","add","userDefinedSegmentMatcherData","computeSplitsMutation","entries","computed","reduce","accum","split","status","added","push","name","JSON","stringify","removed","splitChangesUpdaterFactory","log","splitChangesFetcher","splits","splitsEventEmitter","requestTimeoutBeforeReady","retriesOnFailureBeforeReady","isClientSide","startingUp","_promiseDecorator","promise","splitChangesUpdater","noCache","_splitChangesUpdater","since","retry","debug","fetcherPromise","splitChanges","mutation","setChangeNumber","till","addSplits","removeSplits","registerSegments","splitsArrived","catch","emitSplitsArrivedEvent","emit","error","warn","info","checkCache","isCacheReady","sincePromise"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/polling/updaters/splitChangesUpdater.js"],"sourcesContent":["import { _Set, setToArray } from '../../../utils/lang/sets';\nimport { timeout } from '../../../utils/promise/timeout';\nimport { SDK_SPLITS_ARRIVED, SDK_SPLITS_CACHE_LOADED } from '../../../readiness/constants';\nimport { SYNC_SPLITS_FETCH, SYNC_SPLITS_NEW, SYNC_SPLITS_REMOVED, SYNC_SPLITS_SEGMENTS, SYNC_SPLITS_FETCH_FAILS, SYNC_SPLITS_FETCH_RETRY } from '../../../logger/constants';\n// Checks that all registered segments have been fetched (changeNumber !== -1 for every segment).\n// Returns a promise that could be rejected.\n// @TODO review together with Segments and MySegments storage APIs\nfunction checkAllSegmentsExist(segments) {\n    var registeredSegments = Promise.resolve(segments.getRegisteredSegments());\n    return registeredSegments.then(function (segmentNames) {\n        return Promise.all(segmentNames.map(function (segmentName) { return segments.getChangeNumber(segmentName); }))\n            .then(function (changeNumbers) { return changeNumbers.every(function (changeNumber) { return changeNumber !== -1; }); });\n    });\n}\n/**\n * Collect segments from a raw split definition.\n * Exported for testing purposes.\n */\nexport function parseSegments(_a) {\n    var conditions = _a.conditions;\n    var segments = new _Set();\n    for (var i = 0; i < conditions.length; i++) {\n        var matchers = conditions[i].matcherGroup.matchers;\n        matchers.forEach(function (matcher) {\n            if (matcher.matcherType === 'IN_SEGMENT')\n                segments.add(matcher.userDefinedSegmentMatcherData.segmentName);\n        });\n    }\n    return segments;\n}\n/**\n * Given the list of splits from /splitChanges endpoint, it returns the mutations,\n * i.e., an object with added splits, removed splits and used segments.\n * Exported for testing purposes.\n */\nexport function computeSplitsMutation(entries) {\n    var segments = new _Set();\n    var computed = entries.reduce(function (accum, split) {\n        if (split.status === 'ACTIVE') {\n            accum.added.push([split.name, JSON.stringify(split)]);\n            parseSegments(split).forEach(function (segmentName) {\n                segments.add(segmentName);\n            });\n        }\n        else {\n            accum.removed.push(split.name);\n        }\n        return accum;\n    }, { added: [], removed: [], segments: [] });\n    computed.segments = setToArray(segments);\n    return computed;\n}\n/**\n * factory of SplitChanges updater, a task that:\n *  - fetches split changes using `splitChangesFetcher`\n *  - updates `splitsCache`\n *  - uses `splitsEventEmitter` to emit events related to split data updates\n *\n * @param log  Logger instance\n * @param splitChangesFetcher  Fetcher of `/splitChanges`\n * @param splits  Splits storage, with sync or async methods\n * @param segments  Segments storage, with sync or async methods\n * @param splitsEventEmitter  Optional readiness manager. Not required for synchronizer or producer mode.\n * @param requestTimeoutBeforeReady  How long the updater will wait for the request to timeout. Default 0, i.e., never timeout.\n * @param retriesOnFailureBeforeReady  How many retries on `/splitChanges` we the updater do in case of failure or timeout. Default 0, i.e., no retries.\n */\nexport function splitChangesUpdaterFactory(log, splitChangesFetcher, splits, segments, splitsEventEmitter, requestTimeoutBeforeReady, retriesOnFailureBeforeReady, isClientSide) {\n    if (requestTimeoutBeforeReady === void 0) { requestTimeoutBeforeReady = 0; }\n    if (retriesOnFailureBeforeReady === void 0) { retriesOnFailureBeforeReady = 0; }\n    var startingUp = true;\n    /** timeout decorator for `splitChangesFetcher` promise  */\n    function _promiseDecorator(promise) {\n        if (startingUp && requestTimeoutBeforeReady)\n            promise = timeout(requestTimeoutBeforeReady, promise);\n        return promise;\n    }\n    /**\n     * SplitChanges updater returns a promise that resolves with a `false` boolean value if it fails to fetch splits or synchronize them with the storage.\n     * Returned promise will not be rejected.\n     *\n     * @param {boolean | undefined} noCache true to revalidate data to fetch\n     */\n    return function splitChangesUpdater(noCache) {\n        /**\n         * @param {number} since current changeNumber at splitsCache\n         * @param {number} retry current number of retry attemps\n         */\n        function _splitChangesUpdater(since, retry) {\n            if (retry === void 0) { retry = 0; }\n            log.debug(SYNC_SPLITS_FETCH, [since]);\n            var fetcherPromise = splitChangesFetcher(since, noCache, _promiseDecorator)\n                .then(function (splitChanges) {\n                startingUp = false;\n                var mutation = computeSplitsMutation(splitChanges.splits);\n                log.debug(SYNC_SPLITS_NEW, [mutation.added.length]);\n                log.debug(SYNC_SPLITS_REMOVED, [mutation.removed.length]);\n                log.debug(SYNC_SPLITS_SEGMENTS, [mutation.segments.length]);\n                // Write into storage\n                // @TODO call `setChangeNumber` only if the other storage operations have succeeded, in order to keep storage consistency\n                return Promise.all([\n                    // calling first `setChangenumber` method, to perform cache flush if split filter queryString changed\n                    splits.setChangeNumber(splitChanges.till),\n                    splits.addSplits(mutation.added),\n                    splits.removeSplits(mutation.removed),\n                    segments.registerSegments(mutation.segments)\n                ]).then(function () {\n                    if (splitsEventEmitter) {\n                        // To emit SDK_SPLITS_ARRIVED for server-side SDK, we must check that all registered segments have been fetched\n                        return Promise.resolve(!splitsEventEmitter.splitsArrived || (since !== splitChanges.till && (isClientSide || checkAllSegmentsExist(segments))))\n                            .catch(function () { return false; } /** noop. just to handle a possible `checkAllSegmentsExist` rejection, before emitting SDK event */)\n                            .then(function (emitSplitsArrivedEvent) {\n                            // emit SDK events\n                            if (emitSplitsArrivedEvent)\n                                splitsEventEmitter.emit(SDK_SPLITS_ARRIVED);\n                            return true;\n                        });\n                    }\n                    return true;\n                });\n            })\n                .catch(function (error) {\n                log.warn(SYNC_SPLITS_FETCH_FAILS, [error]);\n                if (startingUp && retriesOnFailureBeforeReady > retry) {\n                    retry += 1;\n                    log.info(SYNC_SPLITS_FETCH_RETRY, [retry, error]);\n                    return _splitChangesUpdater(since, retry);\n                }\n                else {\n                    startingUp = false;\n                }\n                return false;\n            });\n            // After triggering the requests, if we have cached splits information let's notify that to emit SDK_READY_FROM_CACHE.\n            // Wrapping in a promise since checkCache can be async.\n            if (splitsEventEmitter && startingUp) {\n                Promise.resolve(splits.checkCache()).then(function (isCacheReady) {\n                    if (isCacheReady)\n                        splitsEventEmitter.emit(SDK_SPLITS_CACHE_LOADED);\n                });\n            }\n            return fetcherPromise;\n        }\n        var sincePromise = Promise.resolve(splits.getChangeNumber()); // `getChangeNumber` never rejects or throws error\n        return sincePromise.then(_splitChangesUpdater);\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}