{"ast":null,"code":"import { isObject, uniq, toString, toNumber } from '../../utils/lang';\nimport { zeroSinceHH, zeroSinceSS } from '../convertions';\nimport { matcherTypes, matcherDataTypes } from '../matchers/matcherTypes';\nimport { ENGINE_SANITIZE } from '../../logger/constants';\nfunction sanitizeNumber(val) {\n  var num = toNumber(val);\n  return isNaN(num) ? undefined : num;\n}\nfunction sanitizeString(val) {\n  var valueToSanitize = val;\n  if (isObject(val)) {\n    // If the value is an object and is not a key, discard it.\n    valueToSanitize = val.matchingKey ? val.matchingKey : undefined;\n  }\n  var str = toString(valueToSanitize);\n  return str ? str : undefined;\n}\nfunction sanitizeArray(val) {\n  var arr = Array.isArray(val) ? uniq(val.map(function (e) {\n    return e + '';\n  })) : [];\n  return arr.length ? arr : undefined;\n}\nfunction sanitizeBoolean(val) {\n  if (val === true || val === false) return val;\n  if (typeof val === 'string') {\n    var lowerCaseValue = val.toLocaleLowerCase();\n    if (lowerCaseValue === 'true') return true;\n    if (lowerCaseValue === 'false') return false;\n  }\n  return undefined;\n}\nfunction dependencyProcessor(sanitizedValue, attributes) {\n  return {\n    key: sanitizedValue,\n    attributes: attributes\n  };\n}\n/**\n * We can define a pre-processing for the value, to be executed prior to matcher evaluation.\n */\nfunction getProcessingFunction(matcherTypeID, dataType) {\n  switch (matcherTypeID) {\n    case matcherTypes.EQUAL_TO:\n      return dataType === 'DATETIME' ? zeroSinceHH : undefined;\n    case matcherTypes.GREATER_THAN_OR_EQUAL_TO:\n    case matcherTypes.LESS_THAN_OR_EQUAL_TO:\n    case matcherTypes.BETWEEN:\n      return dataType === 'DATETIME' ? zeroSinceSS : undefined;\n    case matcherTypes.IN_SPLIT_TREATMENT:\n      return dependencyProcessor;\n    default:\n      return undefined;\n  }\n}\n/**\n * Sanitize matcher value\n */\nexport function sanitize(log, matcherTypeID, value, dataType, attributes) {\n  var processor = getProcessingFunction(matcherTypeID, dataType);\n  var sanitizedValue;\n  switch (dataType) {\n    case matcherDataTypes.NUMBER:\n    case matcherDataTypes.DATETIME:\n      sanitizedValue = sanitizeNumber(value);\n      break;\n    case matcherDataTypes.STRING:\n      sanitizedValue = sanitizeString(value);\n      break;\n    case matcherDataTypes.SET:\n      sanitizedValue = sanitizeArray(value);\n      break;\n    case matcherDataTypes.BOOLEAN:\n      sanitizedValue = sanitizeBoolean(value);\n      break;\n    case matcherDataTypes.NOT_SPECIFIED:\n      sanitizedValue = value;\n      break;\n    default:\n      sanitizedValue = undefined;\n  }\n  if (processor) {\n    // @ts-ignore\n    sanitizedValue = processor(sanitizedValue, attributes);\n  }\n  log.debug(ENGINE_SANITIZE, [value, dataType, sanitizedValue instanceof Object ? JSON.stringify(sanitizedValue) : sanitizedValue]);\n  return sanitizedValue;\n}","map":{"version":3,"names":["isObject","uniq","toString","toNumber","zeroSinceHH","zeroSinceSS","matcherTypes","matcherDataTypes","ENGINE_SANITIZE","sanitizeNumber","val","num","isNaN","undefined","sanitizeString","valueToSanitize","matchingKey","str","sanitizeArray","arr","Array","isArray","map","e","length","sanitizeBoolean","lowerCaseValue","toLocaleLowerCase","dependencyProcessor","sanitizedValue","attributes","key","getProcessingFunction","matcherTypeID","dataType","EQUAL_TO","GREATER_THAN_OR_EQUAL_TO","LESS_THAN_OR_EQUAL_TO","BETWEEN","IN_SPLIT_TREATMENT","sanitize","log","value","processor","NUMBER","DATETIME","STRING","SET","BOOLEAN","NOT_SPECIFIED","debug","Object","JSON","stringify"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/evaluator/value/sanitize.js"],"sourcesContent":["import { isObject, uniq, toString, toNumber } from '../../utils/lang';\nimport { zeroSinceHH, zeroSinceSS } from '../convertions';\nimport { matcherTypes, matcherDataTypes } from '../matchers/matcherTypes';\nimport { ENGINE_SANITIZE } from '../../logger/constants';\nfunction sanitizeNumber(val) {\n    var num = toNumber(val);\n    return isNaN(num) ? undefined : num;\n}\nfunction sanitizeString(val) {\n    var valueToSanitize = val;\n    if (isObject(val)) {\n        // If the value is an object and is not a key, discard it.\n        valueToSanitize = val.matchingKey ? val.matchingKey : undefined;\n    }\n    var str = toString(valueToSanitize);\n    return str ? str : undefined;\n}\nfunction sanitizeArray(val) {\n    var arr = Array.isArray(val) ? uniq(val.map(function (e) { return e + ''; })) : [];\n    return arr.length ? arr : undefined;\n}\nfunction sanitizeBoolean(val) {\n    if (val === true || val === false)\n        return val;\n    if (typeof val === 'string') {\n        var lowerCaseValue = val.toLocaleLowerCase();\n        if (lowerCaseValue === 'true')\n            return true;\n        if (lowerCaseValue === 'false')\n            return false;\n    }\n    return undefined;\n}\nfunction dependencyProcessor(sanitizedValue, attributes) {\n    return {\n        key: sanitizedValue,\n        attributes: attributes\n    };\n}\n/**\n * We can define a pre-processing for the value, to be executed prior to matcher evaluation.\n */\nfunction getProcessingFunction(matcherTypeID, dataType) {\n    switch (matcherTypeID) {\n        case matcherTypes.EQUAL_TO:\n            return dataType === 'DATETIME' ? zeroSinceHH : undefined;\n        case matcherTypes.GREATER_THAN_OR_EQUAL_TO:\n        case matcherTypes.LESS_THAN_OR_EQUAL_TO:\n        case matcherTypes.BETWEEN:\n            return dataType === 'DATETIME' ? zeroSinceSS : undefined;\n        case matcherTypes.IN_SPLIT_TREATMENT:\n            return dependencyProcessor;\n        default:\n            return undefined;\n    }\n}\n/**\n * Sanitize matcher value\n */\nexport function sanitize(log, matcherTypeID, value, dataType, attributes) {\n    var processor = getProcessingFunction(matcherTypeID, dataType);\n    var sanitizedValue;\n    switch (dataType) {\n        case matcherDataTypes.NUMBER:\n        case matcherDataTypes.DATETIME:\n            sanitizedValue = sanitizeNumber(value);\n            break;\n        case matcherDataTypes.STRING:\n            sanitizedValue = sanitizeString(value);\n            break;\n        case matcherDataTypes.SET:\n            sanitizedValue = sanitizeArray(value);\n            break;\n        case matcherDataTypes.BOOLEAN:\n            sanitizedValue = sanitizeBoolean(value);\n            break;\n        case matcherDataTypes.NOT_SPECIFIED:\n            sanitizedValue = value;\n            break;\n        default:\n            sanitizedValue = undefined;\n    }\n    if (processor) {\n        // @ts-ignore\n        sanitizedValue = processor(sanitizedValue, attributes);\n    }\n    log.debug(ENGINE_SANITIZE, [value, dataType, sanitizedValue instanceof Object ? JSON.stringify(sanitizedValue) : sanitizedValue]);\n    return sanitizedValue;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}