{"ast":null,"code":"import { objectAssign } from '../utils/lang/objectAssign';\nimport { thenable } from '../utils/promise/thenable';\nimport { EVENTS_TRACKER_SUCCESS, ERROR_EVENTS_TRACKER } from '../logger/constants';\nimport { CONSENT_DECLINED, DROPPED, QUEUED } from '../utils/constants';\nimport { isStorageSync } from './impressionObserver/utils';\n/**\n * Event tracker stores events in cache and pass them to the integrations manager if provided.\n *\n * @param eventsCache cache to save events\n * @param integrationsManager optional event handler used for integrations\n */\nexport function eventTrackerFactory(settings, eventsCache, integrationsManager, telemetryCache) {\n  var log = settings.log;\n  var isSync = isStorageSync(settings);\n  function queueEventsCallback(eventData, tracked) {\n    var eventTypeId = eventData.eventTypeId,\n      trafficTypeName = eventData.trafficTypeName,\n      key = eventData.key,\n      value = eventData.value,\n      timestamp = eventData.timestamp,\n      properties = eventData.properties;\n    // Logging every prop would be too much.\n    var msg = \"event of type \\\"\" + eventTypeId + \"\\\" for traffic type \\\"\" + trafficTypeName + \"\\\". Key: \" + key + \". Value: \" + value + \". Timestamp: \" + timestamp + \". \" + (properties ? 'With properties.' : 'With no properties.');\n    if (tracked) {\n      log.info(EVENTS_TRACKER_SUCCESS, [msg]);\n      if (integrationsManager) {\n        // Wrap in a timeout because we don't want it to be blocking.\n        setTimeout(function () {\n          // copy of event, to avoid unexpected behaviour if modified by integrations\n          var eventDataCopy = objectAssign({}, eventData);\n          if (eventData.properties) eventDataCopy.properties = objectAssign({}, eventData.properties);\n          // integrationsManager does not throw errors (they are internally handled by each integration module)\n          integrationsManager.handleEvent(eventDataCopy);\n        }, 0);\n      }\n    } else {\n      log.error(ERROR_EVENTS_TRACKER, [msg]);\n    }\n    return tracked;\n  }\n  return {\n    track: function (eventData, size) {\n      if (settings.userConsent === CONSENT_DECLINED) {\n        return isSync ? false : Promise.resolve(false);\n      }\n      var tracked = eventsCache.track(eventData, size);\n      if (thenable(tracked)) {\n        return tracked.then(queueEventsCallback.bind(null, eventData));\n      } else {\n        // Record when eventsCache is sync only (standalone mode)\n        // @TODO we are not dropping events on full queue yet, so `tracked` is always true ATM\n        if (telemetryCache) telemetryCache.recordEventStats(tracked ? QUEUED : DROPPED, 1);\n        return queueEventsCallback(eventData, tracked);\n      }\n    }\n  };\n}","map":{"version":3,"names":["objectAssign","thenable","EVENTS_TRACKER_SUCCESS","ERROR_EVENTS_TRACKER","CONSENT_DECLINED","DROPPED","QUEUED","isStorageSync","eventTrackerFactory","settings","eventsCache","integrationsManager","telemetryCache","log","isSync","queueEventsCallback","eventData","tracked","eventTypeId","trafficTypeName","key","value","timestamp","properties","msg","info","setTimeout","eventDataCopy","handleEvent","error","track","size","userConsent","Promise","resolve","then","bind","recordEventStats"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/trackers/eventTracker.js"],"sourcesContent":["import { objectAssign } from '../utils/lang/objectAssign';\nimport { thenable } from '../utils/promise/thenable';\nimport { EVENTS_TRACKER_SUCCESS, ERROR_EVENTS_TRACKER } from '../logger/constants';\nimport { CONSENT_DECLINED, DROPPED, QUEUED } from '../utils/constants';\nimport { isStorageSync } from './impressionObserver/utils';\n/**\n * Event tracker stores events in cache and pass them to the integrations manager if provided.\n *\n * @param eventsCache cache to save events\n * @param integrationsManager optional event handler used for integrations\n */\nexport function eventTrackerFactory(settings, eventsCache, integrationsManager, telemetryCache) {\n    var log = settings.log;\n    var isSync = isStorageSync(settings);\n    function queueEventsCallback(eventData, tracked) {\n        var eventTypeId = eventData.eventTypeId, trafficTypeName = eventData.trafficTypeName, key = eventData.key, value = eventData.value, timestamp = eventData.timestamp, properties = eventData.properties;\n        // Logging every prop would be too much.\n        var msg = \"event of type \\\"\" + eventTypeId + \"\\\" for traffic type \\\"\" + trafficTypeName + \"\\\". Key: \" + key + \". Value: \" + value + \". Timestamp: \" + timestamp + \". \" + (properties ? 'With properties.' : 'With no properties.');\n        if (tracked) {\n            log.info(EVENTS_TRACKER_SUCCESS, [msg]);\n            if (integrationsManager) {\n                // Wrap in a timeout because we don't want it to be blocking.\n                setTimeout(function () {\n                    // copy of event, to avoid unexpected behaviour if modified by integrations\n                    var eventDataCopy = objectAssign({}, eventData);\n                    if (eventData.properties)\n                        eventDataCopy.properties = objectAssign({}, eventData.properties);\n                    // integrationsManager does not throw errors (they are internally handled by each integration module)\n                    integrationsManager.handleEvent(eventDataCopy);\n                }, 0);\n            }\n        }\n        else {\n            log.error(ERROR_EVENTS_TRACKER, [msg]);\n        }\n        return tracked;\n    }\n    return {\n        track: function (eventData, size) {\n            if (settings.userConsent === CONSENT_DECLINED) {\n                return isSync ? false : Promise.resolve(false);\n            }\n            var tracked = eventsCache.track(eventData, size);\n            if (thenable(tracked)) {\n                return tracked.then(queueEventsCallback.bind(null, eventData));\n            }\n            else {\n                // Record when eventsCache is sync only (standalone mode)\n                // @TODO we are not dropping events on full queue yet, so `tracked` is always true ATM\n                if (telemetryCache)\n                    telemetryCache.recordEventStats(tracked ? QUEUED : DROPPED, 1);\n                return queueEventsCallback(eventData, tracked);\n            }\n        }\n    };\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,4BAA4B;AACzD,SAASC,QAAQ,QAAQ,2BAA2B;AACpD,SAASC,sBAAsB,EAAEC,oBAAoB,QAAQ,qBAAqB;AAClF,SAASC,gBAAgB,EAAEC,OAAO,EAAEC,MAAM,QAAQ,oBAAoB;AACtE,SAASC,aAAa,QAAQ,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmB,CAACC,QAAQ,EAAEC,WAAW,EAAEC,mBAAmB,EAAEC,cAAc,EAAE;EAC5F,IAAIC,GAAG,GAAGJ,QAAQ,CAACI,GAAG;EACtB,IAAIC,MAAM,GAAGP,aAAa,CAACE,QAAQ,CAAC;EACpC,SAASM,mBAAmB,CAACC,SAAS,EAAEC,OAAO,EAAE;IAC7C,IAAIC,WAAW,GAAGF,SAAS,CAACE,WAAW;MAAEC,eAAe,GAAGH,SAAS,CAACG,eAAe;MAAEC,GAAG,GAAGJ,SAAS,CAACI,GAAG;MAAEC,KAAK,GAAGL,SAAS,CAACK,KAAK;MAAEC,SAAS,GAAGN,SAAS,CAACM,SAAS;MAAEC,UAAU,GAAGP,SAAS,CAACO,UAAU;IACtM;IACA,IAAIC,GAAG,GAAG,kBAAkB,GAAGN,WAAW,GAAG,wBAAwB,GAAGC,eAAe,GAAG,WAAW,GAAGC,GAAG,GAAG,WAAW,GAAGC,KAAK,GAAG,eAAe,GAAGC,SAAS,GAAG,IAAI,IAAIC,UAAU,GAAG,kBAAkB,GAAG,qBAAqB,CAAC;IAClO,IAAIN,OAAO,EAAE;MACTJ,GAAG,CAACY,IAAI,CAACvB,sBAAsB,EAAE,CAACsB,GAAG,CAAC,CAAC;MACvC,IAAIb,mBAAmB,EAAE;QACrB;QACAe,UAAU,CAAC,YAAY;UACnB;UACA,IAAIC,aAAa,GAAG3B,YAAY,CAAC,CAAC,CAAC,EAAEgB,SAAS,CAAC;UAC/C,IAAIA,SAAS,CAACO,UAAU,EACpBI,aAAa,CAACJ,UAAU,GAAGvB,YAAY,CAAC,CAAC,CAAC,EAAEgB,SAAS,CAACO,UAAU,CAAC;UACrE;UACAZ,mBAAmB,CAACiB,WAAW,CAACD,aAAa,CAAC;QAClD,CAAC,EAAE,CAAC,CAAC;MACT;IACJ,CAAC,MACI;MACDd,GAAG,CAACgB,KAAK,CAAC1B,oBAAoB,EAAE,CAACqB,GAAG,CAAC,CAAC;IAC1C;IACA,OAAOP,OAAO;EAClB;EACA,OAAO;IACHa,KAAK,EAAE,UAAUd,SAAS,EAAEe,IAAI,EAAE;MAC9B,IAAItB,QAAQ,CAACuB,WAAW,KAAK5B,gBAAgB,EAAE;QAC3C,OAAOU,MAAM,GAAG,KAAK,GAAGmB,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;MAClD;MACA,IAAIjB,OAAO,GAAGP,WAAW,CAACoB,KAAK,CAACd,SAAS,EAAEe,IAAI,CAAC;MAChD,IAAI9B,QAAQ,CAACgB,OAAO,CAAC,EAAE;QACnB,OAAOA,OAAO,CAACkB,IAAI,CAACpB,mBAAmB,CAACqB,IAAI,CAAC,IAAI,EAAEpB,SAAS,CAAC,CAAC;MAClE,CAAC,MACI;QACD;QACA;QACA,IAAIJ,cAAc,EACdA,cAAc,CAACyB,gBAAgB,CAACpB,OAAO,GAAGX,MAAM,GAAGD,OAAO,EAAE,CAAC,CAAC;QAClE,OAAOU,mBAAmB,CAACC,SAAS,EAAEC,OAAO,CAAC;MAClD;IACJ;EACJ,CAAC;AACL"},"metadata":{},"sourceType":"module"}