{"ast":null,"code":"import { forOwn } from '../../utils/lang';\nimport { mySegmentsSyncTaskFactory } from './syncTasks/mySegmentsSyncTask';\nimport { splitsSyncTaskFactory } from './syncTasks/splitsSyncTask';\nimport { getMatching } from '../../utils/key';\nimport { SDK_SPLITS_ARRIVED, SDK_SEGMENTS_ARRIVED } from '../../readiness/constants';\nimport { POLLING_SMART_PAUSING, POLLING_START, POLLING_STOP } from '../../logger/constants';\n/**\n * Expose start / stop mechanism for polling data from services.\n * For client-side API with multiple clients.\n */\nexport function pollingManagerCSFactory(params) {\n  var splitApi = params.splitApi,\n    storage = params.storage,\n    readiness = params.readiness,\n    settings = params.settings;\n  var log = settings.log;\n  var splitsSyncTask = splitsSyncTaskFactory(splitApi.fetchSplitChanges, storage, readiness, settings, true);\n  // Map of matching keys to their corresponding MySegmentsSyncTask.\n  var mySegmentsSyncTasks = {};\n  var matchingKey = getMatching(settings.core.key);\n  var mySegmentsSyncTask = add(matchingKey, readiness, storage);\n  function startMySegmentsSyncTasks() {\n    forOwn(mySegmentsSyncTasks, function (mySegmentsSyncTask) {\n      mySegmentsSyncTask.start();\n    });\n  }\n  function stopMySegmentsSyncTasks() {\n    forOwn(mySegmentsSyncTasks, function (mySegmentsSyncTask) {\n      if (mySegmentsSyncTask.isRunning()) mySegmentsSyncTask.stop();\n    });\n  }\n  // smart pausing\n  readiness.splits.on(SDK_SPLITS_ARRIVED, function () {\n    if (!splitsSyncTask.isRunning()) return; // noop if not doing polling\n    var splitsHaveSegments = storage.splits.usesSegments();\n    if (splitsHaveSegments !== mySegmentsSyncTask.isRunning()) {\n      log.info(POLLING_SMART_PAUSING, [splitsHaveSegments ? 'ON' : 'OFF']);\n      if (splitsHaveSegments) {\n        startMySegmentsSyncTasks();\n      } else {\n        stopMySegmentsSyncTasks();\n      }\n    }\n  });\n  function add(matchingKey, readiness, storage) {\n    var mySegmentsSyncTask = mySegmentsSyncTaskFactory(splitApi.fetchMySegments, storage, readiness, settings, matchingKey);\n    // smart ready\n    function smartReady() {\n      if (!readiness.isReady() && !storage.splits.usesSegments()) readiness.segments.emit(SDK_SEGMENTS_ARRIVED);\n    }\n    if (!storage.splits.usesSegments()) setTimeout(smartReady, 0);else readiness.splits.once(SDK_SPLITS_ARRIVED, smartReady);\n    mySegmentsSyncTasks[matchingKey] = mySegmentsSyncTask;\n    return mySegmentsSyncTask;\n  }\n  return {\n    splitsSyncTask: splitsSyncTask,\n    segmentsSyncTask: mySegmentsSyncTask,\n    // Start periodic fetching (polling)\n    start: function () {\n      log.info(POLLING_START);\n      splitsSyncTask.start();\n      if (storage.splits.usesSegments()) startMySegmentsSyncTasks();\n    },\n    // Stop periodic fetching (polling)\n    stop: function () {\n      log.info(POLLING_STOP);\n      if (splitsSyncTask.isRunning()) splitsSyncTask.stop();\n      stopMySegmentsSyncTasks();\n    },\n    // Used by SyncManager to know if running in polling mode.\n    isRunning: splitsSyncTask.isRunning,\n    // fetch splits and segments\n    syncAll: function () {\n      var promises = [splitsSyncTask.execute()];\n      forOwn(mySegmentsSyncTasks, function (mySegmentsSyncTask) {\n        promises.push(mySegmentsSyncTask.execute());\n      });\n      return Promise.all(promises);\n    },\n    // Support for handling mySegments sync of multiple clients\n    add: add,\n    remove: function (matchingKey) {\n      delete mySegmentsSyncTasks[matchingKey];\n    },\n    get: function (matchingKey) {\n      return mySegmentsSyncTasks[matchingKey];\n    }\n  };\n}","map":{"version":3,"names":["forOwn","mySegmentsSyncTaskFactory","splitsSyncTaskFactory","getMatching","SDK_SPLITS_ARRIVED","SDK_SEGMENTS_ARRIVED","POLLING_SMART_PAUSING","POLLING_START","POLLING_STOP","pollingManagerCSFactory","params","splitApi","storage","readiness","settings","log","splitsSyncTask","fetchSplitChanges","mySegmentsSyncTasks","matchingKey","core","key","mySegmentsSyncTask","add","startMySegmentsSyncTasks","start","stopMySegmentsSyncTasks","isRunning","stop","splits","on","splitsHaveSegments","usesSegments","info","fetchMySegments","smartReady","isReady","segments","emit","setTimeout","once","segmentsSyncTask","syncAll","promises","execute","push","Promise","all","remove","get"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/polling/pollingManagerCS.js"],"sourcesContent":["import { forOwn } from '../../utils/lang';\nimport { mySegmentsSyncTaskFactory } from './syncTasks/mySegmentsSyncTask';\nimport { splitsSyncTaskFactory } from './syncTasks/splitsSyncTask';\nimport { getMatching } from '../../utils/key';\nimport { SDK_SPLITS_ARRIVED, SDK_SEGMENTS_ARRIVED } from '../../readiness/constants';\nimport { POLLING_SMART_PAUSING, POLLING_START, POLLING_STOP } from '../../logger/constants';\n/**\n * Expose start / stop mechanism for polling data from services.\n * For client-side API with multiple clients.\n */\nexport function pollingManagerCSFactory(params) {\n    var splitApi = params.splitApi, storage = params.storage, readiness = params.readiness, settings = params.settings;\n    var log = settings.log;\n    var splitsSyncTask = splitsSyncTaskFactory(splitApi.fetchSplitChanges, storage, readiness, settings, true);\n    // Map of matching keys to their corresponding MySegmentsSyncTask.\n    var mySegmentsSyncTasks = {};\n    var matchingKey = getMatching(settings.core.key);\n    var mySegmentsSyncTask = add(matchingKey, readiness, storage);\n    function startMySegmentsSyncTasks() {\n        forOwn(mySegmentsSyncTasks, function (mySegmentsSyncTask) {\n            mySegmentsSyncTask.start();\n        });\n    }\n    function stopMySegmentsSyncTasks() {\n        forOwn(mySegmentsSyncTasks, function (mySegmentsSyncTask) {\n            if (mySegmentsSyncTask.isRunning())\n                mySegmentsSyncTask.stop();\n        });\n    }\n    // smart pausing\n    readiness.splits.on(SDK_SPLITS_ARRIVED, function () {\n        if (!splitsSyncTask.isRunning())\n            return; // noop if not doing polling\n        var splitsHaveSegments = storage.splits.usesSegments();\n        if (splitsHaveSegments !== mySegmentsSyncTask.isRunning()) {\n            log.info(POLLING_SMART_PAUSING, [splitsHaveSegments ? 'ON' : 'OFF']);\n            if (splitsHaveSegments) {\n                startMySegmentsSyncTasks();\n            }\n            else {\n                stopMySegmentsSyncTasks();\n            }\n        }\n    });\n    function add(matchingKey, readiness, storage) {\n        var mySegmentsSyncTask = mySegmentsSyncTaskFactory(splitApi.fetchMySegments, storage, readiness, settings, matchingKey);\n        // smart ready\n        function smartReady() {\n            if (!readiness.isReady() && !storage.splits.usesSegments())\n                readiness.segments.emit(SDK_SEGMENTS_ARRIVED);\n        }\n        if (!storage.splits.usesSegments())\n            setTimeout(smartReady, 0);\n        else\n            readiness.splits.once(SDK_SPLITS_ARRIVED, smartReady);\n        mySegmentsSyncTasks[matchingKey] = mySegmentsSyncTask;\n        return mySegmentsSyncTask;\n    }\n    return {\n        splitsSyncTask: splitsSyncTask,\n        segmentsSyncTask: mySegmentsSyncTask,\n        // Start periodic fetching (polling)\n        start: function () {\n            log.info(POLLING_START);\n            splitsSyncTask.start();\n            if (storage.splits.usesSegments())\n                startMySegmentsSyncTasks();\n        },\n        // Stop periodic fetching (polling)\n        stop: function () {\n            log.info(POLLING_STOP);\n            if (splitsSyncTask.isRunning())\n                splitsSyncTask.stop();\n            stopMySegmentsSyncTasks();\n        },\n        // Used by SyncManager to know if running in polling mode.\n        isRunning: splitsSyncTask.isRunning,\n        // fetch splits and segments\n        syncAll: function () {\n            var promises = [splitsSyncTask.execute()];\n            forOwn(mySegmentsSyncTasks, function (mySegmentsSyncTask) {\n                promises.push(mySegmentsSyncTask.execute());\n            });\n            return Promise.all(promises);\n        },\n        // Support for handling mySegments sync of multiple clients\n        add: add,\n        remove: function (matchingKey) {\n            delete mySegmentsSyncTasks[matchingKey];\n        },\n        get: function (matchingKey) {\n            return mySegmentsSyncTasks[matchingKey];\n        }\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}