{"ast":null,"code":"import { objectAssign } from '../../utils/lang/objectAssign';\nimport { Backoff } from '../../utils/Backoff';\nimport { SSEHandlerFactory } from './SSEHandler';\nimport { MySegmentsUpdateWorker } from './UpdateWorkers/MySegmentsUpdateWorker';\nimport { SegmentsUpdateWorker } from './UpdateWorkers/SegmentsUpdateWorker';\nimport { SplitsUpdateWorker } from './UpdateWorkers/SplitsUpdateWorker';\nimport { authenticateFactory, hashUserKey } from './AuthClient';\nimport { forOwn } from '../../utils/lang';\nimport { SSEClient } from './SSEClient';\nimport { getMatching } from '../../utils/key';\nimport { MY_SEGMENTS_UPDATE, MY_SEGMENTS_UPDATE_V2, PUSH_NONRETRYABLE_ERROR, PUSH_SUBSYSTEM_DOWN, SECONDS_BEFORE_EXPIRATION, SEGMENT_UPDATE, SPLIT_KILL, SPLIT_UPDATE, PUSH_RETRYABLE_ERROR, PUSH_SUBSYSTEM_UP, ControlType } from './constants';\nimport { STREAMING_FALLBACK, STREAMING_REFRESH_TOKEN, STREAMING_CONNECTING, STREAMING_DISABLED, ERROR_STREAMING_AUTH, STREAMING_DISCONNECTING, STREAMING_RECONNECT, STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2 } from '../../logger/constants';\nimport { UpdateStrategy } from './SSEHandler/types';\nimport { isInBitmap, parseBitmap, parseKeyList } from './mySegmentsV2utils';\nimport { _Set } from '../../utils/lang/sets';\nimport { hash64 } from '../../utils/murmur3/murmur3_64';\nimport { TOKEN_REFRESH, AUTH_REJECTION } from '../../utils/constants';\n/**\n * PushManager factory:\n * - for server-side if key is not provided in settings.\n * - for client-side, with support for multiple clients, if key is provided in settings\n */\nexport function pushManagerFactory(params, pollingManager) {\n  var settings = params.settings,\n    storage = params.storage,\n    splitApi = params.splitApi,\n    readiness = params.readiness,\n    platform = params.platform,\n    telemetryTracker = params.telemetryTracker;\n  // `userKey` is the matching key of main client in client-side SDK.\n  // It can be used to check if running on client-side or server-side SDK.\n  var userKey = settings.core.key ? getMatching(settings.core.key) : undefined;\n  var log = settings.log;\n  var sseClient;\n  try {\n    // `useHeaders` false for client-side, even if the platform EventSource supports headers (e.g., React Native).\n    sseClient = new SSEClient(settings, userKey ? false : true, platform.getEventSource);\n  } catch (e) {\n    log.warn(STREAMING_FALLBACK, [e]);\n    return;\n  }\n  var authenticate = authenticateFactory(splitApi.fetchAuth);\n  // init feedback loop\n  var pushEmitter = new platform.EventEmitter();\n  var sseHandler = SSEHandlerFactory(log, pushEmitter, telemetryTracker);\n  sseClient.setEventHandler(sseHandler);\n  // init workers\n  // MySegmentsUpdateWorker (client-side) are initiated in `add` method\n  var segmentsUpdateWorker = userKey ? undefined : new SegmentsUpdateWorker(pollingManager.segmentsSyncTask, storage.segments);\n  // For server-side we pass the segmentsSyncTask, used by SplitsUpdateWorker to fetch new segments\n  var splitsUpdateWorker = new SplitsUpdateWorker(storage.splits, pollingManager.splitsSyncTask, readiness.splits, userKey ? undefined : pollingManager.segmentsSyncTask);\n  // [Only for client-side] map of hashes to user keys, to dispatch MY_SEGMENTS_UPDATE events to the corresponding MySegmentsUpdateWorker\n  var userKeyHashes = {};\n  // [Only for client-side] map of user keys to their corresponding hash64 and MySegmentsUpdateWorkers.\n  // Hash64 is used to process MY_SEGMENTS_UPDATE_V2 events and dispatch actions to the corresponding MySegmentsUpdateWorker.\n  var clients = {};\n  // [Only for client-side] variable to flag that a new client was added. It is needed to reconnect streaming.\n  var connectForNewClient = false;\n  // flag that indicates if `stop/disconnectPush` was called, either by the SyncManager, when the client is destroyed, or due to a PUSH_NONRETRYABLE_ERROR error.\n  // It is used to halt the `connectPush` process if it was in progress.\n  var disconnected;\n  // flag that indicates a PUSH_NONRETRYABLE_ERROR, condition with which starting pushManager again is ignored.\n  // true if STREAMING_DISABLED control event, or 'pushEnabled: false', or non-recoverable SSE or Auth errors.\n  var disabled; // `disabled` implies `disconnected === true`\n  /** PushManager functions related to initialization */\n  var connectPushRetryBackoff = new Backoff(connectPush, settings.scheduler.pushRetryBackoffBase);\n  var timeoutIdTokenRefresh;\n  var timeoutIdSseOpen;\n  function scheduleTokenRefreshAndSse(authData) {\n    // clear scheduled tasks if exist\n    if (timeoutIdTokenRefresh) clearTimeout(timeoutIdTokenRefresh);\n    if (timeoutIdSseOpen) clearTimeout(timeoutIdSseOpen);\n    // Set token refresh 10 minutes before `expirationTime - issuedAt`\n    var decodedToken = authData.decodedToken;\n    var refreshTokenDelay = decodedToken.exp - decodedToken.iat - SECONDS_BEFORE_EXPIRATION;\n    // Default connDelay of 60 secs\n    var connDelay = typeof authData.connDelay === 'number' && authData.connDelay >= 0 ? authData.connDelay : 60;\n    log.info(STREAMING_REFRESH_TOKEN, [refreshTokenDelay, connDelay]);\n    timeoutIdTokenRefresh = setTimeout(connectPush, refreshTokenDelay * 1000);\n    timeoutIdSseOpen = setTimeout(function () {\n      // halt if disconnected\n      if (disconnected) return;\n      sseClient.open(authData);\n    }, connDelay * 1000);\n    telemetryTracker.streamingEvent(TOKEN_REFRESH, decodedToken.exp);\n  }\n  function connectPush() {\n    // Guard condition in case `stop/disconnectPush` has been called (e.g., calling SDK destroy, or app signal close/background)\n    if (disconnected) return;\n    // @TODO distinguish log for 'Connecting' (1st time) and 'Re-connecting'\n    log.info(STREAMING_CONNECTING);\n    disconnected = false;\n    var userKeys = userKey ? Object.keys(clients) : undefined;\n    authenticate(userKeys).then(function (authData) {\n      if (disconnected) return;\n      // 'pushEnabled: false' is handled as a PUSH_NONRETRYABLE_ERROR instead of PUSH_SUBSYSTEM_DOWN, in order to\n      // close the sseClient in case the org has been bloqued while the instance was connected to streaming\n      if (!authData.pushEnabled) {\n        log.info(STREAMING_DISABLED);\n        pushEmitter.emit(PUSH_NONRETRYABLE_ERROR);\n        return;\n      }\n      // [Only for client-side] don't open SSE connection if a new shared client was added, since it means that a new authentication is taking place\n      if (userKeys && userKeys.length < Object.keys(clients).length) return;\n      // Schedule SSE connection and refresh token\n      scheduleTokenRefreshAndSse(authData);\n    }).catch(function (error) {\n      if (disconnected) return;\n      log.error(ERROR_STREAMING_AUTH, [error.message]);\n      // Handle 4XX HTTP errors: 401 (invalid API Key) or 400 (using incorrect API Key, i.e., client-side API Key on server-side)\n      if (error.statusCode >= 400 && error.statusCode < 500) {\n        telemetryTracker.streamingEvent(AUTH_REJECTION);\n        pushEmitter.emit(PUSH_NONRETRYABLE_ERROR);\n        return;\n      }\n      // Handle other HTTP and network errors as recoverable errors\n      pushEmitter.emit(PUSH_RETRYABLE_ERROR);\n    });\n  }\n  // close SSE connection and cancel scheduled tasks\n  function disconnectPush() {\n    // Halt disconnecting, just to avoid redundant logs if called multiple times\n    if (disconnected) return;\n    disconnected = true;\n    sseClient.close();\n    log.info(STREAMING_DISCONNECTING);\n    if (timeoutIdTokenRefresh) clearTimeout(timeoutIdTokenRefresh);\n    if (timeoutIdSseOpen) clearTimeout(timeoutIdSseOpen);\n    connectPushRetryBackoff.reset();\n    stopWorkers();\n  }\n  // cancel scheduled fetch retries of Splits, Segments, and MySegments Update Workers\n  function stopWorkers() {\n    splitsUpdateWorker.backoff.reset();\n    if (userKey) forOwn(clients, function (_a) {\n      var worker = _a.worker;\n      return worker.backoff.reset();\n    });else segmentsUpdateWorker.backoff.reset();\n  }\n  pushEmitter.on(PUSH_SUBSYSTEM_DOWN, stopWorkers);\n  // Only required when streaming connects after a PUSH_RETRYABLE_ERROR.\n  // Otherwise it is unnecessary (e.g, STREAMING_RESUMED).\n  pushEmitter.on(PUSH_SUBSYSTEM_UP, function () {\n    connectPushRetryBackoff.reset();\n    stopWorkers();\n  });\n  /** Fallback to polling without retry due to: STREAMING_DISABLED control event, or 'pushEnabled: false', or non-recoverable SSE and Authentication errors */\n  pushEmitter.on(PUSH_NONRETRYABLE_ERROR, function handleNonRetryableError() {\n    disabled = true;\n    // Note: `stopWorkers` is been called twice, but it is not harmful\n    disconnectPush();\n    pushEmitter.emit(PUSH_SUBSYSTEM_DOWN); // no harm if polling already\n  });\n  /** Fallback to polling with retry due to recoverable SSE and Authentication errors */\n  pushEmitter.on(PUSH_RETRYABLE_ERROR, function handleRetryableError() {\n    // SSE connection is closed to avoid repeated errors due to retries\n    sseClient.close();\n    // retry streaming reconnect with backoff algorithm\n    var delayInMillis = connectPushRetryBackoff.scheduleCall();\n    log.info(STREAMING_RECONNECT, [delayInMillis / 1000]);\n    pushEmitter.emit(PUSH_SUBSYSTEM_DOWN); // no harm if polling already\n  });\n  /** STREAMING_RESET notification. Unlike a PUSH_RETRYABLE_ERROR, it doesn't emit PUSH_SUBSYSTEM_DOWN to fallback polling */\n  pushEmitter.on(ControlType.STREAMING_RESET, function handleStreamingReset() {\n    if (disconnected) return; // should never happen\n    // Minimum required clean-up.\n    // `disconnectPush` cannot be called because it sets `disconnected` and thus `connectPush` will not execute\n    if (timeoutIdTokenRefresh) clearTimeout(timeoutIdTokenRefresh);\n    connectPush();\n  });\n  /** Functions related to synchronization (Queues and Workers in the spec) */\n  pushEmitter.on(SPLIT_KILL, splitsUpdateWorker.killSplit);\n  pushEmitter.on(SPLIT_UPDATE, splitsUpdateWorker.put);\n  if (userKey) {\n    pushEmitter.on(MY_SEGMENTS_UPDATE, function handleMySegmentsUpdate(parsedData, channel) {\n      var userKeyHash = channel.split('_')[2];\n      var userKey = userKeyHashes[userKeyHash];\n      if (userKey && clients[userKey]) {\n        // check existence since it can be undefined if client has been destroyed\n        clients[userKey].worker.put(parsedData.changeNumber, parsedData.includesPayload ? parsedData.segmentList ? parsedData.segmentList : [] : undefined);\n      }\n    });\n    pushEmitter.on(MY_SEGMENTS_UPDATE_V2, function handleMySegmentsUpdate(parsedData) {\n      switch (parsedData.u) {\n        case UpdateStrategy.BoundedFetchRequest:\n          {\n            var bitmap_1;\n            try {\n              bitmap_1 = parseBitmap(parsedData.d, parsedData.c);\n            } catch (e) {\n              log.warn(STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2, ['BoundedFetchRequest', e]);\n              break;\n            }\n            forOwn(clients, function (_a) {\n              var hash64 = _a.hash64,\n                worker = _a.worker;\n              if (isInBitmap(bitmap_1, hash64.hex)) {\n                worker.put(parsedData.changeNumber); // fetch mySegments\n              }\n            });\n\n            return;\n          }\n        case UpdateStrategy.KeyList:\n          {\n            var keyList = void 0,\n              added_1,\n              removed_1;\n            try {\n              keyList = parseKeyList(parsedData.d, parsedData.c);\n              added_1 = new _Set(keyList.a);\n              removed_1 = new _Set(keyList.r);\n            } catch (e) {\n              log.warn(STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2, ['KeyList', e]);\n              break;\n            }\n            forOwn(clients, function (_a) {\n              var hash64 = _a.hash64,\n                worker = _a.worker;\n              var add = added_1.has(hash64.dec) ? true : removed_1.has(hash64.dec) ? false : undefined;\n              if (add !== undefined) {\n                worker.put(parsedData.changeNumber, {\n                  name: parsedData.segmentName,\n                  add: add\n                });\n              }\n            });\n            return;\n          }\n        case UpdateStrategy.SegmentRemoval:\n          if (!parsedData.segmentName) {\n            log.warn(STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2, ['SegmentRemoval', 'No segment name was provided']);\n            break;\n          }\n          forOwn(clients, function (_a) {\n            var worker = _a.worker;\n            return worker.put(parsedData.changeNumber, {\n              name: parsedData.segmentName,\n              add: false\n            });\n          });\n          return;\n      }\n      // `UpdateStrategy.UnboundedFetchRequest` and fallbacks of other cases\n      forOwn(clients, function (_a) {\n        var worker = _a.worker;\n        worker.put(parsedData.changeNumber);\n      });\n    });\n  } else {\n    pushEmitter.on(SEGMENT_UPDATE, segmentsUpdateWorker.put);\n  }\n  return objectAssign(\n  // Expose Event Emitter functionality and Event constants\n  Object.create(pushEmitter), {\n    // Stop/pause push mode.\n    // It doesn't emit events. Neither PUSH_SUBSYSTEM_DOWN to start polling.\n    stop: function () {\n      disconnectPush(); // `handleNonRetryableError` cannot be used as `stop`, because it emits PUSH_SUBSYSTEM_DOWN event, which starts polling.\n      if (userKey) this.remove(userKey); // Necessary to properly resume streaming in client-side (e.g., RN SDK transition to foreground).\n    },\n\n    // Start/resume push mode.\n    // It eventually emits PUSH_SUBSYSTEM_DOWN, that starts polling, or PUSH_SUBSYSTEM_UP, that executes a syncAll\n    start: function () {\n      // Guard condition to avoid calling `connectPush` again if the `start` method is called multiple times or if push has been disabled.\n      if (disabled || disconnected === false) return;\n      disconnected = false;\n      if (userKey) this.add(userKey, pollingManager.segmentsSyncTask); // client-side\n      else setTimeout(connectPush); // server-side runs in next cycle as in client-side, for consistency with client-side\n    },\n\n    // true/false if start or stop was called last respectively\n    isRunning: function () {\n      return disconnected === false;\n    },\n    // [Only for client-side]\n    add: function (userKey, mySegmentsSyncTask) {\n      var hash = hashUserKey(userKey);\n      if (!userKeyHashes[hash]) {\n        userKeyHashes[hash] = userKey;\n        clients[userKey] = {\n          hash64: hash64(userKey),\n          worker: new MySegmentsUpdateWorker(mySegmentsSyncTask)\n        };\n        connectForNewClient = true; // we must reconnect on start, to listen the channel for the new user key\n        // Reconnects in case of a new client.\n        // Run in next event-loop cycle to save authentication calls\n        // in case multiple clients are created in the current cycle.\n        setTimeout(function checkForReconnect() {\n          if (connectForNewClient) {\n            connectForNewClient = false;\n            connectPush();\n          }\n        }, 0);\n      }\n    },\n    // [Only for client-side]\n    remove: function (userKey) {\n      var hash = hashUserKey(userKey);\n      delete userKeyHashes[hash];\n      delete clients[userKey];\n    }\n  });\n}","map":{"version":3,"names":["objectAssign","Backoff","SSEHandlerFactory","MySegmentsUpdateWorker","SegmentsUpdateWorker","SplitsUpdateWorker","authenticateFactory","hashUserKey","forOwn","SSEClient","getMatching","MY_SEGMENTS_UPDATE","MY_SEGMENTS_UPDATE_V2","PUSH_NONRETRYABLE_ERROR","PUSH_SUBSYSTEM_DOWN","SECONDS_BEFORE_EXPIRATION","SEGMENT_UPDATE","SPLIT_KILL","SPLIT_UPDATE","PUSH_RETRYABLE_ERROR","PUSH_SUBSYSTEM_UP","ControlType","STREAMING_FALLBACK","STREAMING_REFRESH_TOKEN","STREAMING_CONNECTING","STREAMING_DISABLED","ERROR_STREAMING_AUTH","STREAMING_DISCONNECTING","STREAMING_RECONNECT","STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2","UpdateStrategy","isInBitmap","parseBitmap","parseKeyList","_Set","hash64","TOKEN_REFRESH","AUTH_REJECTION","pushManagerFactory","params","pollingManager","settings","storage","splitApi","readiness","platform","telemetryTracker","userKey","core","key","undefined","log","sseClient","getEventSource","e","warn","authenticate","fetchAuth","pushEmitter","EventEmitter","sseHandler","setEventHandler","segmentsUpdateWorker","segmentsSyncTask","segments","splitsUpdateWorker","splits","splitsSyncTask","userKeyHashes","clients","connectForNewClient","disconnected","disabled","connectPushRetryBackoff","connectPush","scheduler","pushRetryBackoffBase","timeoutIdTokenRefresh","timeoutIdSseOpen","scheduleTokenRefreshAndSse","authData","clearTimeout","decodedToken","refreshTokenDelay","exp","iat","connDelay","info","setTimeout","open","streamingEvent","userKeys","Object","keys","then","pushEnabled","emit","length","catch","error","message","statusCode","disconnectPush","close","reset","stopWorkers","backoff","_a","worker","on","handleNonRetryableError","handleRetryableError","delayInMillis","scheduleCall","STREAMING_RESET","handleStreamingReset","killSplit","put","handleMySegmentsUpdate","parsedData","channel","userKeyHash","split","changeNumber","includesPayload","segmentList","u","BoundedFetchRequest","bitmap_1","d","c","hex","KeyList","keyList","added_1","removed_1","a","r","add","has","dec","name","segmentName","SegmentRemoval","create","stop","remove","start","isRunning","mySegmentsSyncTask","hash","checkForReconnect"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/streaming/pushManager.js"],"sourcesContent":["import { objectAssign } from '../../utils/lang/objectAssign';\nimport { Backoff } from '../../utils/Backoff';\nimport { SSEHandlerFactory } from './SSEHandler';\nimport { MySegmentsUpdateWorker } from './UpdateWorkers/MySegmentsUpdateWorker';\nimport { SegmentsUpdateWorker } from './UpdateWorkers/SegmentsUpdateWorker';\nimport { SplitsUpdateWorker } from './UpdateWorkers/SplitsUpdateWorker';\nimport { authenticateFactory, hashUserKey } from './AuthClient';\nimport { forOwn } from '../../utils/lang';\nimport { SSEClient } from './SSEClient';\nimport { getMatching } from '../../utils/key';\nimport { MY_SEGMENTS_UPDATE, MY_SEGMENTS_UPDATE_V2, PUSH_NONRETRYABLE_ERROR, PUSH_SUBSYSTEM_DOWN, SECONDS_BEFORE_EXPIRATION, SEGMENT_UPDATE, SPLIT_KILL, SPLIT_UPDATE, PUSH_RETRYABLE_ERROR, PUSH_SUBSYSTEM_UP, ControlType } from './constants';\nimport { STREAMING_FALLBACK, STREAMING_REFRESH_TOKEN, STREAMING_CONNECTING, STREAMING_DISABLED, ERROR_STREAMING_AUTH, STREAMING_DISCONNECTING, STREAMING_RECONNECT, STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2 } from '../../logger/constants';\nimport { UpdateStrategy } from './SSEHandler/types';\nimport { isInBitmap, parseBitmap, parseKeyList } from './mySegmentsV2utils';\nimport { _Set } from '../../utils/lang/sets';\nimport { hash64 } from '../../utils/murmur3/murmur3_64';\nimport { TOKEN_REFRESH, AUTH_REJECTION } from '../../utils/constants';\n/**\n * PushManager factory:\n * - for server-side if key is not provided in settings.\n * - for client-side, with support for multiple clients, if key is provided in settings\n */\nexport function pushManagerFactory(params, pollingManager) {\n    var settings = params.settings, storage = params.storage, splitApi = params.splitApi, readiness = params.readiness, platform = params.platform, telemetryTracker = params.telemetryTracker;\n    // `userKey` is the matching key of main client in client-side SDK.\n    // It can be used to check if running on client-side or server-side SDK.\n    var userKey = settings.core.key ? getMatching(settings.core.key) : undefined;\n    var log = settings.log;\n    var sseClient;\n    try {\n        // `useHeaders` false for client-side, even if the platform EventSource supports headers (e.g., React Native).\n        sseClient = new SSEClient(settings, userKey ? false : true, platform.getEventSource);\n    }\n    catch (e) {\n        log.warn(STREAMING_FALLBACK, [e]);\n        return;\n    }\n    var authenticate = authenticateFactory(splitApi.fetchAuth);\n    // init feedback loop\n    var pushEmitter = new platform.EventEmitter();\n    var sseHandler = SSEHandlerFactory(log, pushEmitter, telemetryTracker);\n    sseClient.setEventHandler(sseHandler);\n    // init workers\n    // MySegmentsUpdateWorker (client-side) are initiated in `add` method\n    var segmentsUpdateWorker = userKey ? undefined : new SegmentsUpdateWorker(pollingManager.segmentsSyncTask, storage.segments);\n    // For server-side we pass the segmentsSyncTask, used by SplitsUpdateWorker to fetch new segments\n    var splitsUpdateWorker = new SplitsUpdateWorker(storage.splits, pollingManager.splitsSyncTask, readiness.splits, userKey ? undefined : pollingManager.segmentsSyncTask);\n    // [Only for client-side] map of hashes to user keys, to dispatch MY_SEGMENTS_UPDATE events to the corresponding MySegmentsUpdateWorker\n    var userKeyHashes = {};\n    // [Only for client-side] map of user keys to their corresponding hash64 and MySegmentsUpdateWorkers.\n    // Hash64 is used to process MY_SEGMENTS_UPDATE_V2 events and dispatch actions to the corresponding MySegmentsUpdateWorker.\n    var clients = {};\n    // [Only for client-side] variable to flag that a new client was added. It is needed to reconnect streaming.\n    var connectForNewClient = false;\n    // flag that indicates if `stop/disconnectPush` was called, either by the SyncManager, when the client is destroyed, or due to a PUSH_NONRETRYABLE_ERROR error.\n    // It is used to halt the `connectPush` process if it was in progress.\n    var disconnected;\n    // flag that indicates a PUSH_NONRETRYABLE_ERROR, condition with which starting pushManager again is ignored.\n    // true if STREAMING_DISABLED control event, or 'pushEnabled: false', or non-recoverable SSE or Auth errors.\n    var disabled; // `disabled` implies `disconnected === true`\n    /** PushManager functions related to initialization */\n    var connectPushRetryBackoff = new Backoff(connectPush, settings.scheduler.pushRetryBackoffBase);\n    var timeoutIdTokenRefresh;\n    var timeoutIdSseOpen;\n    function scheduleTokenRefreshAndSse(authData) {\n        // clear scheduled tasks if exist\n        if (timeoutIdTokenRefresh)\n            clearTimeout(timeoutIdTokenRefresh);\n        if (timeoutIdSseOpen)\n            clearTimeout(timeoutIdSseOpen);\n        // Set token refresh 10 minutes before `expirationTime - issuedAt`\n        var decodedToken = authData.decodedToken;\n        var refreshTokenDelay = decodedToken.exp - decodedToken.iat - SECONDS_BEFORE_EXPIRATION;\n        // Default connDelay of 60 secs\n        var connDelay = typeof authData.connDelay === 'number' && authData.connDelay >= 0 ? authData.connDelay : 60;\n        log.info(STREAMING_REFRESH_TOKEN, [refreshTokenDelay, connDelay]);\n        timeoutIdTokenRefresh = setTimeout(connectPush, refreshTokenDelay * 1000);\n        timeoutIdSseOpen = setTimeout(function () {\n            // halt if disconnected\n            if (disconnected)\n                return;\n            sseClient.open(authData);\n        }, connDelay * 1000);\n        telemetryTracker.streamingEvent(TOKEN_REFRESH, decodedToken.exp);\n    }\n    function connectPush() {\n        // Guard condition in case `stop/disconnectPush` has been called (e.g., calling SDK destroy, or app signal close/background)\n        if (disconnected)\n            return;\n        // @TODO distinguish log for 'Connecting' (1st time) and 'Re-connecting'\n        log.info(STREAMING_CONNECTING);\n        disconnected = false;\n        var userKeys = userKey ? Object.keys(clients) : undefined;\n        authenticate(userKeys).then(function (authData) {\n            if (disconnected)\n                return;\n            // 'pushEnabled: false' is handled as a PUSH_NONRETRYABLE_ERROR instead of PUSH_SUBSYSTEM_DOWN, in order to\n            // close the sseClient in case the org has been bloqued while the instance was connected to streaming\n            if (!authData.pushEnabled) {\n                log.info(STREAMING_DISABLED);\n                pushEmitter.emit(PUSH_NONRETRYABLE_ERROR);\n                return;\n            }\n            // [Only for client-side] don't open SSE connection if a new shared client was added, since it means that a new authentication is taking place\n            if (userKeys && userKeys.length < Object.keys(clients).length)\n                return;\n            // Schedule SSE connection and refresh token\n            scheduleTokenRefreshAndSse(authData);\n        }).catch(function (error) {\n            if (disconnected)\n                return;\n            log.error(ERROR_STREAMING_AUTH, [error.message]);\n            // Handle 4XX HTTP errors: 401 (invalid API Key) or 400 (using incorrect API Key, i.e., client-side API Key on server-side)\n            if (error.statusCode >= 400 && error.statusCode < 500) {\n                telemetryTracker.streamingEvent(AUTH_REJECTION);\n                pushEmitter.emit(PUSH_NONRETRYABLE_ERROR);\n                return;\n            }\n            // Handle other HTTP and network errors as recoverable errors\n            pushEmitter.emit(PUSH_RETRYABLE_ERROR);\n        });\n    }\n    // close SSE connection and cancel scheduled tasks\n    function disconnectPush() {\n        // Halt disconnecting, just to avoid redundant logs if called multiple times\n        if (disconnected)\n            return;\n        disconnected = true;\n        sseClient.close();\n        log.info(STREAMING_DISCONNECTING);\n        if (timeoutIdTokenRefresh)\n            clearTimeout(timeoutIdTokenRefresh);\n        if (timeoutIdSseOpen)\n            clearTimeout(timeoutIdSseOpen);\n        connectPushRetryBackoff.reset();\n        stopWorkers();\n    }\n    // cancel scheduled fetch retries of Splits, Segments, and MySegments Update Workers\n    function stopWorkers() {\n        splitsUpdateWorker.backoff.reset();\n        if (userKey)\n            forOwn(clients, function (_a) {\n                var worker = _a.worker;\n                return worker.backoff.reset();\n            });\n        else\n            segmentsUpdateWorker.backoff.reset();\n    }\n    pushEmitter.on(PUSH_SUBSYSTEM_DOWN, stopWorkers);\n    // Only required when streaming connects after a PUSH_RETRYABLE_ERROR.\n    // Otherwise it is unnecessary (e.g, STREAMING_RESUMED).\n    pushEmitter.on(PUSH_SUBSYSTEM_UP, function () {\n        connectPushRetryBackoff.reset();\n        stopWorkers();\n    });\n    /** Fallback to polling without retry due to: STREAMING_DISABLED control event, or 'pushEnabled: false', or non-recoverable SSE and Authentication errors */\n    pushEmitter.on(PUSH_NONRETRYABLE_ERROR, function handleNonRetryableError() {\n        disabled = true;\n        // Note: `stopWorkers` is been called twice, but it is not harmful\n        disconnectPush();\n        pushEmitter.emit(PUSH_SUBSYSTEM_DOWN); // no harm if polling already\n    });\n    /** Fallback to polling with retry due to recoverable SSE and Authentication errors */\n    pushEmitter.on(PUSH_RETRYABLE_ERROR, function handleRetryableError() {\n        // SSE connection is closed to avoid repeated errors due to retries\n        sseClient.close();\n        // retry streaming reconnect with backoff algorithm\n        var delayInMillis = connectPushRetryBackoff.scheduleCall();\n        log.info(STREAMING_RECONNECT, [delayInMillis / 1000]);\n        pushEmitter.emit(PUSH_SUBSYSTEM_DOWN); // no harm if polling already\n    });\n    /** STREAMING_RESET notification. Unlike a PUSH_RETRYABLE_ERROR, it doesn't emit PUSH_SUBSYSTEM_DOWN to fallback polling */\n    pushEmitter.on(ControlType.STREAMING_RESET, function handleStreamingReset() {\n        if (disconnected)\n            return; // should never happen\n        // Minimum required clean-up.\n        // `disconnectPush` cannot be called because it sets `disconnected` and thus `connectPush` will not execute\n        if (timeoutIdTokenRefresh)\n            clearTimeout(timeoutIdTokenRefresh);\n        connectPush();\n    });\n    /** Functions related to synchronization (Queues and Workers in the spec) */\n    pushEmitter.on(SPLIT_KILL, splitsUpdateWorker.killSplit);\n    pushEmitter.on(SPLIT_UPDATE, splitsUpdateWorker.put);\n    if (userKey) {\n        pushEmitter.on(MY_SEGMENTS_UPDATE, function handleMySegmentsUpdate(parsedData, channel) {\n            var userKeyHash = channel.split('_')[2];\n            var userKey = userKeyHashes[userKeyHash];\n            if (userKey && clients[userKey]) { // check existence since it can be undefined if client has been destroyed\n                clients[userKey].worker.put(parsedData.changeNumber, parsedData.includesPayload ? parsedData.segmentList ? parsedData.segmentList : [] : undefined);\n            }\n        });\n        pushEmitter.on(MY_SEGMENTS_UPDATE_V2, function handleMySegmentsUpdate(parsedData) {\n            switch (parsedData.u) {\n                case UpdateStrategy.BoundedFetchRequest: {\n                    var bitmap_1;\n                    try {\n                        bitmap_1 = parseBitmap(parsedData.d, parsedData.c);\n                    }\n                    catch (e) {\n                        log.warn(STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2, ['BoundedFetchRequest', e]);\n                        break;\n                    }\n                    forOwn(clients, function (_a) {\n                        var hash64 = _a.hash64, worker = _a.worker;\n                        if (isInBitmap(bitmap_1, hash64.hex)) {\n                            worker.put(parsedData.changeNumber); // fetch mySegments\n                        }\n                    });\n                    return;\n                }\n                case UpdateStrategy.KeyList: {\n                    var keyList = void 0, added_1, removed_1;\n                    try {\n                        keyList = parseKeyList(parsedData.d, parsedData.c);\n                        added_1 = new _Set(keyList.a);\n                        removed_1 = new _Set(keyList.r);\n                    }\n                    catch (e) {\n                        log.warn(STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2, ['KeyList', e]);\n                        break;\n                    }\n                    forOwn(clients, function (_a) {\n                        var hash64 = _a.hash64, worker = _a.worker;\n                        var add = added_1.has(hash64.dec) ? true : removed_1.has(hash64.dec) ? false : undefined;\n                        if (add !== undefined) {\n                            worker.put(parsedData.changeNumber, {\n                                name: parsedData.segmentName,\n                                add: add\n                            });\n                        }\n                    });\n                    return;\n                }\n                case UpdateStrategy.SegmentRemoval:\n                    if (!parsedData.segmentName) {\n                        log.warn(STREAMING_PARSING_MY_SEGMENTS_UPDATE_V2, ['SegmentRemoval', 'No segment name was provided']);\n                        break;\n                    }\n                    forOwn(clients, function (_a) {\n                        var worker = _a.worker;\n                        return worker.put(parsedData.changeNumber, {\n                            name: parsedData.segmentName,\n                            add: false\n                        });\n                    });\n                    return;\n            }\n            // `UpdateStrategy.UnboundedFetchRequest` and fallbacks of other cases\n            forOwn(clients, function (_a) {\n                var worker = _a.worker;\n                worker.put(parsedData.changeNumber);\n            });\n        });\n    }\n    else {\n        pushEmitter.on(SEGMENT_UPDATE, segmentsUpdateWorker.put);\n    }\n    return objectAssign(\n    // Expose Event Emitter functionality and Event constants\n    Object.create(pushEmitter), {\n        // Stop/pause push mode.\n        // It doesn't emit events. Neither PUSH_SUBSYSTEM_DOWN to start polling.\n        stop: function () {\n            disconnectPush(); // `handleNonRetryableError` cannot be used as `stop`, because it emits PUSH_SUBSYSTEM_DOWN event, which starts polling.\n            if (userKey)\n                this.remove(userKey); // Necessary to properly resume streaming in client-side (e.g., RN SDK transition to foreground).\n        },\n        // Start/resume push mode.\n        // It eventually emits PUSH_SUBSYSTEM_DOWN, that starts polling, or PUSH_SUBSYSTEM_UP, that executes a syncAll\n        start: function () {\n            // Guard condition to avoid calling `connectPush` again if the `start` method is called multiple times or if push has been disabled.\n            if (disabled || disconnected === false)\n                return;\n            disconnected = false;\n            if (userKey)\n                this.add(userKey, pollingManager.segmentsSyncTask); // client-side\n            else\n                setTimeout(connectPush); // server-side runs in next cycle as in client-side, for consistency with client-side\n        },\n        // true/false if start or stop was called last respectively\n        isRunning: function () {\n            return disconnected === false;\n        },\n        // [Only for client-side]\n        add: function (userKey, mySegmentsSyncTask) {\n            var hash = hashUserKey(userKey);\n            if (!userKeyHashes[hash]) {\n                userKeyHashes[hash] = userKey;\n                clients[userKey] = { hash64: hash64(userKey), worker: new MySegmentsUpdateWorker(mySegmentsSyncTask) };\n                connectForNewClient = true; // we must reconnect on start, to listen the channel for the new user key\n                // Reconnects in case of a new client.\n                // Run in next event-loop cycle to save authentication calls\n                // in case multiple clients are created in the current cycle.\n                setTimeout(function checkForReconnect() {\n                    if (connectForNewClient) {\n                        connectForNewClient = false;\n                        connectPush();\n                    }\n                }, 0);\n            }\n        },\n        // [Only for client-side]\n        remove: function (userKey) {\n            var hash = hashUserKey(userKey);\n            delete userKeyHashes[hash];\n            delete clients[userKey];\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}