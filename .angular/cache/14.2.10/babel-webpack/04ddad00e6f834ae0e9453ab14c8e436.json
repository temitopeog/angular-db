{"ast":null,"code":"import { algorithms } from '../../utils/decompress';\nimport { decodeFromBase64 } from '../../utils/base64';\nvar GZIP = 1;\nvar ZLIB = 2;\nfunction Uint8ArrayToString(myUint8Arr) {\n  return String.fromCharCode.apply(null, myUint8Arr);\n}\nfunction StringToUint8Array(myString) {\n  var charCodes = myString.split('').map(function (e) {\n    return e.charCodeAt(0);\n  });\n  return new Uint8Array(charCodes);\n}\n/**\n * Decode and decompress 'data' with 'compression' algorithm\n *\n * @param {string} data\n * @param {number} compression 1 GZIP, 2 ZLIB\n * @returns {Uint8Array}\n * @throws if data string cannot be decoded, decompressed or the provided compression value is invalid (not 1 or 2)\n */\nfunction decompress(data, compression) {\n  var compressData = decodeFromBase64(data);\n  var binData = StringToUint8Array(compressData);\n  if (typeof algorithms === 'string') throw new Error(algorithms);\n  if (compression === GZIP) return algorithms.gunzipSync(binData);\n  if (compression === ZLIB) return algorithms.unzlibSync(binData);\n  throw new Error(\"Invalid compression algorithm #\" + compression);\n}\n/**\n * Decode, decompress and parse the provided 'data' into a KeyList object\n *\n * @param {string} data\n * @param {number} compression\n * @returns {{a?: string[], r?: string[] }}\n * @throws if data string cannot be decoded, decompressed or parsed\n */\nexport function parseKeyList(data, compression) {\n  var binKeyList = decompress(data, compression);\n  var strKeyList = Uint8ArrayToString(binKeyList);\n  // replace numbers to strings, to avoid losing precision\n  return JSON.parse(strKeyList.replace(/\\d+/g, '\"$&\"'));\n}\n/**\n * Decode, decompress and parse the provided 'data' into a Bitmap object\n *\n * @param {string} data\n * @param {number} compression\n * @returns {Uint8Array}\n * @throws if data string cannot be decoded or decompressed\n */\nexport function parseBitmap(data, compression) {\n  return decompress(data, compression);\n}\n/**\n * Check if the 'bitmap' bit at 'hash64hex' position is 1\n *\n * @param {Uint8Array} bitmap\n * @param {string} hash64hex 16-chars string, representing a number in hexa\n * @returns {boolean}\n */\nexport function isInBitmap(bitmap, hash64hex) {\n  // using the lowest 32 bits as index, to avoid losing precision when converting to number\n  var index = parseInt(hash64hex.slice(8), 16) % (bitmap.length * 8);\n  var internal = Math.floor(index / 8);\n  var offset = index % 8;\n  return (bitmap[internal] & 1 << offset) > 0;\n}","map":{"version":3,"names":["algorithms","decodeFromBase64","GZIP","ZLIB","Uint8ArrayToString","myUint8Arr","String","fromCharCode","apply","StringToUint8Array","myString","charCodes","split","map","e","charCodeAt","Uint8Array","decompress","data","compression","compressData","binData","Error","gunzipSync","unzlibSync","parseKeyList","binKeyList","strKeyList","JSON","parse","replace","parseBitmap","isInBitmap","bitmap","hash64hex","index","parseInt","slice","length","internal","Math","floor","offset"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/streaming/mySegmentsV2utils.js"],"sourcesContent":["import { algorithms } from '../../utils/decompress';\nimport { decodeFromBase64 } from '../../utils/base64';\nvar GZIP = 1;\nvar ZLIB = 2;\nfunction Uint8ArrayToString(myUint8Arr) {\n    return String.fromCharCode.apply(null, myUint8Arr);\n}\nfunction StringToUint8Array(myString) {\n    var charCodes = myString.split('').map(function (e) { return e.charCodeAt(0); });\n    return new Uint8Array(charCodes);\n}\n/**\n * Decode and decompress 'data' with 'compression' algorithm\n *\n * @param {string} data\n * @param {number} compression 1 GZIP, 2 ZLIB\n * @returns {Uint8Array}\n * @throws if data string cannot be decoded, decompressed or the provided compression value is invalid (not 1 or 2)\n */\nfunction decompress(data, compression) {\n    var compressData = decodeFromBase64(data);\n    var binData = StringToUint8Array(compressData);\n    if (typeof algorithms === 'string')\n        throw new Error(algorithms);\n    if (compression === GZIP)\n        return algorithms.gunzipSync(binData);\n    if (compression === ZLIB)\n        return algorithms.unzlibSync(binData);\n    throw new Error(\"Invalid compression algorithm #\" + compression);\n}\n/**\n * Decode, decompress and parse the provided 'data' into a KeyList object\n *\n * @param {string} data\n * @param {number} compression\n * @returns {{a?: string[], r?: string[] }}\n * @throws if data string cannot be decoded, decompressed or parsed\n */\nexport function parseKeyList(data, compression) {\n    var binKeyList = decompress(data, compression);\n    var strKeyList = Uint8ArrayToString(binKeyList);\n    // replace numbers to strings, to avoid losing precision\n    return JSON.parse(strKeyList.replace(/\\d+/g, '\"$&\"'));\n}\n/**\n * Decode, decompress and parse the provided 'data' into a Bitmap object\n *\n * @param {string} data\n * @param {number} compression\n * @returns {Uint8Array}\n * @throws if data string cannot be decoded or decompressed\n */\nexport function parseBitmap(data, compression) {\n    return decompress(data, compression);\n}\n/**\n * Check if the 'bitmap' bit at 'hash64hex' position is 1\n *\n * @param {Uint8Array} bitmap\n * @param {string} hash64hex 16-chars string, representing a number in hexa\n * @returns {boolean}\n */\nexport function isInBitmap(bitmap, hash64hex) {\n    // using the lowest 32 bits as index, to avoid losing precision when converting to number\n    var index = parseInt(hash64hex.slice(8), 16) % (bitmap.length * 8);\n    var internal = Math.floor(index / 8);\n    var offset = index % 8;\n    return (bitmap[internal] & 1 << offset) > 0;\n}\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,wBAAwB;AACnD,SAASC,gBAAgB,QAAQ,oBAAoB;AACrD,IAAIC,IAAI,GAAG,CAAC;AACZ,IAAIC,IAAI,GAAG,CAAC;AACZ,SAASC,kBAAkB,CAACC,UAAU,EAAE;EACpC,OAAOC,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,EAAEH,UAAU,CAAC;AACtD;AACA,SAASI,kBAAkB,CAACC,QAAQ,EAAE;EAClC,IAAIC,SAAS,GAAGD,QAAQ,CAACE,KAAK,CAAC,EAAE,CAAC,CAACC,GAAG,CAAC,UAAUC,CAAC,EAAE;IAAE,OAAOA,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC;EAAE,CAAC,CAAC;EAChF,OAAO,IAAIC,UAAU,CAACL,SAAS,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,UAAU,CAACC,IAAI,EAAEC,WAAW,EAAE;EACnC,IAAIC,YAAY,GAAGnB,gBAAgB,CAACiB,IAAI,CAAC;EACzC,IAAIG,OAAO,GAAGZ,kBAAkB,CAACW,YAAY,CAAC;EAC9C,IAAI,OAAOpB,UAAU,KAAK,QAAQ,EAC9B,MAAM,IAAIsB,KAAK,CAACtB,UAAU,CAAC;EAC/B,IAAImB,WAAW,KAAKjB,IAAI,EACpB,OAAOF,UAAU,CAACuB,UAAU,CAACF,OAAO,CAAC;EACzC,IAAIF,WAAW,KAAKhB,IAAI,EACpB,OAAOH,UAAU,CAACwB,UAAU,CAACH,OAAO,CAAC;EACzC,MAAM,IAAIC,KAAK,CAAC,iCAAiC,GAAGH,WAAW,CAAC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,YAAY,CAACP,IAAI,EAAEC,WAAW,EAAE;EAC5C,IAAIO,UAAU,GAAGT,UAAU,CAACC,IAAI,EAAEC,WAAW,CAAC;EAC9C,IAAIQ,UAAU,GAAGvB,kBAAkB,CAACsB,UAAU,CAAC;EAC/C;EACA,OAAOE,IAAI,CAACC,KAAK,CAACF,UAAU,CAACG,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAW,CAACb,IAAI,EAAEC,WAAW,EAAE;EAC3C,OAAOF,UAAU,CAACC,IAAI,EAAEC,WAAW,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASa,UAAU,CAACC,MAAM,EAAEC,SAAS,EAAE;EAC1C;EACA,IAAIC,KAAK,GAAGC,QAAQ,CAACF,SAAS,CAACG,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAIJ,MAAM,CAACK,MAAM,GAAG,CAAC,CAAC;EAClE,IAAIC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACN,KAAK,GAAG,CAAC,CAAC;EACpC,IAAIO,MAAM,GAAGP,KAAK,GAAG,CAAC;EACtB,OAAO,CAACF,MAAM,CAACM,QAAQ,CAAC,GAAG,CAAC,IAAIG,MAAM,IAAI,CAAC;AAC/C"},"metadata":{},"sourceType":"module"}