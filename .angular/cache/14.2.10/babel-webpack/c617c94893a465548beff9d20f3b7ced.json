{"ast":null,"code":"import { Backoff } from '../../../utils/Backoff';\n/**\n * MySegmentsUpdateWorker class\n */\nvar MySegmentsUpdateWorker = /** @class */function () {\n  /**\n   * @param {Object} mySegmentsSyncTask task for syncing mySegments data\n   */\n  function MySegmentsUpdateWorker(mySegmentsSyncTask) {\n    this.mySegmentsSyncTask = mySegmentsSyncTask;\n    this.maxChangeNumber = 0; // keeps the maximum changeNumber among queued events\n    this.handleNewEvent = false;\n    this.segmentsData = undefined; // keeps the segmentsData (if included in notification payload) from the queued event with maximum changeNumber\n    this.currentChangeNumber = -1; // @TODO: remove once `/mySegments` endpoint provides the changeNumber\n    this.put = this.put.bind(this);\n    this.__handleMySegmentsUpdateCall = this.__handleMySegmentsUpdateCall.bind(this);\n    this.backoff = new Backoff(this.__handleMySegmentsUpdateCall);\n  }\n  // Private method\n  // Precondition: this.mySegmentsSyncTask.isSynchronizingMySegments === false\n  MySegmentsUpdateWorker.prototype.__handleMySegmentsUpdateCall = function () {\n    var _this = this;\n    if (this.maxChangeNumber > this.currentChangeNumber) {\n      this.handleNewEvent = false;\n      var currentMaxChangeNumber_1 = this.maxChangeNumber;\n      // fetch mySegments revalidating data if cached\n      this.mySegmentsSyncTask.execute(this.segmentsData, true).then(function (result) {\n        if (result !== false)\n          // Unlike `Splits|SegmentsUpdateWorker`, we cannot use `mySegmentsCache.getChangeNumber` since `/mySegments` endpoint doesn't provide this value.\n          _this.currentChangeNumber = Math.max(_this.currentChangeNumber, currentMaxChangeNumber_1); // use `currentMaxChangeNumber`, in case that `this.maxChangeNumber` was updated during fetch.\n        if (_this.handleNewEvent) {\n          _this.__handleMySegmentsUpdateCall();\n        } else {\n          _this.backoff.scheduleCall();\n        }\n      });\n    }\n  };\n  /**\n   * Invoked by NotificationProcessor on MY_SEGMENTS_UPDATE event\n   *\n   * @param {number} changeNumber change number of the MY_SEGMENTS_UPDATE notification\n   * @param {SegmentsData | undefined} segmentsData might be undefined\n   */\n  MySegmentsUpdateWorker.prototype.put = function (changeNumber, segmentsData) {\n    if (changeNumber <= this.currentChangeNumber || changeNumber <= this.maxChangeNumber) return;\n    this.maxChangeNumber = changeNumber;\n    this.handleNewEvent = true;\n    this.backoff.reset();\n    this.segmentsData = segmentsData;\n    if (this.mySegmentsSyncTask.isExecuting()) return;\n    this.__handleMySegmentsUpdateCall();\n  };\n  return MySegmentsUpdateWorker;\n}();\nexport { MySegmentsUpdateWorker };","map":{"version":3,"names":["Backoff","MySegmentsUpdateWorker","mySegmentsSyncTask","maxChangeNumber","handleNewEvent","segmentsData","undefined","currentChangeNumber","put","bind","__handleMySegmentsUpdateCall","backoff","prototype","_this","currentMaxChangeNumber_1","execute","then","result","Math","max","scheduleCall","changeNumber","reset","isExecuting"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/streaming/UpdateWorkers/MySegmentsUpdateWorker.js"],"sourcesContent":["import { Backoff } from '../../../utils/Backoff';\n/**\n * MySegmentsUpdateWorker class\n */\nvar MySegmentsUpdateWorker = /** @class */ (function () {\n    /**\n     * @param {Object} mySegmentsSyncTask task for syncing mySegments data\n     */\n    function MySegmentsUpdateWorker(mySegmentsSyncTask) {\n        this.mySegmentsSyncTask = mySegmentsSyncTask;\n        this.maxChangeNumber = 0; // keeps the maximum changeNumber among queued events\n        this.handleNewEvent = false;\n        this.segmentsData = undefined; // keeps the segmentsData (if included in notification payload) from the queued event with maximum changeNumber\n        this.currentChangeNumber = -1; // @TODO: remove once `/mySegments` endpoint provides the changeNumber\n        this.put = this.put.bind(this);\n        this.__handleMySegmentsUpdateCall = this.__handleMySegmentsUpdateCall.bind(this);\n        this.backoff = new Backoff(this.__handleMySegmentsUpdateCall);\n    }\n    // Private method\n    // Precondition: this.mySegmentsSyncTask.isSynchronizingMySegments === false\n    MySegmentsUpdateWorker.prototype.__handleMySegmentsUpdateCall = function () {\n        var _this = this;\n        if (this.maxChangeNumber > this.currentChangeNumber) {\n            this.handleNewEvent = false;\n            var currentMaxChangeNumber_1 = this.maxChangeNumber;\n            // fetch mySegments revalidating data if cached\n            this.mySegmentsSyncTask.execute(this.segmentsData, true).then(function (result) {\n                if (result !== false) // Unlike `Splits|SegmentsUpdateWorker`, we cannot use `mySegmentsCache.getChangeNumber` since `/mySegments` endpoint doesn't provide this value.\n                    _this.currentChangeNumber = Math.max(_this.currentChangeNumber, currentMaxChangeNumber_1); // use `currentMaxChangeNumber`, in case that `this.maxChangeNumber` was updated during fetch.\n                if (_this.handleNewEvent) {\n                    _this.__handleMySegmentsUpdateCall();\n                }\n                else {\n                    _this.backoff.scheduleCall();\n                }\n            });\n        }\n    };\n    /**\n     * Invoked by NotificationProcessor on MY_SEGMENTS_UPDATE event\n     *\n     * @param {number} changeNumber change number of the MY_SEGMENTS_UPDATE notification\n     * @param {SegmentsData | undefined} segmentsData might be undefined\n     */\n    MySegmentsUpdateWorker.prototype.put = function (changeNumber, segmentsData) {\n        if (changeNumber <= this.currentChangeNumber || changeNumber <= this.maxChangeNumber)\n            return;\n        this.maxChangeNumber = changeNumber;\n        this.handleNewEvent = true;\n        this.backoff.reset();\n        this.segmentsData = segmentsData;\n        if (this.mySegmentsSyncTask.isExecuting())\n            return;\n        this.__handleMySegmentsUpdateCall();\n    };\n    return MySegmentsUpdateWorker;\n}());\nexport { MySegmentsUpdateWorker };\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,wBAAwB;AAChD;AACA;AACA;AACA,IAAIC,sBAAsB,GAAG,aAAe,YAAY;EACpD;AACJ;AACA;EACI,SAASA,sBAAsB,CAACC,kBAAkB,EAAE;IAChD,IAAI,CAACA,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,eAAe,GAAG,CAAC,CAAC,CAAC;IAC1B,IAAI,CAACC,cAAc,GAAG,KAAK;IAC3B,IAAI,CAACC,YAAY,GAAGC,SAAS,CAAC,CAAC;IAC/B,IAAI,CAACC,mBAAmB,GAAG,CAAC,CAAC,CAAC,CAAC;IAC/B,IAAI,CAACC,GAAG,GAAG,IAAI,CAACA,GAAG,CAACC,IAAI,CAAC,IAAI,CAAC;IAC9B,IAAI,CAACC,4BAA4B,GAAG,IAAI,CAACA,4BAA4B,CAACD,IAAI,CAAC,IAAI,CAAC;IAChF,IAAI,CAACE,OAAO,GAAG,IAAIX,OAAO,CAAC,IAAI,CAACU,4BAA4B,CAAC;EACjE;EACA;EACA;EACAT,sBAAsB,CAACW,SAAS,CAACF,4BAA4B,GAAG,YAAY;IACxE,IAAIG,KAAK,GAAG,IAAI;IAChB,IAAI,IAAI,CAACV,eAAe,GAAG,IAAI,CAACI,mBAAmB,EAAE;MACjD,IAAI,CAACH,cAAc,GAAG,KAAK;MAC3B,IAAIU,wBAAwB,GAAG,IAAI,CAACX,eAAe;MACnD;MACA,IAAI,CAACD,kBAAkB,CAACa,OAAO,CAAC,IAAI,CAACV,YAAY,EAAE,IAAI,CAAC,CAACW,IAAI,CAAC,UAAUC,MAAM,EAAE;QAC5E,IAAIA,MAAM,KAAK,KAAK;UAAE;UAClBJ,KAAK,CAACN,mBAAmB,GAAGW,IAAI,CAACC,GAAG,CAACN,KAAK,CAACN,mBAAmB,EAAEO,wBAAwB,CAAC,CAAC,CAAC;QAC/F,IAAID,KAAK,CAACT,cAAc,EAAE;UACtBS,KAAK,CAACH,4BAA4B,EAAE;QACxC,CAAC,MACI;UACDG,KAAK,CAACF,OAAO,CAACS,YAAY,EAAE;QAChC;MACJ,CAAC,CAAC;IACN;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACInB,sBAAsB,CAACW,SAAS,CAACJ,GAAG,GAAG,UAAUa,YAAY,EAAEhB,YAAY,EAAE;IACzE,IAAIgB,YAAY,IAAI,IAAI,CAACd,mBAAmB,IAAIc,YAAY,IAAI,IAAI,CAAClB,eAAe,EAChF;IACJ,IAAI,CAACA,eAAe,GAAGkB,YAAY;IACnC,IAAI,CAACjB,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACO,OAAO,CAACW,KAAK,EAAE;IACpB,IAAI,CAACjB,YAAY,GAAGA,YAAY;IAChC,IAAI,IAAI,CAACH,kBAAkB,CAACqB,WAAW,EAAE,EACrC;IACJ,IAAI,CAACb,4BAA4B,EAAE;EACvC,CAAC;EACD,OAAOT,sBAAsB;AACjC,CAAC,EAAG;AACJ,SAASA,sBAAsB"},"metadata":{},"sourceType":"module"}