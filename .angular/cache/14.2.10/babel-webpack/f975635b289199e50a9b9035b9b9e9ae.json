{"ast":null,"code":"import { SDK_SPLITS_ARRIVED } from '../../../readiness/constants';\nimport { Backoff } from '../../../utils/Backoff';\n/**\n * SplitsUpdateWorker class\n */\nvar SplitsUpdateWorker = /** @class */function () {\n  /**\n   * @param {Object} splitsCache splits data cache\n   * @param {Object} splitsSyncTask task for syncing splits data\n   * @param {Object} splitsEventEmitter emitter for splits data events\n   */\n  function SplitsUpdateWorker(splitsCache, splitsSyncTask, splitsEventEmitter, segmentsSyncTask) {\n    this.splitsCache = splitsCache;\n    this.splitsSyncTask = splitsSyncTask;\n    this.splitsEventEmitter = splitsEventEmitter;\n    this.segmentsSyncTask = segmentsSyncTask;\n    this.maxChangeNumber = 0;\n    this.handleNewEvent = false;\n    this.put = this.put.bind(this);\n    this.killSplit = this.killSplit.bind(this);\n    this.__handleSplitUpdateCall = this.__handleSplitUpdateCall.bind(this);\n    this.backoff = new Backoff(this.__handleSplitUpdateCall);\n  }\n  // Private method\n  // Preconditions: this.splitsSyncTask.isSynchronizingSplits === false\n  SplitsUpdateWorker.prototype.__handleSplitUpdateCall = function () {\n    var _this = this;\n    if (this.maxChangeNumber > this.splitsCache.getChangeNumber()) {\n      this.handleNewEvent = false;\n      // fetch splits revalidating data if cached\n      this.splitsSyncTask.execute(true).then(function () {\n        if (_this.handleNewEvent) {\n          _this.__handleSplitUpdateCall();\n        } else {\n          // fetch new registered segments for server-side API. Not retrying on error\n          if (_this.segmentsSyncTask) _this.segmentsSyncTask.execute(undefined, false, true);\n          _this.backoff.scheduleCall();\n        }\n      });\n    }\n  };\n  /**\n   * Invoked by NotificationProcessor on SPLIT_UPDATE event\n   *\n   * @param {number} changeNumber change number of the SPLIT_UPDATE notification\n   */\n  SplitsUpdateWorker.prototype.put = function (_a) {\n    var changeNumber = _a.changeNumber;\n    var currentChangeNumber = this.splitsCache.getChangeNumber();\n    if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumber) return;\n    this.maxChangeNumber = changeNumber;\n    this.handleNewEvent = true;\n    this.backoff.reset();\n    if (this.splitsSyncTask.isExecuting()) return;\n    this.__handleSplitUpdateCall();\n  };\n  /**\n   * Invoked by NotificationProcessor on SPLIT_KILL event\n   *\n   * @param {number} changeNumber change number of the SPLIT_UPDATE notification\n   * @param {string} splitName name of split to kill\n   * @param {string} defaultTreatment default treatment value\n   */\n  SplitsUpdateWorker.prototype.killSplit = function (_a) {\n    var changeNumber = _a.changeNumber,\n      splitName = _a.splitName,\n      defaultTreatment = _a.defaultTreatment;\n    if (this.splitsCache.killLocally(splitName, defaultTreatment, changeNumber)) {\n      // trigger an SDK_UPDATE if Split was killed locally\n      this.splitsEventEmitter.emit(SDK_SPLITS_ARRIVED, true);\n    }\n    // queues the SplitChanges fetch (only if changeNumber is newer)\n    this.put({\n      changeNumber: changeNumber\n    });\n  };\n  return SplitsUpdateWorker;\n}();\nexport { SplitsUpdateWorker };","map":{"version":3,"names":["SDK_SPLITS_ARRIVED","Backoff","SplitsUpdateWorker","splitsCache","splitsSyncTask","splitsEventEmitter","segmentsSyncTask","maxChangeNumber","handleNewEvent","put","bind","killSplit","__handleSplitUpdateCall","backoff","prototype","_this","getChangeNumber","execute","then","undefined","scheduleCall","_a","changeNumber","currentChangeNumber","reset","isExecuting","splitName","defaultTreatment","killLocally","emit"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/streaming/UpdateWorkers/SplitsUpdateWorker.js"],"sourcesContent":["import { SDK_SPLITS_ARRIVED } from '../../../readiness/constants';\nimport { Backoff } from '../../../utils/Backoff';\n/**\n * SplitsUpdateWorker class\n */\nvar SplitsUpdateWorker = /** @class */ (function () {\n    /**\n     * @param {Object} splitsCache splits data cache\n     * @param {Object} splitsSyncTask task for syncing splits data\n     * @param {Object} splitsEventEmitter emitter for splits data events\n     */\n    function SplitsUpdateWorker(splitsCache, splitsSyncTask, splitsEventEmitter, segmentsSyncTask) {\n        this.splitsCache = splitsCache;\n        this.splitsSyncTask = splitsSyncTask;\n        this.splitsEventEmitter = splitsEventEmitter;\n        this.segmentsSyncTask = segmentsSyncTask;\n        this.maxChangeNumber = 0;\n        this.handleNewEvent = false;\n        this.put = this.put.bind(this);\n        this.killSplit = this.killSplit.bind(this);\n        this.__handleSplitUpdateCall = this.__handleSplitUpdateCall.bind(this);\n        this.backoff = new Backoff(this.__handleSplitUpdateCall);\n    }\n    // Private method\n    // Preconditions: this.splitsSyncTask.isSynchronizingSplits === false\n    SplitsUpdateWorker.prototype.__handleSplitUpdateCall = function () {\n        var _this = this;\n        if (this.maxChangeNumber > this.splitsCache.getChangeNumber()) {\n            this.handleNewEvent = false;\n            // fetch splits revalidating data if cached\n            this.splitsSyncTask.execute(true).then(function () {\n                if (_this.handleNewEvent) {\n                    _this.__handleSplitUpdateCall();\n                }\n                else {\n                    // fetch new registered segments for server-side API. Not retrying on error\n                    if (_this.segmentsSyncTask)\n                        _this.segmentsSyncTask.execute(undefined, false, true);\n                    _this.backoff.scheduleCall();\n                }\n            });\n        }\n    };\n    /**\n     * Invoked by NotificationProcessor on SPLIT_UPDATE event\n     *\n     * @param {number} changeNumber change number of the SPLIT_UPDATE notification\n     */\n    SplitsUpdateWorker.prototype.put = function (_a) {\n        var changeNumber = _a.changeNumber;\n        var currentChangeNumber = this.splitsCache.getChangeNumber();\n        if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumber)\n            return;\n        this.maxChangeNumber = changeNumber;\n        this.handleNewEvent = true;\n        this.backoff.reset();\n        if (this.splitsSyncTask.isExecuting())\n            return;\n        this.__handleSplitUpdateCall();\n    };\n    /**\n     * Invoked by NotificationProcessor on SPLIT_KILL event\n     *\n     * @param {number} changeNumber change number of the SPLIT_UPDATE notification\n     * @param {string} splitName name of split to kill\n     * @param {string} defaultTreatment default treatment value\n     */\n    SplitsUpdateWorker.prototype.killSplit = function (_a) {\n        var changeNumber = _a.changeNumber, splitName = _a.splitName, defaultTreatment = _a.defaultTreatment;\n        if (this.splitsCache.killLocally(splitName, defaultTreatment, changeNumber)) {\n            // trigger an SDK_UPDATE if Split was killed locally\n            this.splitsEventEmitter.emit(SDK_SPLITS_ARRIVED, true);\n        }\n        // queues the SplitChanges fetch (only if changeNumber is newer)\n        this.put({ changeNumber: changeNumber });\n    };\n    return SplitsUpdateWorker;\n}());\nexport { SplitsUpdateWorker };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}