{"ast":null,"code":"import { LOG_PREFIX } from './constants';\nvar EventsCachePluggable = /** @class */function () {\n  function EventsCachePluggable(log, key, wrapper, metadata) {\n    this.log = log;\n    this.key = key;\n    this.wrapper = wrapper;\n    this.metadata = metadata;\n  }\n  /**\n   * Push given event to the storage.\n   * @param eventData  Event item to push.\n   * @returns  A promise that is resolved with a boolean value indicating if the push operation succeeded or failed.\n   * Unlike `impressions::track`, The promise will never be rejected.\n   */\n  EventsCachePluggable.prototype.track = function (eventData) {\n    var _this = this;\n    return this.wrapper.pushItems(this.key, [this._toJSON(eventData)])\n    // We use boolean values to signal successful queueing\n    .then(function () {\n      return true;\n    }).catch(function (e) {\n      _this.log.error(LOG_PREFIX + \"Error adding event to queue: \" + e + \".\");\n      return false;\n    });\n  };\n  EventsCachePluggable.prototype._toJSON = function (eventData) {\n    return JSON.stringify({\n      m: this.metadata,\n      e: eventData\n    });\n  };\n  /**\n   * Returns a promise that resolves with the count of stored events, or 0 if there was some error.\n   * The promise will never be rejected.\n   */\n  EventsCachePluggable.prototype.count = function () {\n    return this.wrapper.getItemsCount(this.key).catch(function () {\n      return 0;\n    });\n  };\n  /**\n   * Removes the given number of events from the store. If a number is not provided, it deletes all items.\n   * The returned promise rejects if the wrapper operation fails.\n   */\n  EventsCachePluggable.prototype.drop = function (count) {\n    if (!count) return this.wrapper.del(this.key);\n    return this.wrapper.popItems(this.key, count).then(function () {});\n  };\n  /**\n   * Pop the given number of events from the storage.\n   * The returned promise rejects if the wrapper operation fails.\n   *\n   * NOTE: this method doesn't take into account MAX_EVENT_SIZE or MAX_QUEUE_BYTE_SIZE limits.\n   * It is the submitter responsability to handle that.\n   */\n  EventsCachePluggable.prototype.popNWithMetadata = function (count) {\n    return this.wrapper.popItems(this.key, count).then(function (items) {\n      return items.map(function (item) {\n        return JSON.parse(item);\n      });\n    });\n  };\n  return EventsCachePluggable;\n}();\nexport { EventsCachePluggable };","map":{"version":3,"names":["LOG_PREFIX","EventsCachePluggable","log","key","wrapper","metadata","prototype","track","eventData","_this","pushItems","_toJSON","then","catch","e","error","JSON","stringify","m","count","getItemsCount","drop","del","popItems","popNWithMetadata","items","map","item","parse"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/pluggable/EventsCachePluggable.js"],"sourcesContent":["import { LOG_PREFIX } from './constants';\nvar EventsCachePluggable = /** @class */ (function () {\n    function EventsCachePluggable(log, key, wrapper, metadata) {\n        this.log = log;\n        this.key = key;\n        this.wrapper = wrapper;\n        this.metadata = metadata;\n    }\n    /**\n     * Push given event to the storage.\n     * @param eventData  Event item to push.\n     * @returns  A promise that is resolved with a boolean value indicating if the push operation succeeded or failed.\n     * Unlike `impressions::track`, The promise will never be rejected.\n     */\n    EventsCachePluggable.prototype.track = function (eventData) {\n        var _this = this;\n        return this.wrapper.pushItems(this.key, [this._toJSON(eventData)])\n            // We use boolean values to signal successful queueing\n            .then(function () { return true; })\n            .catch(function (e) {\n            _this.log.error(LOG_PREFIX + \"Error adding event to queue: \" + e + \".\");\n            return false;\n        });\n    };\n    EventsCachePluggable.prototype._toJSON = function (eventData) {\n        return JSON.stringify({\n            m: this.metadata,\n            e: eventData\n        });\n    };\n    /**\n     * Returns a promise that resolves with the count of stored events, or 0 if there was some error.\n     * The promise will never be rejected.\n     */\n    EventsCachePluggable.prototype.count = function () {\n        return this.wrapper.getItemsCount(this.key).catch(function () { return 0; });\n    };\n    /**\n     * Removes the given number of events from the store. If a number is not provided, it deletes all items.\n     * The returned promise rejects if the wrapper operation fails.\n     */\n    EventsCachePluggable.prototype.drop = function (count) {\n        if (!count)\n            return this.wrapper.del(this.key);\n        return this.wrapper.popItems(this.key, count).then(function () { });\n    };\n    /**\n     * Pop the given number of events from the storage.\n     * The returned promise rejects if the wrapper operation fails.\n     *\n     * NOTE: this method doesn't take into account MAX_EVENT_SIZE or MAX_QUEUE_BYTE_SIZE limits.\n     * It is the submitter responsability to handle that.\n     */\n    EventsCachePluggable.prototype.popNWithMetadata = function (count) {\n        return this.wrapper.popItems(this.key, count).then(function (items) {\n            return items.map(function (item) { return JSON.parse(item); });\n        });\n    };\n    return EventsCachePluggable;\n}());\nexport { EventsCachePluggable };\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,aAAa;AACxC,IAAIC,oBAAoB,GAAG,aAAe,YAAY;EAClD,SAASA,oBAAoB,CAACC,GAAG,EAAEC,GAAG,EAAEC,OAAO,EAAEC,QAAQ,EAAE;IACvD,IAAI,CAACH,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC5B;EACA;AACJ;AACA;AACA;AACA;AACA;EACIJ,oBAAoB,CAACK,SAAS,CAACC,KAAK,GAAG,UAAUC,SAAS,EAAE;IACxD,IAAIC,KAAK,GAAG,IAAI;IAChB,OAAO,IAAI,CAACL,OAAO,CAACM,SAAS,CAAC,IAAI,CAACP,GAAG,EAAE,CAAC,IAAI,CAACQ,OAAO,CAACH,SAAS,CAAC,CAAC;IAC7D;IAAA,CACCI,IAAI,CAAC,YAAY;MAAE,OAAO,IAAI;IAAE,CAAC,CAAC,CAClCC,KAAK,CAAC,UAAUC,CAAC,EAAE;MACpBL,KAAK,CAACP,GAAG,CAACa,KAAK,CAACf,UAAU,GAAG,+BAA+B,GAAGc,CAAC,GAAG,GAAG,CAAC;MACvE,OAAO,KAAK;IAChB,CAAC,CAAC;EACN,CAAC;EACDb,oBAAoB,CAACK,SAAS,CAACK,OAAO,GAAG,UAAUH,SAAS,EAAE;IAC1D,OAAOQ,IAAI,CAACC,SAAS,CAAC;MAClBC,CAAC,EAAE,IAAI,CAACb,QAAQ;MAChBS,CAAC,EAAEN;IACP,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;EACIP,oBAAoB,CAACK,SAAS,CAACa,KAAK,GAAG,YAAY;IAC/C,OAAO,IAAI,CAACf,OAAO,CAACgB,aAAa,CAAC,IAAI,CAACjB,GAAG,CAAC,CAACU,KAAK,CAAC,YAAY;MAAE,OAAO,CAAC;IAAE,CAAC,CAAC;EAChF,CAAC;EACD;AACJ;AACA;AACA;EACIZ,oBAAoB,CAACK,SAAS,CAACe,IAAI,GAAG,UAAUF,KAAK,EAAE;IACnD,IAAI,CAACA,KAAK,EACN,OAAO,IAAI,CAACf,OAAO,CAACkB,GAAG,CAAC,IAAI,CAACnB,GAAG,CAAC;IACrC,OAAO,IAAI,CAACC,OAAO,CAACmB,QAAQ,CAAC,IAAI,CAACpB,GAAG,EAAEgB,KAAK,CAAC,CAACP,IAAI,CAAC,YAAY,CAAE,CAAC,CAAC;EACvE,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIX,oBAAoB,CAACK,SAAS,CAACkB,gBAAgB,GAAG,UAAUL,KAAK,EAAE;IAC/D,OAAO,IAAI,CAACf,OAAO,CAACmB,QAAQ,CAAC,IAAI,CAACpB,GAAG,EAAEgB,KAAK,CAAC,CAACP,IAAI,CAAC,UAAUa,KAAK,EAAE;MAChE,OAAOA,KAAK,CAACC,GAAG,CAAC,UAAUC,IAAI,EAAE;QAAE,OAAOX,IAAI,CAACY,KAAK,CAACD,IAAI,CAAC;MAAE,CAAC,CAAC;IAClE,CAAC,CAAC;EACN,CAAC;EACD,OAAO1B,oBAAoB;AAC/B,CAAC,EAAG;AACJ,SAASA,oBAAoB"},"metadata":{},"sourceType":"module"}