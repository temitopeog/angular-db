{"ast":null,"code":"import { SYNC_TASK_EXECUTE, SYNC_TASK_START, SYNC_TASK_STOP } from '../logger/constants';\n/**\n * Creates a syncTask that handles the periodic execution of a given task (\"start\" and \"stop\" methods).\n * The task can be also executed by calling the \"execute\" method. Multiple execute calls are chained to run secuentially and avoid race conditions.\n * For example, submitters executed on SDK destroy or full queue, while periodic execution is pending.\n *\n * @param log  Logger instance.\n * @param task  Task to execute that returns a promise that NEVER REJECTS. Otherwise, periodic execution can result in Unhandled Promise Rejections.\n * @param period  Period in milliseconds to execute the task.\n * @param taskName  Optional task name for logging.\n * @returns A sync task that wraps the given task.\n */\nexport function syncTaskFactory(log, task, period, taskName) {\n  if (taskName === void 0) {\n    taskName = 'task';\n  }\n  // Task promise while it is pending. Undefined once the promise is resolved\n  var pendingTask;\n  // flag that indicates if the task periodic execution has been started/stopped.\n  var running = false;\n  // Auxiliar counter used to avoid race condition when calling `start` & `stop` intermittently\n  var runningId = 0;\n  // Params passed to `task` when called periodically\n  var runningArgs;\n  // Id of the periodic call timeout\n  var timeoutID;\n  function execute() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    // If task is executing, chain the new execution\n    if (pendingTask) {\n      return pendingTask.then(function () {\n        return execute.apply(void 0, args);\n      });\n    }\n    // Execute task\n    log.debug(SYNC_TASK_EXECUTE, [taskName]);\n    pendingTask = task.apply(void 0, args).then(function (result) {\n      pendingTask = undefined;\n      return result;\n    });\n    return pendingTask;\n  }\n  function periodicExecute(currentRunningId) {\n    return execute.apply(void 0, runningArgs).then(function (result) {\n      // Call `setTimeout` if periodic execution was started and `currentRunningId === runningId`\n      // to avoid a race condition when calling `start`, `stop` and `start` again\n      if (running && currentRunningId === runningId) timeoutID = setTimeout(periodicExecute, period, currentRunningId);\n      return result;\n    });\n  }\n  return {\n    execute: execute,\n    isExecuting: function () {\n      return pendingTask !== undefined;\n    },\n    start: function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (!running) {\n        running = true;\n        runningId++;\n        runningArgs = args;\n        log.debug(SYNC_TASK_START, [taskName, period]);\n        return periodicExecute(runningId);\n      }\n    },\n    stop: function () {\n      running = false;\n      if (timeoutID) {\n        log.debug(SYNC_TASK_STOP, [taskName]);\n        clearTimeout(timeoutID);\n        timeoutID = undefined;\n      }\n    },\n    isRunning: function () {\n      return running;\n    }\n  };\n}","map":{"version":3,"names":["SYNC_TASK_EXECUTE","SYNC_TASK_START","SYNC_TASK_STOP","syncTaskFactory","log","task","period","taskName","pendingTask","running","runningId","runningArgs","timeoutID","execute","args","_i","arguments","length","then","apply","debug","result","undefined","periodicExecute","currentRunningId","setTimeout","isExecuting","start","stop","clearTimeout","isRunning"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/syncTask.js"],"sourcesContent":["import { SYNC_TASK_EXECUTE, SYNC_TASK_START, SYNC_TASK_STOP } from '../logger/constants';\n/**\n * Creates a syncTask that handles the periodic execution of a given task (\"start\" and \"stop\" methods).\n * The task can be also executed by calling the \"execute\" method. Multiple execute calls are chained to run secuentially and avoid race conditions.\n * For example, submitters executed on SDK destroy or full queue, while periodic execution is pending.\n *\n * @param log  Logger instance.\n * @param task  Task to execute that returns a promise that NEVER REJECTS. Otherwise, periodic execution can result in Unhandled Promise Rejections.\n * @param period  Period in milliseconds to execute the task.\n * @param taskName  Optional task name for logging.\n * @returns A sync task that wraps the given task.\n */\nexport function syncTaskFactory(log, task, period, taskName) {\n    if (taskName === void 0) { taskName = 'task'; }\n    // Task promise while it is pending. Undefined once the promise is resolved\n    var pendingTask;\n    // flag that indicates if the task periodic execution has been started/stopped.\n    var running = false;\n    // Auxiliar counter used to avoid race condition when calling `start` & `stop` intermittently\n    var runningId = 0;\n    // Params passed to `task` when called periodically\n    var runningArgs;\n    // Id of the periodic call timeout\n    var timeoutID;\n    function execute() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // If task is executing, chain the new execution\n        if (pendingTask) {\n            return pendingTask.then(function () {\n                return execute.apply(void 0, args);\n            });\n        }\n        // Execute task\n        log.debug(SYNC_TASK_EXECUTE, [taskName]);\n        pendingTask = task.apply(void 0, args).then(function (result) {\n            pendingTask = undefined;\n            return result;\n        });\n        return pendingTask;\n    }\n    function periodicExecute(currentRunningId) {\n        return execute.apply(void 0, runningArgs).then(function (result) {\n            // Call `setTimeout` if periodic execution was started and `currentRunningId === runningId`\n            // to avoid a race condition when calling `start`, `stop` and `start` again\n            if (running && currentRunningId === runningId)\n                timeoutID = setTimeout(periodicExecute, period, currentRunningId);\n            return result;\n        });\n    }\n    return {\n        execute: execute,\n        isExecuting: function () {\n            return pendingTask !== undefined;\n        },\n        start: function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (!running) {\n                running = true;\n                runningId++;\n                runningArgs = args;\n                log.debug(SYNC_TASK_START, [taskName, period]);\n                return periodicExecute(runningId);\n            }\n        },\n        stop: function () {\n            running = false;\n            if (timeoutID) {\n                log.debug(SYNC_TASK_STOP, [taskName]);\n                clearTimeout(timeoutID);\n                timeoutID = undefined;\n            }\n        },\n        isRunning: function () {\n            return running;\n        }\n    };\n}\n"],"mappings":"AAAA,SAASA,iBAAiB,EAAEC,eAAe,EAAEC,cAAc,QAAQ,qBAAqB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAe,CAACC,GAAG,EAAEC,IAAI,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACzD,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;IAAEA,QAAQ,GAAG,MAAM;EAAE;EAC9C;EACA,IAAIC,WAAW;EACf;EACA,IAAIC,OAAO,GAAG,KAAK;EACnB;EACA,IAAIC,SAAS,GAAG,CAAC;EACjB;EACA,IAAIC,WAAW;EACf;EACA,IAAIC,SAAS;EACb,SAASC,OAAO,GAAG;IACf,IAAIC,IAAI,GAAG,EAAE;IACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC1CD,IAAI,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC5B;IACA;IACA,IAAIP,WAAW,EAAE;MACb,OAAOA,WAAW,CAACU,IAAI,CAAC,YAAY;QAChC,OAAOL,OAAO,CAACM,KAAK,CAAC,KAAK,CAAC,EAAEL,IAAI,CAAC;MACtC,CAAC,CAAC;IACN;IACA;IACAV,GAAG,CAACgB,KAAK,CAACpB,iBAAiB,EAAE,CAACO,QAAQ,CAAC,CAAC;IACxCC,WAAW,GAAGH,IAAI,CAACc,KAAK,CAAC,KAAK,CAAC,EAAEL,IAAI,CAAC,CAACI,IAAI,CAAC,UAAUG,MAAM,EAAE;MAC1Db,WAAW,GAAGc,SAAS;MACvB,OAAOD,MAAM;IACjB,CAAC,CAAC;IACF,OAAOb,WAAW;EACtB;EACA,SAASe,eAAe,CAACC,gBAAgB,EAAE;IACvC,OAAOX,OAAO,CAACM,KAAK,CAAC,KAAK,CAAC,EAAER,WAAW,CAAC,CAACO,IAAI,CAAC,UAAUG,MAAM,EAAE;MAC7D;MACA;MACA,IAAIZ,OAAO,IAAIe,gBAAgB,KAAKd,SAAS,EACzCE,SAAS,GAAGa,UAAU,CAACF,eAAe,EAAEjB,MAAM,EAAEkB,gBAAgB,CAAC;MACrE,OAAOH,MAAM;IACjB,CAAC,CAAC;EACN;EACA,OAAO;IACHR,OAAO,EAAEA,OAAO;IAChBa,WAAW,EAAE,YAAY;MACrB,OAAOlB,WAAW,KAAKc,SAAS;IACpC,CAAC;IACDK,KAAK,EAAE,YAAY;MACf,IAAIb,IAAI,GAAG,EAAE;MACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;QAC1CD,IAAI,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;MAC5B;MACA,IAAI,CAACN,OAAO,EAAE;QACVA,OAAO,GAAG,IAAI;QACdC,SAAS,EAAE;QACXC,WAAW,GAAGG,IAAI;QAClBV,GAAG,CAACgB,KAAK,CAACnB,eAAe,EAAE,CAACM,QAAQ,EAAED,MAAM,CAAC,CAAC;QAC9C,OAAOiB,eAAe,CAACb,SAAS,CAAC;MACrC;IACJ,CAAC;IACDkB,IAAI,EAAE,YAAY;MACdnB,OAAO,GAAG,KAAK;MACf,IAAIG,SAAS,EAAE;QACXR,GAAG,CAACgB,KAAK,CAAClB,cAAc,EAAE,CAACK,QAAQ,CAAC,CAAC;QACrCsB,YAAY,CAACjB,SAAS,CAAC;QACvBA,SAAS,GAAGU,SAAS;MACzB;IACJ,CAAC;IACDQ,SAAS,EAAE,YAAY;MACnB,OAAOrB,OAAO;IAClB;EACJ,CAAC;AACL"},"metadata":{},"sourceType":"module"}