{"ast":null,"code":"import { submitterManagerFactory } from './submitters/submitterManager';\nimport { PUSH_SUBSYSTEM_UP, PUSH_SUBSYSTEM_DOWN } from './streaming/constants';\nimport { SYNC_START_POLLING, SYNC_CONTINUE_POLLING, SYNC_STOP_POLLING } from '../logger/constants';\nimport { isConsentGranted } from '../consent';\nimport { POLLING, STREAMING, SYNC_MODE_UPDATE } from '../utils/constants';\n/**\n * Online SyncManager factory.\n * Can be used for server-side API, and client-side API with or without multiple clients.\n *\n * @param pollingManagerFactory allows to specialize the SyncManager for server-side or client-side API by passing\n * `pollingManagerSSFactory` or `pollingManagerCSFactory` respectively.\n * @param pushManagerFactory optional to build a SyncManager with or without streaming support\n */\nexport function syncManagerOnlineFactory(pollingManagerFactory, pushManagerFactory) {\n  /**\n   * SyncManager factory for modular SDK\n   */\n  return function (params) {\n    var settings = params.settings,\n      _a = params.settings,\n      log = _a.log,\n      streamingEnabled = _a.streamingEnabled,\n      syncEnabled = _a.sync.enabled,\n      telemetryTracker = params.telemetryTracker;\n    /** Polling Manager */\n    var pollingManager = pollingManagerFactory && pollingManagerFactory(params);\n    /** Push Manager */\n    var pushManager = syncEnabled && streamingEnabled && pollingManager && pushManagerFactory ? pushManagerFactory(params, pollingManager) : undefined;\n    /** Submitter Manager */\n    // It is not inyected as push and polling managers, because at the moment it is required\n    var submitterManager = submitterManagerFactory(params);\n    /** Sync Manager logic */\n    function startPolling() {\n      if (pollingManager.isRunning()) {\n        log.info(SYNC_CONTINUE_POLLING);\n      } else {\n        log.info(SYNC_START_POLLING);\n        pollingManager.start();\n        telemetryTracker.streamingEvent(SYNC_MODE_UPDATE, POLLING);\n      }\n    }\n    function stopPollingAndSyncAll() {\n      log.info(SYNC_STOP_POLLING);\n      // if polling, stop\n      if (pollingManager.isRunning()) {\n        pollingManager.stop();\n        telemetryTracker.streamingEvent(SYNC_MODE_UPDATE, STREAMING);\n      }\n      // fetch splits and segments. There is no need to catch this promise (it is always resolved)\n      pollingManager.syncAll();\n    }\n    if (pushManager) {\n      pushManager.on(PUSH_SUBSYSTEM_UP, stopPollingAndSyncAll);\n      pushManager.on(PUSH_SUBSYSTEM_DOWN, startPolling);\n    }\n    var running = false; // flag that indicates whether the syncManager has been started (true) or stopped (false)\n    var startFirstTime = true; // flag to distinguish calling the `start` method for the first time, to support pausing and resuming the synchronization\n    return {\n      // Exposed for fine-grained control of synchronization.\n      // E.g.: user consent, app state changes (Page hide, Foreground/Background, Online/Offline).\n      pollingManager: pollingManager,\n      pushManager: pushManager,\n      submitterManager: submitterManager,\n      /**\n       * Method used to start the syncManager for the first time, or resume it after being stopped.\n       */\n      start: function () {\n        running = true;\n        // start syncing splits and segments\n        if (pollingManager) {\n          // If synchronization is disabled pushManager and pollingManager should not start\n          if (syncEnabled) {\n            if (pushManager) {\n              // Doesn't call `syncAll` when the syncManager is resuming\n              if (startFirstTime) {\n                pollingManager.syncAll();\n                startFirstTime = false;\n              }\n              pushManager.start();\n            } else {\n              pollingManager.start();\n            }\n          } else {\n            if (startFirstTime) {\n              pollingManager.syncAll();\n              startFirstTime = false;\n            }\n          }\n        }\n        // start periodic data recording (events, impressions, telemetry).\n        submitterManager.start(!isConsentGranted(settings));\n      },\n      /**\n       * Method used to stop/pause the syncManager.\n       */\n      stop: function () {\n        running = false;\n        // stop syncing\n        if (pushManager) pushManager.stop();\n        if (pollingManager && pollingManager.isRunning()) pollingManager.stop();\n        // stop periodic data recording (events, impressions, telemetry).\n        submitterManager.stop();\n      },\n      isRunning: function () {\n        return running;\n      },\n      flush: function () {\n        return submitterManager.execute(!isConsentGranted(settings));\n      },\n      // [Only used for client-side]\n      // If polling and push managers are defined (standalone mode), they implement the interfaces for client-side\n      shared: function (matchingKey, readinessManager, storage) {\n        if (!pollingManager) return;\n        var mySegmentsSyncTask = pollingManager.add(matchingKey, readinessManager, storage);\n        return {\n          isRunning: mySegmentsSyncTask.isRunning,\n          start: function () {\n            if (syncEnabled) {\n              if (pushManager) {\n                if (pollingManager.isRunning()) {\n                  // if doing polling, we must start the periodic fetch of data\n                  if (storage.splits.usesSegments()) mySegmentsSyncTask.start();\n                } else {\n                  // if not polling, we must execute the sync task for the initial fetch\n                  // of segments since `syncAll` was already executed when starting the main client\n                  mySegmentsSyncTask.execute();\n                }\n                pushManager.add(matchingKey, mySegmentsSyncTask);\n              } else {\n                if (storage.splits.usesSegments()) mySegmentsSyncTask.start();\n              }\n            } else {\n              if (!readinessManager.isReady()) mySegmentsSyncTask.execute();\n            }\n          },\n          stop: function () {\n            // check in case `client.destroy()` has been invoked more than once for the same client\n            var mySegmentsSyncTask = pollingManager.get(matchingKey);\n            if (mySegmentsSyncTask) {\n              // stop syncing\n              if (pushManager) pushManager.remove(matchingKey);\n              if (mySegmentsSyncTask.isRunning()) mySegmentsSyncTask.stop();\n              pollingManager.remove(matchingKey);\n            }\n          },\n          flush: function () {\n            return Promise.resolve();\n          }\n        };\n      }\n    };\n  };\n}","map":{"version":3,"names":["submitterManagerFactory","PUSH_SUBSYSTEM_UP","PUSH_SUBSYSTEM_DOWN","SYNC_START_POLLING","SYNC_CONTINUE_POLLING","SYNC_STOP_POLLING","isConsentGranted","POLLING","STREAMING","SYNC_MODE_UPDATE","syncManagerOnlineFactory","pollingManagerFactory","pushManagerFactory","params","settings","_a","log","streamingEnabled","syncEnabled","sync","enabled","telemetryTracker","pollingManager","pushManager","undefined","submitterManager","startPolling","isRunning","info","start","streamingEvent","stopPollingAndSyncAll","stop","syncAll","on","running","startFirstTime","flush","execute","shared","matchingKey","readinessManager","storage","mySegmentsSyncTask","add","splits","usesSegments","isReady","get","remove","Promise","resolve"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/syncManagerOnline.js"],"sourcesContent":["import { submitterManagerFactory } from './submitters/submitterManager';\nimport { PUSH_SUBSYSTEM_UP, PUSH_SUBSYSTEM_DOWN } from './streaming/constants';\nimport { SYNC_START_POLLING, SYNC_CONTINUE_POLLING, SYNC_STOP_POLLING } from '../logger/constants';\nimport { isConsentGranted } from '../consent';\nimport { POLLING, STREAMING, SYNC_MODE_UPDATE } from '../utils/constants';\n/**\n * Online SyncManager factory.\n * Can be used for server-side API, and client-side API with or without multiple clients.\n *\n * @param pollingManagerFactory allows to specialize the SyncManager for server-side or client-side API by passing\n * `pollingManagerSSFactory` or `pollingManagerCSFactory` respectively.\n * @param pushManagerFactory optional to build a SyncManager with or without streaming support\n */\nexport function syncManagerOnlineFactory(pollingManagerFactory, pushManagerFactory) {\n    /**\n     * SyncManager factory for modular SDK\n     */\n    return function (params) {\n        var settings = params.settings, _a = params.settings, log = _a.log, streamingEnabled = _a.streamingEnabled, syncEnabled = _a.sync.enabled, telemetryTracker = params.telemetryTracker;\n        /** Polling Manager */\n        var pollingManager = pollingManagerFactory && pollingManagerFactory(params);\n        /** Push Manager */\n        var pushManager = syncEnabled && streamingEnabled && pollingManager && pushManagerFactory ?\n            pushManagerFactory(params, pollingManager) :\n            undefined;\n        /** Submitter Manager */\n        // It is not inyected as push and polling managers, because at the moment it is required\n        var submitterManager = submitterManagerFactory(params);\n        /** Sync Manager logic */\n        function startPolling() {\n            if (pollingManager.isRunning()) {\n                log.info(SYNC_CONTINUE_POLLING);\n            }\n            else {\n                log.info(SYNC_START_POLLING);\n                pollingManager.start();\n                telemetryTracker.streamingEvent(SYNC_MODE_UPDATE, POLLING);\n            }\n        }\n        function stopPollingAndSyncAll() {\n            log.info(SYNC_STOP_POLLING);\n            // if polling, stop\n            if (pollingManager.isRunning()) {\n                pollingManager.stop();\n                telemetryTracker.streamingEvent(SYNC_MODE_UPDATE, STREAMING);\n            }\n            // fetch splits and segments. There is no need to catch this promise (it is always resolved)\n            pollingManager.syncAll();\n        }\n        if (pushManager) {\n            pushManager.on(PUSH_SUBSYSTEM_UP, stopPollingAndSyncAll);\n            pushManager.on(PUSH_SUBSYSTEM_DOWN, startPolling);\n        }\n        var running = false; // flag that indicates whether the syncManager has been started (true) or stopped (false)\n        var startFirstTime = true; // flag to distinguish calling the `start` method for the first time, to support pausing and resuming the synchronization\n        return {\n            // Exposed for fine-grained control of synchronization.\n            // E.g.: user consent, app state changes (Page hide, Foreground/Background, Online/Offline).\n            pollingManager: pollingManager,\n            pushManager: pushManager,\n            submitterManager: submitterManager,\n            /**\n             * Method used to start the syncManager for the first time, or resume it after being stopped.\n             */\n            start: function () {\n                running = true;\n                // start syncing splits and segments\n                if (pollingManager) {\n                    // If synchronization is disabled pushManager and pollingManager should not start\n                    if (syncEnabled) {\n                        if (pushManager) {\n                            // Doesn't call `syncAll` when the syncManager is resuming\n                            if (startFirstTime) {\n                                pollingManager.syncAll();\n                                startFirstTime = false;\n                            }\n                            pushManager.start();\n                        }\n                        else {\n                            pollingManager.start();\n                        }\n                    }\n                    else {\n                        if (startFirstTime) {\n                            pollingManager.syncAll();\n                            startFirstTime = false;\n                        }\n                    }\n                }\n                // start periodic data recording (events, impressions, telemetry).\n                submitterManager.start(!isConsentGranted(settings));\n            },\n            /**\n             * Method used to stop/pause the syncManager.\n             */\n            stop: function () {\n                running = false;\n                // stop syncing\n                if (pushManager)\n                    pushManager.stop();\n                if (pollingManager && pollingManager.isRunning())\n                    pollingManager.stop();\n                // stop periodic data recording (events, impressions, telemetry).\n                submitterManager.stop();\n            },\n            isRunning: function () {\n                return running;\n            },\n            flush: function () {\n                return submitterManager.execute(!isConsentGranted(settings));\n            },\n            // [Only used for client-side]\n            // If polling and push managers are defined (standalone mode), they implement the interfaces for client-side\n            shared: function (matchingKey, readinessManager, storage) {\n                if (!pollingManager)\n                    return;\n                var mySegmentsSyncTask = pollingManager.add(matchingKey, readinessManager, storage);\n                return {\n                    isRunning: mySegmentsSyncTask.isRunning,\n                    start: function () {\n                        if (syncEnabled) {\n                            if (pushManager) {\n                                if (pollingManager.isRunning()) {\n                                    // if doing polling, we must start the periodic fetch of data\n                                    if (storage.splits.usesSegments())\n                                        mySegmentsSyncTask.start();\n                                }\n                                else {\n                                    // if not polling, we must execute the sync task for the initial fetch\n                                    // of segments since `syncAll` was already executed when starting the main client\n                                    mySegmentsSyncTask.execute();\n                                }\n                                pushManager.add(matchingKey, mySegmentsSyncTask);\n                            }\n                            else {\n                                if (storage.splits.usesSegments())\n                                    mySegmentsSyncTask.start();\n                            }\n                        }\n                        else {\n                            if (!readinessManager.isReady())\n                                mySegmentsSyncTask.execute();\n                        }\n                    },\n                    stop: function () {\n                        // check in case `client.destroy()` has been invoked more than once for the same client\n                        var mySegmentsSyncTask = pollingManager.get(matchingKey);\n                        if (mySegmentsSyncTask) {\n                            // stop syncing\n                            if (pushManager)\n                                pushManager.remove(matchingKey);\n                            if (mySegmentsSyncTask.isRunning())\n                                mySegmentsSyncTask.stop();\n                            pollingManager.remove(matchingKey);\n                        }\n                    },\n                    flush: function () { return Promise.resolve(); }\n                };\n            }\n        };\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}