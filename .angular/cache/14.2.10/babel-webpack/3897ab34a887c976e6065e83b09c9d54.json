{"ast":null,"code":"var MAX_QUEUE_BYTE_SIZE = 5 * 1024 * 1024; // 5M\nvar EventsCacheInMemory = /** @class */function () {\n  /**\n   *\n   * @param eventsQueueSize number of queued events to call onFullQueueCb.\n   * Default value is 0, that means no maximum value, in case we want to avoid this being triggered.\n   */\n  function EventsCacheInMemory(eventsQueueSize) {\n    if (eventsQueueSize === void 0) {\n      eventsQueueSize = 0;\n    }\n    this.maxQueue = eventsQueueSize;\n    this.queue = [];\n    this.queueByteSize = 0;\n  }\n  EventsCacheInMemory.prototype.setOnFullQueueCb = function (cb) {\n    this.onFullQueue = cb;\n  };\n  /**\n   * Add a new event object at the end of the queue.\n   */\n  EventsCacheInMemory.prototype.track = function (data, size) {\n    if (size === void 0) {\n      size = 0;\n    }\n    this.queueByteSize += size;\n    this.queue.push(data);\n    this._checkForFlush();\n    return true;\n  };\n  /**\n   * Clear the data stored on the cache.\n   */\n  EventsCacheInMemory.prototype.clear = function () {\n    this.queue = [];\n    this.queueByteSize = 0;\n  };\n  /**\n   * Pop the collected data, used as payload for posting.\n   */\n  EventsCacheInMemory.prototype.pop = function (toMerge) {\n    var data = this.queue;\n    this.clear();\n    return toMerge ? toMerge.concat(data) : data;\n  };\n  /**\n   * Check if the cache is empty.\n   */\n  EventsCacheInMemory.prototype.isEmpty = function () {\n    return this.queue.length === 0;\n  };\n  /**\n   * Check if the cache queue is full and we need to flush it.\n   */\n  EventsCacheInMemory.prototype._checkForFlush = function () {\n    if (this.queueByteSize > MAX_QUEUE_BYTE_SIZE ||\n    // 0 means no maximum value, in case we want to avoid this being triggered. Size limit is not affected by it.\n    this.maxQueue > 0 && this.queue.length >= this.maxQueue) {\n      this.onFullQueue && this.onFullQueue();\n    }\n  };\n  return EventsCacheInMemory;\n}();\nexport { EventsCacheInMemory };","map":{"version":3,"names":["MAX_QUEUE_BYTE_SIZE","EventsCacheInMemory","eventsQueueSize","maxQueue","queue","queueByteSize","prototype","setOnFullQueueCb","cb","onFullQueue","track","data","size","push","_checkForFlush","clear","pop","toMerge","concat","isEmpty","length"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/inMemory/EventsCacheInMemory.js"],"sourcesContent":["var MAX_QUEUE_BYTE_SIZE = 5 * 1024 * 1024; // 5M\nvar EventsCacheInMemory = /** @class */ (function () {\n    /**\n     *\n     * @param eventsQueueSize number of queued events to call onFullQueueCb.\n     * Default value is 0, that means no maximum value, in case we want to avoid this being triggered.\n     */\n    function EventsCacheInMemory(eventsQueueSize) {\n        if (eventsQueueSize === void 0) { eventsQueueSize = 0; }\n        this.maxQueue = eventsQueueSize;\n        this.queue = [];\n        this.queueByteSize = 0;\n    }\n    EventsCacheInMemory.prototype.setOnFullQueueCb = function (cb) {\n        this.onFullQueue = cb;\n    };\n    /**\n     * Add a new event object at the end of the queue.\n     */\n    EventsCacheInMemory.prototype.track = function (data, size) {\n        if (size === void 0) { size = 0; }\n        this.queueByteSize += size;\n        this.queue.push(data);\n        this._checkForFlush();\n        return true;\n    };\n    /**\n     * Clear the data stored on the cache.\n     */\n    EventsCacheInMemory.prototype.clear = function () {\n        this.queue = [];\n        this.queueByteSize = 0;\n    };\n    /**\n     * Pop the collected data, used as payload for posting.\n     */\n    EventsCacheInMemory.prototype.pop = function (toMerge) {\n        var data = this.queue;\n        this.clear();\n        return toMerge ? toMerge.concat(data) : data;\n    };\n    /**\n     * Check if the cache is empty.\n     */\n    EventsCacheInMemory.prototype.isEmpty = function () {\n        return this.queue.length === 0;\n    };\n    /**\n     * Check if the cache queue is full and we need to flush it.\n     */\n    EventsCacheInMemory.prototype._checkForFlush = function () {\n        if ((this.queueByteSize > MAX_QUEUE_BYTE_SIZE) ||\n            // 0 means no maximum value, in case we want to avoid this being triggered. Size limit is not affected by it.\n            (this.maxQueue > 0 && this.queue.length >= this.maxQueue)) {\n            this.onFullQueue && this.onFullQueue();\n        }\n    };\n    return EventsCacheInMemory;\n}());\nexport { EventsCacheInMemory };\n"],"mappings":"AAAA,IAAIA,mBAAmB,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC;AAC3C,IAAIC,mBAAmB,GAAG,aAAe,YAAY;EACjD;AACJ;AACA;AACA;AACA;EACI,SAASA,mBAAmB,CAACC,eAAe,EAAE;IAC1C,IAAIA,eAAe,KAAK,KAAK,CAAC,EAAE;MAAEA,eAAe,GAAG,CAAC;IAAE;IACvD,IAAI,CAACC,QAAQ,GAAGD,eAAe;IAC/B,IAAI,CAACE,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,CAAC;EAC1B;EACAJ,mBAAmB,CAACK,SAAS,CAACC,gBAAgB,GAAG,UAAUC,EAAE,EAAE;IAC3D,IAAI,CAACC,WAAW,GAAGD,EAAE;EACzB,CAAC;EACD;AACJ;AACA;EACIP,mBAAmB,CAACK,SAAS,CAACI,KAAK,GAAG,UAAUC,IAAI,EAAEC,IAAI,EAAE;IACxD,IAAIA,IAAI,KAAK,KAAK,CAAC,EAAE;MAAEA,IAAI,GAAG,CAAC;IAAE;IACjC,IAAI,CAACP,aAAa,IAAIO,IAAI;IAC1B,IAAI,CAACR,KAAK,CAACS,IAAI,CAACF,IAAI,CAAC;IACrB,IAAI,CAACG,cAAc,EAAE;IACrB,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;EACIb,mBAAmB,CAACK,SAAS,CAACS,KAAK,GAAG,YAAY;IAC9C,IAAI,CAACX,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,CAAC;EAC1B,CAAC;EACD;AACJ;AACA;EACIJ,mBAAmB,CAACK,SAAS,CAACU,GAAG,GAAG,UAAUC,OAAO,EAAE;IACnD,IAAIN,IAAI,GAAG,IAAI,CAACP,KAAK;IACrB,IAAI,CAACW,KAAK,EAAE;IACZ,OAAOE,OAAO,GAAGA,OAAO,CAACC,MAAM,CAACP,IAAI,CAAC,GAAGA,IAAI;EAChD,CAAC;EACD;AACJ;AACA;EACIV,mBAAmB,CAACK,SAAS,CAACa,OAAO,GAAG,YAAY;IAChD,OAAO,IAAI,CAACf,KAAK,CAACgB,MAAM,KAAK,CAAC;EAClC,CAAC;EACD;AACJ;AACA;EACInB,mBAAmB,CAACK,SAAS,CAACQ,cAAc,GAAG,YAAY;IACvD,IAAK,IAAI,CAACT,aAAa,GAAGL,mBAAmB;IACzC;IACC,IAAI,CAACG,QAAQ,GAAG,CAAC,IAAI,IAAI,CAACC,KAAK,CAACgB,MAAM,IAAI,IAAI,CAACjB,QAAS,EAAE;MAC3D,IAAI,CAACM,WAAW,IAAI,IAAI,CAACA,WAAW,EAAE;IAC1C;EACJ,CAAC;EACD,OAAOR,mBAAmB;AAC9B,CAAC,EAAG;AACJ,SAASA,mBAAmB"},"metadata":{},"sourceType":"module"}