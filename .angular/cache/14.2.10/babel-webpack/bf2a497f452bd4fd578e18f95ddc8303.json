{"ast":null,"code":"import { matchersTransform } from '../matchersTransform';\nimport { Treatments } from '../treatments';\nimport { matcherFactory } from '../matchers';\nimport { sanitizeValue } from '../value';\nimport { conditionContext } from '../condition';\nimport { ifElseIfCombinerContext } from '../combiners/ifelseif';\nimport { andCombinerContext } from '../combiners/and';\nimport { thenable } from '../../utils/promise/thenable';\nexport function parser(log, conditions, storage) {\n  var predicates = [];\n  for (var i = 0; i < conditions.length; i++) {\n    var _a = conditions[i],\n      matcherGroup = _a.matcherGroup,\n      partitions = _a.partitions,\n      label = _a.label,\n      conditionType = _a.conditionType;\n    // transform data structure\n    var matchers = matchersTransform(matcherGroup.matchers);\n    // create a set of pure functions from the matcher's dto\n    var expressions = matchers.map(function (matcherDto) {\n      var matcher = matcherFactory(log, matcherDto, storage);\n      // Evaluator function.\n      return function (key, attributes, splitEvaluator) {\n        var value = sanitizeValue(log, key, matcherDto, attributes);\n        var result = value !== undefined && matcher ? matcher(value, splitEvaluator) : false;\n        if (thenable(result)) {\n          // @ts-ignore\n          return result.then(function (res) {\n            return Boolean(res ^ matcherDto.negate);\n          });\n        }\n        // @ts-ignore\n        return Boolean(result ^ matcherDto.negate);\n      };\n    });\n    // if matcher's factory can't instanciate the matchers, the expressions array\n    // will be empty\n    if (expressions.length === 0) {\n      // reset any data collected during parsing\n      predicates = [];\n      // and break the loop\n      break;\n    }\n    predicates.push(conditionContext(log, andCombinerContext(log, expressions), Treatments.parse(partitions), label, conditionType));\n  }\n  // Instanciate evaluator given the set of conditions using if else if logic\n  return ifElseIfCombinerContext(log, predicates);\n}","map":{"version":3,"names":["matchersTransform","Treatments","matcherFactory","sanitizeValue","conditionContext","ifElseIfCombinerContext","andCombinerContext","thenable","parser","log","conditions","storage","predicates","i","length","_a","matcherGroup","partitions","label","conditionType","matchers","expressions","map","matcherDto","matcher","key","attributes","splitEvaluator","value","result","undefined","then","res","Boolean","negate","push","parse"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/evaluator/parser/index.js"],"sourcesContent":["import { matchersTransform } from '../matchersTransform';\nimport { Treatments } from '../treatments';\nimport { matcherFactory } from '../matchers';\nimport { sanitizeValue } from '../value';\nimport { conditionContext } from '../condition';\nimport { ifElseIfCombinerContext } from '../combiners/ifelseif';\nimport { andCombinerContext } from '../combiners/and';\nimport { thenable } from '../../utils/promise/thenable';\nexport function parser(log, conditions, storage) {\n    var predicates = [];\n    for (var i = 0; i < conditions.length; i++) {\n        var _a = conditions[i], matcherGroup = _a.matcherGroup, partitions = _a.partitions, label = _a.label, conditionType = _a.conditionType;\n        // transform data structure\n        var matchers = matchersTransform(matcherGroup.matchers);\n        // create a set of pure functions from the matcher's dto\n        var expressions = matchers.map(function (matcherDto) {\n            var matcher = matcherFactory(log, matcherDto, storage);\n            // Evaluator function.\n            return function (key, attributes, splitEvaluator) {\n                var value = sanitizeValue(log, key, matcherDto, attributes);\n                var result = value !== undefined && matcher ? matcher(value, splitEvaluator) : false;\n                if (thenable(result)) {\n                    // @ts-ignore\n                    return result.then(function (res) { return Boolean(res ^ matcherDto.negate); });\n                }\n                // @ts-ignore\n                return Boolean(result ^ matcherDto.negate);\n            };\n        });\n        // if matcher's factory can't instanciate the matchers, the expressions array\n        // will be empty\n        if (expressions.length === 0) {\n            // reset any data collected during parsing\n            predicates = [];\n            // and break the loop\n            break;\n        }\n        predicates.push(conditionContext(log, andCombinerContext(log, expressions), Treatments.parse(partitions), label, conditionType));\n    }\n    // Instanciate evaluator given the set of conditions using if else if logic\n    return ifElseIfCombinerContext(log, predicates);\n}\n"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,sBAAsB;AACxD,SAASC,UAAU,QAAQ,eAAe;AAC1C,SAASC,cAAc,QAAQ,aAAa;AAC5C,SAASC,aAAa,QAAQ,UAAU;AACxC,SAASC,gBAAgB,QAAQ,cAAc;AAC/C,SAASC,uBAAuB,QAAQ,uBAAuB;AAC/D,SAASC,kBAAkB,QAAQ,kBAAkB;AACrD,SAASC,QAAQ,QAAQ,8BAA8B;AACvD,OAAO,SAASC,MAAM,CAACC,GAAG,EAAEC,UAAU,EAAEC,OAAO,EAAE;EAC7C,IAAIC,UAAU,GAAG,EAAE;EACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,UAAU,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,IAAIE,EAAE,GAAGL,UAAU,CAACG,CAAC,CAAC;MAAEG,YAAY,GAAGD,EAAE,CAACC,YAAY;MAAEC,UAAU,GAAGF,EAAE,CAACE,UAAU;MAAEC,KAAK,GAAGH,EAAE,CAACG,KAAK;MAAEC,aAAa,GAAGJ,EAAE,CAACI,aAAa;IACtI;IACA,IAAIC,QAAQ,GAAGpB,iBAAiB,CAACgB,YAAY,CAACI,QAAQ,CAAC;IACvD;IACA,IAAIC,WAAW,GAAGD,QAAQ,CAACE,GAAG,CAAC,UAAUC,UAAU,EAAE;MACjD,IAAIC,OAAO,GAAGtB,cAAc,CAACO,GAAG,EAAEc,UAAU,EAAEZ,OAAO,CAAC;MACtD;MACA,OAAO,UAAUc,GAAG,EAAEC,UAAU,EAAEC,cAAc,EAAE;QAC9C,IAAIC,KAAK,GAAGzB,aAAa,CAACM,GAAG,EAAEgB,GAAG,EAAEF,UAAU,EAAEG,UAAU,CAAC;QAC3D,IAAIG,MAAM,GAAGD,KAAK,KAAKE,SAAS,IAAIN,OAAO,GAAGA,OAAO,CAACI,KAAK,EAAED,cAAc,CAAC,GAAG,KAAK;QACpF,IAAIpB,QAAQ,CAACsB,MAAM,CAAC,EAAE;UAClB;UACA,OAAOA,MAAM,CAACE,IAAI,CAAC,UAAUC,GAAG,EAAE;YAAE,OAAOC,OAAO,CAACD,GAAG,GAAGT,UAAU,CAACW,MAAM,CAAC;UAAE,CAAC,CAAC;QACnF;QACA;QACA,OAAOD,OAAO,CAACJ,MAAM,GAAGN,UAAU,CAACW,MAAM,CAAC;MAC9C,CAAC;IACL,CAAC,CAAC;IACF;IACA;IACA,IAAIb,WAAW,CAACP,MAAM,KAAK,CAAC,EAAE;MAC1B;MACAF,UAAU,GAAG,EAAE;MACf;MACA;IACJ;IACAA,UAAU,CAACuB,IAAI,CAAC/B,gBAAgB,CAACK,GAAG,EAAEH,kBAAkB,CAACG,GAAG,EAAEY,WAAW,CAAC,EAAEpB,UAAU,CAACmC,KAAK,CAACnB,UAAU,CAAC,EAAEC,KAAK,EAAEC,aAAa,CAAC,CAAC;EACpI;EACA;EACA,OAAOd,uBAAuB,CAACI,GAAG,EAAEG,UAAU,CAAC;AACnD"},"metadata":{},"sourceType":"module"}