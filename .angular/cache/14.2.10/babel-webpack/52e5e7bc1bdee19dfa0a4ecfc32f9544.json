{"ast":null,"code":"import { getTreatment, shouldApplyRollout } from './engineUtils';\nimport { thenable } from '../../utils/promise/thenable';\nimport * as LabelsConstants from '../../utils/labels';\n// Build Evaluation object if and only if matchingResult is true\nfunction match(log, matchingResult, bucketingKey, seed, treatments, label) {\n  if (matchingResult) {\n    var treatment = getTreatment(log, bucketingKey, seed, treatments);\n    return {\n      treatment: treatment,\n      label: label\n    };\n  }\n  // else we should notify the engine to continue evaluating\n  return undefined;\n}\n// Condition factory\nexport function conditionContext(log, matcherEvaluator, treatments, label, conditionType) {\n  return function conditionEvaluator(key, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator) {\n    // Whitelisting has more priority than traffic allocation, so we don't apply this filtering to those conditions.\n    if (conditionType === 'ROLLOUT' && !shouldApplyRollout(trafficAllocation, key.bucketingKey, trafficAllocationSeed)) {\n      return {\n        treatment: undefined,\n        label: LabelsConstants.NOT_IN_SPLIT\n      };\n    }\n    // matcherEvaluator could be Async, this relays on matchers return value, so we need\n    // to verify for thenable before play with the result.\n    // Also, we pass splitEvaluator function in case we have a matcher that needs to evaluate another split,\n    // as well as the entire key object for the same reason.\n    var matches = matcherEvaluator(key, attributes, splitEvaluator);\n    if (thenable(matches)) {\n      return matches.then(function (result) {\n        return match(log, result, key.bucketingKey, seed, treatments, label);\n      });\n    }\n    return match(log, matches, key.bucketingKey, seed, treatments, label);\n  };\n}","map":{"version":3,"names":["getTreatment","shouldApplyRollout","thenable","LabelsConstants","match","log","matchingResult","bucketingKey","seed","treatments","label","treatment","undefined","conditionContext","matcherEvaluator","conditionType","conditionEvaluator","key","trafficAllocation","trafficAllocationSeed","attributes","splitEvaluator","NOT_IN_SPLIT","matches","then","result"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/evaluator/condition/index.js"],"sourcesContent":["import { getTreatment, shouldApplyRollout } from './engineUtils';\nimport { thenable } from '../../utils/promise/thenable';\nimport * as LabelsConstants from '../../utils/labels';\n// Build Evaluation object if and only if matchingResult is true\nfunction match(log, matchingResult, bucketingKey, seed, treatments, label) {\n    if (matchingResult) {\n        var treatment = getTreatment(log, bucketingKey, seed, treatments);\n        return {\n            treatment: treatment,\n            label: label\n        };\n    }\n    // else we should notify the engine to continue evaluating\n    return undefined;\n}\n// Condition factory\nexport function conditionContext(log, matcherEvaluator, treatments, label, conditionType) {\n    return function conditionEvaluator(key, seed, trafficAllocation, trafficAllocationSeed, attributes, splitEvaluator) {\n        // Whitelisting has more priority than traffic allocation, so we don't apply this filtering to those conditions.\n        if (conditionType === 'ROLLOUT' && !shouldApplyRollout(trafficAllocation, key.bucketingKey, trafficAllocationSeed)) {\n            return {\n                treatment: undefined,\n                label: LabelsConstants.NOT_IN_SPLIT\n            };\n        }\n        // matcherEvaluator could be Async, this relays on matchers return value, so we need\n        // to verify for thenable before play with the result.\n        // Also, we pass splitEvaluator function in case we have a matcher that needs to evaluate another split,\n        // as well as the entire key object for the same reason.\n        var matches = matcherEvaluator(key, attributes, splitEvaluator);\n        if (thenable(matches)) {\n            return matches.then(function (result) { return match(log, result, key.bucketingKey, seed, treatments, label); });\n        }\n        return match(log, matches, key.bucketingKey, seed, treatments, label);\n    };\n}\n"],"mappings":"AAAA,SAASA,YAAY,EAAEC,kBAAkB,QAAQ,eAAe;AAChE,SAASC,QAAQ,QAAQ,8BAA8B;AACvD,OAAO,KAAKC,eAAe,MAAM,oBAAoB;AACrD;AACA,SAASC,KAAK,CAACC,GAAG,EAAEC,cAAc,EAAEC,YAAY,EAAEC,IAAI,EAAEC,UAAU,EAAEC,KAAK,EAAE;EACvE,IAAIJ,cAAc,EAAE;IAChB,IAAIK,SAAS,GAAGX,YAAY,CAACK,GAAG,EAAEE,YAAY,EAAEC,IAAI,EAAEC,UAAU,CAAC;IACjE,OAAO;MACHE,SAAS,EAAEA,SAAS;MACpBD,KAAK,EAAEA;IACX,CAAC;EACL;EACA;EACA,OAAOE,SAAS;AACpB;AACA;AACA,OAAO,SAASC,gBAAgB,CAACR,GAAG,EAAES,gBAAgB,EAAEL,UAAU,EAAEC,KAAK,EAAEK,aAAa,EAAE;EACtF,OAAO,SAASC,kBAAkB,CAACC,GAAG,EAAET,IAAI,EAAEU,iBAAiB,EAAEC,qBAAqB,EAAEC,UAAU,EAAEC,cAAc,EAAE;IAChH;IACA,IAAIN,aAAa,KAAK,SAAS,IAAI,CAACd,kBAAkB,CAACiB,iBAAiB,EAAED,GAAG,CAACV,YAAY,EAAEY,qBAAqB,CAAC,EAAE;MAChH,OAAO;QACHR,SAAS,EAAEC,SAAS;QACpBF,KAAK,EAAEP,eAAe,CAACmB;MAC3B,CAAC;IACL;IACA;IACA;IACA;IACA;IACA,IAAIC,OAAO,GAAGT,gBAAgB,CAACG,GAAG,EAAEG,UAAU,EAAEC,cAAc,CAAC;IAC/D,IAAInB,QAAQ,CAACqB,OAAO,CAAC,EAAE;MACnB,OAAOA,OAAO,CAACC,IAAI,CAAC,UAAUC,MAAM,EAAE;QAAE,OAAOrB,KAAK,CAACC,GAAG,EAAEoB,MAAM,EAAER,GAAG,CAACV,YAAY,EAAEC,IAAI,EAAEC,UAAU,EAAEC,KAAK,CAAC;MAAE,CAAC,CAAC;IACpH;IACA,OAAON,KAAK,CAACC,GAAG,EAAEkB,OAAO,EAAEN,GAAG,CAACV,YAAY,EAAEC,IAAI,EAAEC,UAAU,EAAEC,KAAK,CAAC;EACzE,CAAC;AACL"},"metadata":{},"sourceType":"module"}