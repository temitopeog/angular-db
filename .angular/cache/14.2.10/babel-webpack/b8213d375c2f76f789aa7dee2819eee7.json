{"ast":null,"code":"import { errorParser, messageParser } from './NotificationParser';\nimport { notificationKeeperFactory } from './NotificationKeeper';\nimport { PUSH_RETRYABLE_ERROR, PUSH_NONRETRYABLE_ERROR, OCCUPANCY, CONTROL, MY_SEGMENTS_UPDATE, MY_SEGMENTS_UPDATE_V2, SEGMENT_UPDATE, SPLIT_KILL, SPLIT_UPDATE } from '../constants';\nimport { STREAMING_PARSING_ERROR_FAILS, ERROR_STREAMING_SSE, STREAMING_PARSING_MESSAGE_FAILS, STREAMING_NEW_MESSAGE } from '../../../logger/constants';\nimport { ABLY_ERROR, NON_REQUESTED, SSE_CONNECTION_ERROR } from '../../../utils/constants';\n/**\n * Factory for SSEHandler, which processes SSEClient messages and emits the corresponding push events.\n *\n * @param log factory logger\n * @param pushEmitter emitter for events related to streaming support\n */\nexport function SSEHandlerFactory(log, pushEmitter, telemetryTracker) {\n  var notificationKeeper = notificationKeeperFactory(pushEmitter, telemetryTracker);\n  function isRetryableError(error) {\n    if (error.parsedData && error.parsedData.code) {\n      // Ably error\n      var code = error.parsedData.code;\n      telemetryTracker.streamingEvent(ABLY_ERROR, code);\n      // 401 errors due to invalid or expired token (e.g., if refresh token coudn't be executed)\n      if (40140 <= code && code <= 40149) return true;\n      // Others 4XX errors (e.g., bad request from the SDK)\n      if (40000 <= code && code <= 49999) return false;\n    } else {\n      // network errors or 5XX HTTP errors\n      telemetryTracker.streamingEvent(SSE_CONNECTION_ERROR, NON_REQUESTED);\n    }\n    return true;\n  }\n  return {\n    handleOpen: function () {\n      notificationKeeper.handleOpen();\n    },\n    /* HTTP & Network errors */\n    handleError: function (error) {\n      var errorWithParsedData = error;\n      try {\n        errorWithParsedData = errorParser(error);\n      } catch (err) {\n        log.warn(STREAMING_PARSING_ERROR_FAILS, [err]);\n      }\n      var errorMessage = errorWithParsedData.parsedData && errorWithParsedData.parsedData.message || errorWithParsedData.message;\n      log.error(ERROR_STREAMING_SSE, [errorMessage]);\n      if (isRetryableError(errorWithParsedData)) {\n        pushEmitter.emit(PUSH_RETRYABLE_ERROR);\n      } else {\n        pushEmitter.emit(PUSH_NONRETRYABLE_ERROR);\n      }\n    },\n    /* NotificationProcessor */\n    handleMessage: function (message) {\n      var messageWithParsedData;\n      try {\n        messageWithParsedData = messageParser(message);\n        if (!messageWithParsedData) return; // Messages with empty data are ignored\n      } catch (err) {\n        log.warn(STREAMING_PARSING_MESSAGE_FAILS, [err]);\n        return;\n      }\n      var parsedData = messageWithParsedData.parsedData,\n        data = messageWithParsedData.data,\n        channel = messageWithParsedData.channel,\n        timestamp = messageWithParsedData.timestamp;\n      log.debug(STREAMING_NEW_MESSAGE, [data]);\n      // we only handle update events if streaming is up.\n      if (!notificationKeeper.isStreamingUp() && [OCCUPANCY, CONTROL].indexOf(parsedData.type) === -1) return;\n      switch (parsedData.type) {\n        /* update events */\n        case SPLIT_UPDATE:\n        case SEGMENT_UPDATE:\n        case MY_SEGMENTS_UPDATE_V2:\n        case SPLIT_KILL:\n          pushEmitter.emit(parsedData.type, parsedData);\n          break;\n        case MY_SEGMENTS_UPDATE:\n          pushEmitter.emit(parsedData.type, parsedData, channel);\n          break;\n        /* occupancy & control events, handled by NotificationManagerKeeper */\n        case OCCUPANCY:\n          notificationKeeper.handleOccupancyEvent(parsedData.metrics.publishers, channel, timestamp);\n          break;\n        case CONTROL:\n          notificationKeeper.handleControlEvent(parsedData.controlType, channel, timestamp);\n          break;\n        default:\n          break;\n      }\n    }\n  };\n}","map":{"version":3,"names":["errorParser","messageParser","notificationKeeperFactory","PUSH_RETRYABLE_ERROR","PUSH_NONRETRYABLE_ERROR","OCCUPANCY","CONTROL","MY_SEGMENTS_UPDATE","MY_SEGMENTS_UPDATE_V2","SEGMENT_UPDATE","SPLIT_KILL","SPLIT_UPDATE","STREAMING_PARSING_ERROR_FAILS","ERROR_STREAMING_SSE","STREAMING_PARSING_MESSAGE_FAILS","STREAMING_NEW_MESSAGE","ABLY_ERROR","NON_REQUESTED","SSE_CONNECTION_ERROR","SSEHandlerFactory","log","pushEmitter","telemetryTracker","notificationKeeper","isRetryableError","error","parsedData","code","streamingEvent","handleOpen","handleError","errorWithParsedData","err","warn","errorMessage","message","emit","handleMessage","messageWithParsedData","data","channel","timestamp","debug","isStreamingUp","indexOf","type","handleOccupancyEvent","metrics","publishers","handleControlEvent","controlType"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/streaming/SSEHandler/index.js"],"sourcesContent":["import { errorParser, messageParser } from './NotificationParser';\nimport { notificationKeeperFactory } from './NotificationKeeper';\nimport { PUSH_RETRYABLE_ERROR, PUSH_NONRETRYABLE_ERROR, OCCUPANCY, CONTROL, MY_SEGMENTS_UPDATE, MY_SEGMENTS_UPDATE_V2, SEGMENT_UPDATE, SPLIT_KILL, SPLIT_UPDATE } from '../constants';\nimport { STREAMING_PARSING_ERROR_FAILS, ERROR_STREAMING_SSE, STREAMING_PARSING_MESSAGE_FAILS, STREAMING_NEW_MESSAGE } from '../../../logger/constants';\nimport { ABLY_ERROR, NON_REQUESTED, SSE_CONNECTION_ERROR } from '../../../utils/constants';\n/**\n * Factory for SSEHandler, which processes SSEClient messages and emits the corresponding push events.\n *\n * @param log factory logger\n * @param pushEmitter emitter for events related to streaming support\n */\nexport function SSEHandlerFactory(log, pushEmitter, telemetryTracker) {\n    var notificationKeeper = notificationKeeperFactory(pushEmitter, telemetryTracker);\n    function isRetryableError(error) {\n        if (error.parsedData && error.parsedData.code) {\n            // Ably error\n            var code = error.parsedData.code;\n            telemetryTracker.streamingEvent(ABLY_ERROR, code);\n            // 401 errors due to invalid or expired token (e.g., if refresh token coudn't be executed)\n            if (40140 <= code && code <= 40149)\n                return true;\n            // Others 4XX errors (e.g., bad request from the SDK)\n            if (40000 <= code && code <= 49999)\n                return false;\n        }\n        else {\n            // network errors or 5XX HTTP errors\n            telemetryTracker.streamingEvent(SSE_CONNECTION_ERROR, NON_REQUESTED);\n        }\n        return true;\n    }\n    return {\n        handleOpen: function () {\n            notificationKeeper.handleOpen();\n        },\n        /* HTTP & Network errors */\n        handleError: function (error) {\n            var errorWithParsedData = error;\n            try {\n                errorWithParsedData = errorParser(error);\n            }\n            catch (err) {\n                log.warn(STREAMING_PARSING_ERROR_FAILS, [err]);\n            }\n            var errorMessage = (errorWithParsedData.parsedData && errorWithParsedData.parsedData.message) || errorWithParsedData.message;\n            log.error(ERROR_STREAMING_SSE, [errorMessage]);\n            if (isRetryableError(errorWithParsedData)) {\n                pushEmitter.emit(PUSH_RETRYABLE_ERROR);\n            }\n            else {\n                pushEmitter.emit(PUSH_NONRETRYABLE_ERROR);\n            }\n        },\n        /* NotificationProcessor */\n        handleMessage: function (message) {\n            var messageWithParsedData;\n            try {\n                messageWithParsedData = messageParser(message);\n                if (!messageWithParsedData)\n                    return; // Messages with empty data are ignored\n            }\n            catch (err) {\n                log.warn(STREAMING_PARSING_MESSAGE_FAILS, [err]);\n                return;\n            }\n            var parsedData = messageWithParsedData.parsedData, data = messageWithParsedData.data, channel = messageWithParsedData.channel, timestamp = messageWithParsedData.timestamp;\n            log.debug(STREAMING_NEW_MESSAGE, [data]);\n            // we only handle update events if streaming is up.\n            if (!notificationKeeper.isStreamingUp() && [OCCUPANCY, CONTROL].indexOf(parsedData.type) === -1)\n                return;\n            switch (parsedData.type) {\n                /* update events */\n                case SPLIT_UPDATE:\n                case SEGMENT_UPDATE:\n                case MY_SEGMENTS_UPDATE_V2:\n                case SPLIT_KILL:\n                    pushEmitter.emit(parsedData.type, parsedData);\n                    break;\n                case MY_SEGMENTS_UPDATE:\n                    pushEmitter.emit(parsedData.type, parsedData, channel);\n                    break;\n                /* occupancy & control events, handled by NotificationManagerKeeper */\n                case OCCUPANCY:\n                    notificationKeeper.handleOccupancyEvent(parsedData.metrics.publishers, channel, timestamp);\n                    break;\n                case CONTROL:\n                    notificationKeeper.handleControlEvent(parsedData.controlType, channel, timestamp);\n                    break;\n                default:\n                    break;\n            }\n        },\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}