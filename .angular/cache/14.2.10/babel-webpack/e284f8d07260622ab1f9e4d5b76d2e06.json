{"ast":null,"code":"import { timeout } from '../../../utils/promise/timeout';\nimport { SDK_SEGMENTS_ARRIVED } from '../../../readiness/constants';\nimport { SYNC_MYSEGMENTS_FETCH_RETRY } from '../../../logger/constants';\n/**\n * factory of MySegments updater, a task that:\n *  - fetches mySegments using `mySegmentsFetcher`\n *  - updates `mySegmentsCache`\n *  - uses `segmentsEventEmitter` to emit events related to segments data updates\n */\nexport function mySegmentsUpdaterFactory(log, mySegmentsFetcher, splitsCache, mySegmentsCache, segmentsEventEmitter, requestTimeoutBeforeReady, retriesOnFailureBeforeReady, matchingKey) {\n  var readyOnAlreadyExistentState = true;\n  var startingUp = true;\n  /** timeout and telemetry decorator for `splitChangesFetcher` promise  */\n  function _promiseDecorator(promise) {\n    if (startingUp) promise = timeout(requestTimeoutBeforeReady, promise);\n    return promise;\n  }\n  // @TODO if allowing pluggable storages, handle async execution\n  function updateSegments(segmentsData) {\n    var shouldNotifyUpdate;\n    if (Array.isArray(segmentsData)) {\n      // Update the list of segment names available\n      shouldNotifyUpdate = mySegmentsCache.resetSegments(segmentsData);\n    } else {\n      // Add/Delete the segment\n      var name_1 = segmentsData.name,\n        add = segmentsData.add;\n      if (mySegmentsCache.isInSegment(name_1) !== add) {\n        shouldNotifyUpdate = true;\n        if (add) mySegmentsCache.addToSegment(name_1);else mySegmentsCache.removeFromSegment(name_1);\n      } else {\n        shouldNotifyUpdate = false;\n      }\n    }\n    // Notify update if required\n    if (splitsCache.usesSegments() && (shouldNotifyUpdate || readyOnAlreadyExistentState)) {\n      readyOnAlreadyExistentState = false;\n      segmentsEventEmitter.emit(SDK_SEGMENTS_ARRIVED);\n    }\n  }\n  function _mySegmentsUpdater(retry, segmentsData, noCache) {\n    var updaterPromise = segmentsData ?\n    // If segmentsData is provided, there is no need to fetch mySegments\n    new Promise(function (res) {\n      updateSegments(segmentsData);\n      res(true);\n    }) :\n    // If not provided, fetch mySegments\n    mySegmentsFetcher(matchingKey, noCache, _promiseDecorator).then(function (segments) {\n      // Only when we have downloaded segments completely, we should not keep retrying anymore\n      startingUp = false;\n      updateSegments(segments);\n      return true;\n    });\n    return updaterPromise.catch(function (error) {\n      if (startingUp && retriesOnFailureBeforeReady > retry) {\n        retry += 1;\n        log.warn(SYNC_MYSEGMENTS_FETCH_RETRY, [retry, error]);\n        return _mySegmentsUpdater(retry); // no need to forward `segmentList` and `noCache` params\n      } else {\n        startingUp = false;\n      }\n      return false;\n    });\n  }\n  /**\n   * MySegments updater returns a promise that resolves with a `false` boolean value if it fails to fetch mySegments or synchronize them with the storage.\n   * Returned promise will not be rejected.\n   *\n   * @param {SegmentsData | undefined} segmentsData it can be:\n   *  (1) the list of mySegments names to sync in the storage,\n   *  (2) an object with a segment name and action (true: add, or false: delete) to update the storage,\n   *  (3) or `undefined`, for which the updater will fetch mySegments in order to sync the storage.\n   * @param {boolean | undefined} noCache true to revalidate data to fetch\n   */\n  return function mySegmentsUpdater(segmentsData, noCache) {\n    return _mySegmentsUpdater(0, segmentsData, noCache);\n  };\n}","map":{"version":3,"names":["timeout","SDK_SEGMENTS_ARRIVED","SYNC_MYSEGMENTS_FETCH_RETRY","mySegmentsUpdaterFactory","log","mySegmentsFetcher","splitsCache","mySegmentsCache","segmentsEventEmitter","requestTimeoutBeforeReady","retriesOnFailureBeforeReady","matchingKey","readyOnAlreadyExistentState","startingUp","_promiseDecorator","promise","updateSegments","segmentsData","shouldNotifyUpdate","Array","isArray","resetSegments","name_1","name","add","isInSegment","addToSegment","removeFromSegment","usesSegments","emit","_mySegmentsUpdater","retry","noCache","updaterPromise","Promise","res","then","segments","catch","error","warn","mySegmentsUpdater"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sync/polling/updaters/mySegmentsUpdater.js"],"sourcesContent":["import { timeout } from '../../../utils/promise/timeout';\nimport { SDK_SEGMENTS_ARRIVED } from '../../../readiness/constants';\nimport { SYNC_MYSEGMENTS_FETCH_RETRY } from '../../../logger/constants';\n/**\n * factory of MySegments updater, a task that:\n *  - fetches mySegments using `mySegmentsFetcher`\n *  - updates `mySegmentsCache`\n *  - uses `segmentsEventEmitter` to emit events related to segments data updates\n */\nexport function mySegmentsUpdaterFactory(log, mySegmentsFetcher, splitsCache, mySegmentsCache, segmentsEventEmitter, requestTimeoutBeforeReady, retriesOnFailureBeforeReady, matchingKey) {\n    var readyOnAlreadyExistentState = true;\n    var startingUp = true;\n    /** timeout and telemetry decorator for `splitChangesFetcher` promise  */\n    function _promiseDecorator(promise) {\n        if (startingUp)\n            promise = timeout(requestTimeoutBeforeReady, promise);\n        return promise;\n    }\n    // @TODO if allowing pluggable storages, handle async execution\n    function updateSegments(segmentsData) {\n        var shouldNotifyUpdate;\n        if (Array.isArray(segmentsData)) {\n            // Update the list of segment names available\n            shouldNotifyUpdate = mySegmentsCache.resetSegments(segmentsData);\n        }\n        else {\n            // Add/Delete the segment\n            var name_1 = segmentsData.name, add = segmentsData.add;\n            if (mySegmentsCache.isInSegment(name_1) !== add) {\n                shouldNotifyUpdate = true;\n                if (add)\n                    mySegmentsCache.addToSegment(name_1);\n                else\n                    mySegmentsCache.removeFromSegment(name_1);\n            }\n            else {\n                shouldNotifyUpdate = false;\n            }\n        }\n        // Notify update if required\n        if (splitsCache.usesSegments() && (shouldNotifyUpdate || readyOnAlreadyExistentState)) {\n            readyOnAlreadyExistentState = false;\n            segmentsEventEmitter.emit(SDK_SEGMENTS_ARRIVED);\n        }\n    }\n    function _mySegmentsUpdater(retry, segmentsData, noCache) {\n        var updaterPromise = segmentsData ?\n            // If segmentsData is provided, there is no need to fetch mySegments\n            new Promise(function (res) { updateSegments(segmentsData); res(true); }) :\n            // If not provided, fetch mySegments\n            mySegmentsFetcher(matchingKey, noCache, _promiseDecorator).then(function (segments) {\n                // Only when we have downloaded segments completely, we should not keep retrying anymore\n                startingUp = false;\n                updateSegments(segments);\n                return true;\n            });\n        return updaterPromise.catch(function (error) {\n            if (startingUp && retriesOnFailureBeforeReady > retry) {\n                retry += 1;\n                log.warn(SYNC_MYSEGMENTS_FETCH_RETRY, [retry, error]);\n                return _mySegmentsUpdater(retry); // no need to forward `segmentList` and `noCache` params\n            }\n            else {\n                startingUp = false;\n            }\n            return false;\n        });\n    }\n    /**\n     * MySegments updater returns a promise that resolves with a `false` boolean value if it fails to fetch mySegments or synchronize them with the storage.\n     * Returned promise will not be rejected.\n     *\n     * @param {SegmentsData | undefined} segmentsData it can be:\n     *  (1) the list of mySegments names to sync in the storage,\n     *  (2) an object with a segment name and action (true: add, or false: delete) to update the storage,\n     *  (3) or `undefined`, for which the updater will fetch mySegments in order to sync the storage.\n     * @param {boolean | undefined} noCache true to revalidate data to fetch\n     */\n    return function mySegmentsUpdater(segmentsData, noCache) {\n        return _mySegmentsUpdater(0, segmentsData, noCache);\n    };\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,gCAAgC;AACxD,SAASC,oBAAoB,QAAQ,8BAA8B;AACnE,SAASC,2BAA2B,QAAQ,2BAA2B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,wBAAwB,CAACC,GAAG,EAAEC,iBAAiB,EAAEC,WAAW,EAAEC,eAAe,EAAEC,oBAAoB,EAAEC,yBAAyB,EAAEC,2BAA2B,EAAEC,WAAW,EAAE;EACtL,IAAIC,2BAA2B,GAAG,IAAI;EACtC,IAAIC,UAAU,GAAG,IAAI;EACrB;EACA,SAASC,iBAAiB,CAACC,OAAO,EAAE;IAChC,IAAIF,UAAU,EACVE,OAAO,GAAGf,OAAO,CAACS,yBAAyB,EAAEM,OAAO,CAAC;IACzD,OAAOA,OAAO;EAClB;EACA;EACA,SAASC,cAAc,CAACC,YAAY,EAAE;IAClC,IAAIC,kBAAkB;IACtB,IAAIC,KAAK,CAACC,OAAO,CAACH,YAAY,CAAC,EAAE;MAC7B;MACAC,kBAAkB,GAAGX,eAAe,CAACc,aAAa,CAACJ,YAAY,CAAC;IACpE,CAAC,MACI;MACD;MACA,IAAIK,MAAM,GAAGL,YAAY,CAACM,IAAI;QAAEC,GAAG,GAAGP,YAAY,CAACO,GAAG;MACtD,IAAIjB,eAAe,CAACkB,WAAW,CAACH,MAAM,CAAC,KAAKE,GAAG,EAAE;QAC7CN,kBAAkB,GAAG,IAAI;QACzB,IAAIM,GAAG,EACHjB,eAAe,CAACmB,YAAY,CAACJ,MAAM,CAAC,CAAC,KAErCf,eAAe,CAACoB,iBAAiB,CAACL,MAAM,CAAC;MACjD,CAAC,MACI;QACDJ,kBAAkB,GAAG,KAAK;MAC9B;IACJ;IACA;IACA,IAAIZ,WAAW,CAACsB,YAAY,EAAE,KAAKV,kBAAkB,IAAIN,2BAA2B,CAAC,EAAE;MACnFA,2BAA2B,GAAG,KAAK;MACnCJ,oBAAoB,CAACqB,IAAI,CAAC5B,oBAAoB,CAAC;IACnD;EACJ;EACA,SAAS6B,kBAAkB,CAACC,KAAK,EAAEd,YAAY,EAAEe,OAAO,EAAE;IACtD,IAAIC,cAAc,GAAGhB,YAAY;IAC7B;IACA,IAAIiB,OAAO,CAAC,UAAUC,GAAG,EAAE;MAAEnB,cAAc,CAACC,YAAY,CAAC;MAAEkB,GAAG,CAAC,IAAI,CAAC;IAAE,CAAC,CAAC;IACxE;IACA9B,iBAAiB,CAACM,WAAW,EAAEqB,OAAO,EAAElB,iBAAiB,CAAC,CAACsB,IAAI,CAAC,UAAUC,QAAQ,EAAE;MAChF;MACAxB,UAAU,GAAG,KAAK;MAClBG,cAAc,CAACqB,QAAQ,CAAC;MACxB,OAAO,IAAI;IACf,CAAC,CAAC;IACN,OAAOJ,cAAc,CAACK,KAAK,CAAC,UAAUC,KAAK,EAAE;MACzC,IAAI1B,UAAU,IAAIH,2BAA2B,GAAGqB,KAAK,EAAE;QACnDA,KAAK,IAAI,CAAC;QACV3B,GAAG,CAACoC,IAAI,CAACtC,2BAA2B,EAAE,CAAC6B,KAAK,EAAEQ,KAAK,CAAC,CAAC;QACrD,OAAOT,kBAAkB,CAACC,KAAK,CAAC,CAAC,CAAC;MACtC,CAAC,MACI;QACDlB,UAAU,GAAG,KAAK;MACtB;MACA,OAAO,KAAK;IAChB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAO,SAAS4B,iBAAiB,CAACxB,YAAY,EAAEe,OAAO,EAAE;IACrD,OAAOF,kBAAkB,CAAC,CAAC,EAAEb,YAAY,EAAEe,OAAO,CAAC;EACvD,CAAC;AACL"},"metadata":{},"sourceType":"module"}