{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { AbstractSegmentsCacheSync } from '../AbstractSegmentsCacheSync';\nimport { LOG_PREFIX, DEFINED } from './constants';\nvar MySegmentsCacheInLocal = /** @class */function (_super) {\n  __extends(MySegmentsCacheInLocal, _super);\n  function MySegmentsCacheInLocal(log, keys) {\n    var _this = _super.call(this) || this;\n    _this.log = log;\n    _this.keys = keys;\n    return _this;\n    // There is not need to flush segments cache like splits cache, since resetSegments receives the up-to-date list of active segments\n  }\n  /**\n   * Removes list of segments from localStorage\n   * @NOTE this method is not being used at the moment.\n   */\n  MySegmentsCacheInLocal.prototype.clear = function () {\n    this.log.info(LOG_PREFIX + 'Flushing MySegments data from localStorage');\n    // We cannot simply call `localStorage.clear()` since that implies removing user items from the storage\n    // We could optimize next sentence, since it implies iterating over all localStorage items\n    this.resetSegments([]);\n  };\n  MySegmentsCacheInLocal.prototype.addToSegment = function (name) {\n    var segmentKey = this.keys.buildSegmentNameKey(name);\n    try {\n      localStorage.setItem(segmentKey, DEFINED);\n      return true;\n    } catch (e) {\n      this.log.error(LOG_PREFIX + e);\n      return false;\n    }\n  };\n  MySegmentsCacheInLocal.prototype.removeFromSegment = function (name) {\n    var segmentKey = this.keys.buildSegmentNameKey(name);\n    try {\n      localStorage.removeItem(segmentKey);\n      return true;\n    } catch (e) {\n      this.log.error(LOG_PREFIX + e);\n      return false;\n    }\n  };\n  MySegmentsCacheInLocal.prototype.isInSegment = function (name) {\n    return localStorage.getItem(this.keys.buildSegmentNameKey(name)) === DEFINED;\n  };\n  /**\n   * Reset (update) the cached list of segments with the given list, removing and adding segments if necessary.\n   *\n   * @param {string[]} segmentNames list of segment names\n   * @returns boolean indicating if the cache was updated (i.e., given list was different from the cached one)\n   */\n  MySegmentsCacheInLocal.prototype.resetSegments = function (names) {\n    var _this = this;\n    var isDiff = false;\n    var index;\n    // Scan current values from localStorage\n    var storedSegmentNames = Object.keys(localStorage).reduce(function (accum, key) {\n      var segmentName = _this.keys.extractSegmentName(key);\n      if (segmentName) {\n        accum.push(segmentName);\n      } else {\n        // @TODO @BREAKING: This is only to clean up \"old\" keys. Remove this whole else code block and reuse `getRegisteredSegments` method.\n        segmentName = _this.keys.extractOldSegmentKey(key);\n        if (segmentName) {\n          // this was an old segment key, let's clean up.\n          var newSegmentKey = _this.keys.buildSegmentNameKey(segmentName);\n          try {\n            // If the new format key is not there, create it.\n            if (!localStorage.getItem(newSegmentKey) && names.indexOf(segmentName) > -1) {\n              localStorage.setItem(newSegmentKey, DEFINED);\n              // we are migrating a segment, let's track it.\n              accum.push(segmentName);\n            }\n            localStorage.removeItem(key); // we migrated the current key, let's delete it.\n          } catch (e) {\n            _this.log.error(e);\n          }\n        }\n      }\n      return accum;\n    }, []);\n    // Extreme fast => everything is empty\n    if (names.length === 0 && storedSegmentNames.length === names.length) return isDiff;\n    // Quick path\n    if (storedSegmentNames.length !== names.length) {\n      isDiff = true;\n      storedSegmentNames.forEach(function (name) {\n        return _this.removeFromSegment(name);\n      });\n      names.forEach(function (name) {\n        return _this.addToSegment(name);\n      });\n    } else {\n      // Slowest path => we need to find at least 1 difference because\n      for (index = 0; index < names.length && storedSegmentNames.indexOf(names[index]) !== -1; index++) {\n        // TODO: why empty statement?\n      }\n      if (index < names.length) {\n        isDiff = true;\n        storedSegmentNames.forEach(function (name) {\n          return _this.removeFromSegment(name);\n        });\n        names.forEach(function (name) {\n          return _this.addToSegment(name);\n        });\n      }\n    }\n    return isDiff;\n  };\n  MySegmentsCacheInLocal.prototype.getRegisteredSegments = function () {\n    var _this = this;\n    return Object.keys(localStorage).reduce(function (accum, key) {\n      var segmentName = _this.keys.extractSegmentName(key);\n      if (segmentName) accum.push(segmentName);\n      return accum;\n    }, []);\n  };\n  MySegmentsCacheInLocal.prototype.getKeysCount = function () {\n    return 1;\n  };\n  return MySegmentsCacheInLocal;\n}(AbstractSegmentsCacheSync);\nexport { MySegmentsCacheInLocal };","map":{"version":3,"names":["__extends","AbstractSegmentsCacheSync","LOG_PREFIX","DEFINED","MySegmentsCacheInLocal","_super","log","keys","_this","call","prototype","clear","info","resetSegments","addToSegment","name","segmentKey","buildSegmentNameKey","localStorage","setItem","e","error","removeFromSegment","removeItem","isInSegment","getItem","names","isDiff","index","storedSegmentNames","Object","reduce","accum","key","segmentName","extractSegmentName","push","extractOldSegmentKey","newSegmentKey","indexOf","length","forEach","getRegisteredSegments","getKeysCount"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/inLocalStorage/MySegmentsCacheInLocal.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { AbstractSegmentsCacheSync } from '../AbstractSegmentsCacheSync';\nimport { LOG_PREFIX, DEFINED } from './constants';\nvar MySegmentsCacheInLocal = /** @class */ (function (_super) {\n    __extends(MySegmentsCacheInLocal, _super);\n    function MySegmentsCacheInLocal(log, keys) {\n        var _this = _super.call(this) || this;\n        _this.log = log;\n        _this.keys = keys;\n        return _this;\n        // There is not need to flush segments cache like splits cache, since resetSegments receives the up-to-date list of active segments\n    }\n    /**\n     * Removes list of segments from localStorage\n     * @NOTE this method is not being used at the moment.\n     */\n    MySegmentsCacheInLocal.prototype.clear = function () {\n        this.log.info(LOG_PREFIX + 'Flushing MySegments data from localStorage');\n        // We cannot simply call `localStorage.clear()` since that implies removing user items from the storage\n        // We could optimize next sentence, since it implies iterating over all localStorage items\n        this.resetSegments([]);\n    };\n    MySegmentsCacheInLocal.prototype.addToSegment = function (name) {\n        var segmentKey = this.keys.buildSegmentNameKey(name);\n        try {\n            localStorage.setItem(segmentKey, DEFINED);\n            return true;\n        }\n        catch (e) {\n            this.log.error(LOG_PREFIX + e);\n            return false;\n        }\n    };\n    MySegmentsCacheInLocal.prototype.removeFromSegment = function (name) {\n        var segmentKey = this.keys.buildSegmentNameKey(name);\n        try {\n            localStorage.removeItem(segmentKey);\n            return true;\n        }\n        catch (e) {\n            this.log.error(LOG_PREFIX + e);\n            return false;\n        }\n    };\n    MySegmentsCacheInLocal.prototype.isInSegment = function (name) {\n        return localStorage.getItem(this.keys.buildSegmentNameKey(name)) === DEFINED;\n    };\n    /**\n     * Reset (update) the cached list of segments with the given list, removing and adding segments if necessary.\n     *\n     * @param {string[]} segmentNames list of segment names\n     * @returns boolean indicating if the cache was updated (i.e., given list was different from the cached one)\n     */\n    MySegmentsCacheInLocal.prototype.resetSegments = function (names) {\n        var _this = this;\n        var isDiff = false;\n        var index;\n        // Scan current values from localStorage\n        var storedSegmentNames = Object.keys(localStorage).reduce(function (accum, key) {\n            var segmentName = _this.keys.extractSegmentName(key);\n            if (segmentName) {\n                accum.push(segmentName);\n            }\n            else {\n                // @TODO @BREAKING: This is only to clean up \"old\" keys. Remove this whole else code block and reuse `getRegisteredSegments` method.\n                segmentName = _this.keys.extractOldSegmentKey(key);\n                if (segmentName) { // this was an old segment key, let's clean up.\n                    var newSegmentKey = _this.keys.buildSegmentNameKey(segmentName);\n                    try {\n                        // If the new format key is not there, create it.\n                        if (!localStorage.getItem(newSegmentKey) && names.indexOf(segmentName) > -1) {\n                            localStorage.setItem(newSegmentKey, DEFINED);\n                            // we are migrating a segment, let's track it.\n                            accum.push(segmentName);\n                        }\n                        localStorage.removeItem(key); // we migrated the current key, let's delete it.\n                    }\n                    catch (e) {\n                        _this.log.error(e);\n                    }\n                }\n            }\n            return accum;\n        }, []);\n        // Extreme fast => everything is empty\n        if (names.length === 0 && storedSegmentNames.length === names.length)\n            return isDiff;\n        // Quick path\n        if (storedSegmentNames.length !== names.length) {\n            isDiff = true;\n            storedSegmentNames.forEach(function (name) { return _this.removeFromSegment(name); });\n            names.forEach(function (name) { return _this.addToSegment(name); });\n        }\n        else {\n            // Slowest path => we need to find at least 1 difference because\n            for (index = 0; index < names.length && storedSegmentNames.indexOf(names[index]) !== -1; index++) {\n                // TODO: why empty statement?\n            }\n            if (index < names.length) {\n                isDiff = true;\n                storedSegmentNames.forEach(function (name) { return _this.removeFromSegment(name); });\n                names.forEach(function (name) { return _this.addToSegment(name); });\n            }\n        }\n        return isDiff;\n    };\n    MySegmentsCacheInLocal.prototype.getRegisteredSegments = function () {\n        var _this = this;\n        return Object.keys(localStorage).reduce(function (accum, key) {\n            var segmentName = _this.keys.extractSegmentName(key);\n            if (segmentName)\n                accum.push(segmentName);\n            return accum;\n        }, []);\n    };\n    MySegmentsCacheInLocal.prototype.getKeysCount = function () {\n        return 1;\n    };\n    return MySegmentsCacheInLocal;\n}(AbstractSegmentsCacheSync));\nexport { MySegmentsCacheInLocal };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}