{"ast":null,"code":"import { evaluateFeature, evaluateFeatures } from '../evaluator';\nimport { thenable } from '../utils/promise/thenable';\nimport { getMatching, getBucketing } from '../utils/key';\nimport { validateSplitExistance } from '../utils/inputValidation/splitExistance';\nimport { validateTrafficTypeExistance } from '../utils/inputValidation/trafficTypeExistance';\nimport { SDK_NOT_READY } from '../utils/labels';\nimport { CONTROL, TREATMENT, TREATMENTS, TREATMENT_WITH_CONFIG, TREATMENTS_WITH_CONFIG, TRACK } from '../utils/constants';\nimport { IMPRESSION, IMPRESSION_QUEUEING } from '../logger/constants';\n/**\n * Creator of base client with getTreatments and track methods.\n */\nexport function clientFactory(params) {\n  var readinessManager = params.sdkReadinessManager.readinessManager,\n    storage = params.storage,\n    settings = params.settings,\n    impressionsTracker = params.impressionsTracker,\n    eventTracker = params.eventTracker,\n    telemetryTracker = params.telemetryTracker;\n  var log = settings.log,\n    mode = settings.mode;\n  function getTreatment(key, splitName, attributes, withConfig) {\n    if (withConfig === void 0) {\n      withConfig = false;\n    }\n    var stopTelemetryTracker = telemetryTracker.trackEval(withConfig ? TREATMENT_WITH_CONFIG : TREATMENT);\n    var wrapUp = function (evaluationResult) {\n      var queue = [];\n      var treatment = processEvaluation(evaluationResult, splitName, key, attributes, withConfig, \"getTreatment\" + (withConfig ? 'withConfig' : ''), queue);\n      impressionsTracker.track(queue, attributes);\n      stopTelemetryTracker(queue[0] && queue[0].label);\n      return treatment;\n    };\n    var evaluation = evaluateFeature(log, key, splitName, attributes, storage);\n    return thenable(evaluation) ? evaluation.then(function (res) {\n      return wrapUp(res);\n    }) : wrapUp(evaluation);\n  }\n  function getTreatmentWithConfig(key, splitName, attributes) {\n    return getTreatment(key, splitName, attributes, true);\n  }\n  function getTreatments(key, splitNames, attributes, withConfig) {\n    if (withConfig === void 0) {\n      withConfig = false;\n    }\n    var stopTelemetryTracker = telemetryTracker.trackEval(withConfig ? TREATMENTS_WITH_CONFIG : TREATMENTS);\n    var wrapUp = function (evaluationResults) {\n      var queue = [];\n      var treatments = {};\n      Object.keys(evaluationResults).forEach(function (splitName) {\n        treatments[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, withConfig, \"getTreatments\" + (withConfig ? 'withConfig' : ''), queue);\n      });\n      impressionsTracker.track(queue, attributes);\n      stopTelemetryTracker(queue[0] && queue[0].label);\n      return treatments;\n    };\n    var evaluations = evaluateFeatures(log, key, splitNames, attributes, storage);\n    return thenable(evaluations) ? evaluations.then(function (res) {\n      return wrapUp(res);\n    }) : wrapUp(evaluations);\n  }\n  function getTreatmentsWithConfig(key, splitNames, attributes) {\n    return getTreatments(key, splitNames, attributes, true);\n  }\n  // Internal function\n  function processEvaluation(evaluation, splitName, key, attributes, withConfig, invokingMethodName, queue) {\n    var isSdkReady = readinessManager.isReady() || readinessManager.isReadyFromCache();\n    var matchingKey = getMatching(key);\n    var bucketingKey = getBucketing(key);\n    // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.\n    if (!isSdkReady) {\n      evaluation = {\n        treatment: CONTROL,\n        label: SDK_NOT_READY\n      };\n    }\n    var treatment = evaluation.treatment,\n      label = evaluation.label,\n      changeNumber = evaluation.changeNumber,\n      _a = evaluation.config,\n      config = _a === void 0 ? null : _a;\n    log.info(IMPRESSION, [splitName, matchingKey, treatment, label]);\n    if (validateSplitExistance(log, readinessManager, splitName, label, invokingMethodName)) {\n      log.info(IMPRESSION_QUEUEING);\n      queue.push({\n        feature: splitName,\n        keyName: matchingKey,\n        treatment: treatment,\n        time: Date.now(),\n        bucketingKey: bucketingKey,\n        label: label,\n        changeNumber: changeNumber\n      });\n    }\n    if (withConfig) {\n      return {\n        treatment: treatment,\n        config: config\n      };\n    }\n    return treatment;\n  }\n  function track(key, trafficTypeName, eventTypeId, value, properties, size) {\n    if (size === void 0) {\n      size = 1024;\n    }\n    var stopTelemetryTracker = telemetryTracker.trackEval(TRACK);\n    var matchingKey = getMatching(key);\n    var timestamp = Date.now();\n    var eventData = {\n      eventTypeId: eventTypeId,\n      trafficTypeName: trafficTypeName,\n      value: value,\n      timestamp: timestamp,\n      key: matchingKey,\n      properties: properties\n    };\n    // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.\n    validateTrafficTypeExistance(log, readinessManager, storage.splits, mode, trafficTypeName, 'track');\n    var result = eventTracker.track(eventData, size);\n    if (thenable(result)) {\n      return result.then(function (result) {\n        stopTelemetryTracker();\n        return result;\n      });\n    } else {\n      stopTelemetryTracker();\n      return result;\n    }\n  }\n  return {\n    getTreatment: getTreatment,\n    getTreatmentWithConfig: getTreatmentWithConfig,\n    getTreatments: getTreatments,\n    getTreatmentsWithConfig: getTreatmentsWithConfig,\n    track: track,\n    isClientSide: false\n  };\n}","map":{"version":3,"names":["evaluateFeature","evaluateFeatures","thenable","getMatching","getBucketing","validateSplitExistance","validateTrafficTypeExistance","SDK_NOT_READY","CONTROL","TREATMENT","TREATMENTS","TREATMENT_WITH_CONFIG","TREATMENTS_WITH_CONFIG","TRACK","IMPRESSION","IMPRESSION_QUEUEING","clientFactory","params","readinessManager","sdkReadinessManager","storage","settings","impressionsTracker","eventTracker","telemetryTracker","log","mode","getTreatment","key","splitName","attributes","withConfig","stopTelemetryTracker","trackEval","wrapUp","evaluationResult","queue","treatment","processEvaluation","track","label","evaluation","then","res","getTreatmentWithConfig","getTreatments","splitNames","evaluationResults","treatments","Object","keys","forEach","evaluations","getTreatmentsWithConfig","invokingMethodName","isSdkReady","isReady","isReadyFromCache","matchingKey","bucketingKey","changeNumber","_a","config","info","push","feature","keyName","time","Date","now","trafficTypeName","eventTypeId","value","properties","size","timestamp","eventData","splits","result","isClientSide"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/sdkClient/client.js"],"sourcesContent":["import { evaluateFeature, evaluateFeatures } from '../evaluator';\nimport { thenable } from '../utils/promise/thenable';\nimport { getMatching, getBucketing } from '../utils/key';\nimport { validateSplitExistance } from '../utils/inputValidation/splitExistance';\nimport { validateTrafficTypeExistance } from '../utils/inputValidation/trafficTypeExistance';\nimport { SDK_NOT_READY } from '../utils/labels';\nimport { CONTROL, TREATMENT, TREATMENTS, TREATMENT_WITH_CONFIG, TREATMENTS_WITH_CONFIG, TRACK } from '../utils/constants';\nimport { IMPRESSION, IMPRESSION_QUEUEING } from '../logger/constants';\n/**\n * Creator of base client with getTreatments and track methods.\n */\nexport function clientFactory(params) {\n    var readinessManager = params.sdkReadinessManager.readinessManager, storage = params.storage, settings = params.settings, impressionsTracker = params.impressionsTracker, eventTracker = params.eventTracker, telemetryTracker = params.telemetryTracker;\n    var log = settings.log, mode = settings.mode;\n    function getTreatment(key, splitName, attributes, withConfig) {\n        if (withConfig === void 0) { withConfig = false; }\n        var stopTelemetryTracker = telemetryTracker.trackEval(withConfig ? TREATMENT_WITH_CONFIG : TREATMENT);\n        var wrapUp = function (evaluationResult) {\n            var queue = [];\n            var treatment = processEvaluation(evaluationResult, splitName, key, attributes, withConfig, \"getTreatment\" + (withConfig ? 'withConfig' : ''), queue);\n            impressionsTracker.track(queue, attributes);\n            stopTelemetryTracker(queue[0] && queue[0].label);\n            return treatment;\n        };\n        var evaluation = evaluateFeature(log, key, splitName, attributes, storage);\n        return thenable(evaluation) ? evaluation.then(function (res) { return wrapUp(res); }) : wrapUp(evaluation);\n    }\n    function getTreatmentWithConfig(key, splitName, attributes) {\n        return getTreatment(key, splitName, attributes, true);\n    }\n    function getTreatments(key, splitNames, attributes, withConfig) {\n        if (withConfig === void 0) { withConfig = false; }\n        var stopTelemetryTracker = telemetryTracker.trackEval(withConfig ? TREATMENTS_WITH_CONFIG : TREATMENTS);\n        var wrapUp = function (evaluationResults) {\n            var queue = [];\n            var treatments = {};\n            Object.keys(evaluationResults).forEach(function (splitName) {\n                treatments[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, withConfig, \"getTreatments\" + (withConfig ? 'withConfig' : ''), queue);\n            });\n            impressionsTracker.track(queue, attributes);\n            stopTelemetryTracker(queue[0] && queue[0].label);\n            return treatments;\n        };\n        var evaluations = evaluateFeatures(log, key, splitNames, attributes, storage);\n        return thenable(evaluations) ? evaluations.then(function (res) { return wrapUp(res); }) : wrapUp(evaluations);\n    }\n    function getTreatmentsWithConfig(key, splitNames, attributes) {\n        return getTreatments(key, splitNames, attributes, true);\n    }\n    // Internal function\n    function processEvaluation(evaluation, splitName, key, attributes, withConfig, invokingMethodName, queue) {\n        var isSdkReady = readinessManager.isReady() || readinessManager.isReadyFromCache();\n        var matchingKey = getMatching(key);\n        var bucketingKey = getBucketing(key);\n        // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.\n        if (!isSdkReady) {\n            evaluation = { treatment: CONTROL, label: SDK_NOT_READY };\n        }\n        var treatment = evaluation.treatment, label = evaluation.label, changeNumber = evaluation.changeNumber, _a = evaluation.config, config = _a === void 0 ? null : _a;\n        log.info(IMPRESSION, [splitName, matchingKey, treatment, label]);\n        if (validateSplitExistance(log, readinessManager, splitName, label, invokingMethodName)) {\n            log.info(IMPRESSION_QUEUEING);\n            queue.push({\n                feature: splitName,\n                keyName: matchingKey,\n                treatment: treatment,\n                time: Date.now(),\n                bucketingKey: bucketingKey,\n                label: label,\n                changeNumber: changeNumber\n            });\n        }\n        if (withConfig) {\n            return {\n                treatment: treatment,\n                config: config\n            };\n        }\n        return treatment;\n    }\n    function track(key, trafficTypeName, eventTypeId, value, properties, size) {\n        if (size === void 0) { size = 1024; }\n        var stopTelemetryTracker = telemetryTracker.trackEval(TRACK);\n        var matchingKey = getMatching(key);\n        var timestamp = Date.now();\n        var eventData = {\n            eventTypeId: eventTypeId,\n            trafficTypeName: trafficTypeName,\n            value: value,\n            timestamp: timestamp,\n            key: matchingKey,\n            properties: properties\n        };\n        // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.\n        validateTrafficTypeExistance(log, readinessManager, storage.splits, mode, trafficTypeName, 'track');\n        var result = eventTracker.track(eventData, size);\n        if (thenable(result)) {\n            return result.then(function (result) {\n                stopTelemetryTracker();\n                return result;\n            });\n        }\n        else {\n            stopTelemetryTracker();\n            return result;\n        }\n    }\n    return {\n        getTreatment: getTreatment,\n        getTreatmentWithConfig: getTreatmentWithConfig,\n        getTreatments: getTreatments,\n        getTreatmentsWithConfig: getTreatmentsWithConfig,\n        track: track,\n        isClientSide: false\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}