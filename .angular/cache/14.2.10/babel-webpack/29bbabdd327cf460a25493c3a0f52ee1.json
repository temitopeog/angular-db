{"ast":null,"code":"import { objectAssign } from '../utils/lang/objectAssign';\nimport { SDK_SPLITS_ARRIVED, SDK_SPLITS_CACHE_LOADED, SDK_SEGMENTS_ARRIVED, SDK_READY_TIMED_OUT, SDK_READY_FROM_CACHE, SDK_UPDATE, SDK_READY } from './constants';\nfunction splitsEventEmitterFactory(EventEmitter) {\n  var splitsEventEmitter = objectAssign(new EventEmitter(), {\n    splitsArrived: false,\n    splitsCacheLoaded: false\n  });\n  // `isSplitKill` condition avoids an edge-case of wrongly emitting SDK_READY if:\n  // - `/mySegments` fetch and SPLIT_KILL occurs before `/splitChanges` fetch, and\n  // - storage has cached splits (for which case `splitsStorage.killLocally` can return true)\n  splitsEventEmitter.on(SDK_SPLITS_ARRIVED, function (isSplitKill) {\n    if (!isSplitKill) splitsEventEmitter.splitsArrived = true;\n  });\n  splitsEventEmitter.once(SDK_SPLITS_CACHE_LOADED, function () {\n    splitsEventEmitter.splitsCacheLoaded = true;\n  });\n  return splitsEventEmitter;\n}\nfunction segmentsEventEmitterFactory(EventEmitter) {\n  var segmentsEventEmitter = objectAssign(new EventEmitter(), {\n    segmentsArrived: false\n  });\n  segmentsEventEmitter.once(SDK_SEGMENTS_ARRIVED, function () {\n    segmentsEventEmitter.segmentsArrived = true;\n  });\n  return segmentsEventEmitter;\n}\n/**\n * Factory of readiness manager, which handles the ready / update event propagation.\n */\nexport function readinessManagerFactory(EventEmitter, readyTimeout, splits) {\n  if (readyTimeout === void 0) {\n    readyTimeout = 0;\n  }\n  if (splits === void 0) {\n    splits = splitsEventEmitterFactory(EventEmitter);\n  }\n  var segments = segmentsEventEmitterFactory(EventEmitter);\n  var gate = new EventEmitter();\n  // emit SDK_READY_FROM_CACHE\n  var isReadyFromCache = false;\n  if (splits.splitsCacheLoaded) isReadyFromCache = true; // ready from cache, but doesn't emit SDK_READY_FROM_CACHE\n  else splits.once(SDK_SPLITS_CACHE_LOADED, checkIsReadyFromCache);\n  // emit SDK_READY_TIMED_OUT\n  var hasTimedout = false;\n  var readyTimeoutId;\n  if (readyTimeout > 0) {\n    readyTimeoutId = setTimeout(function () {\n      hasTimedout = true;\n      gate.emit(SDK_READY_TIMED_OUT, 'Split SDK emitted SDK_READY_TIMED_OUT event.');\n    }, readyTimeout);\n  }\n  // emit SDK_READY and SDK_UPDATE\n  var isReady = false;\n  splits.on(SDK_SPLITS_ARRIVED, checkIsReadyOrUpdate);\n  segments.on(SDK_SEGMENTS_ARRIVED, checkIsReadyOrUpdate);\n  var isDestroyed = false;\n  function checkIsReadyFromCache() {\n    isReadyFromCache = true;\n    // Don't emit SDK_READY_FROM_CACHE if SDK_READY has been emitted\n    if (!isReady) {\n      try {\n        gate.emit(SDK_READY_FROM_CACHE);\n      } catch (e) {\n        // throws user callback exceptions in next tick\n        setTimeout(function () {\n          throw e;\n        }, 0);\n      }\n    }\n  }\n  function checkIsReadyOrUpdate(diff) {\n    if (isReady) {\n      try {\n        gate.emit(SDK_UPDATE, diff);\n      } catch (e) {\n        // throws user callback exceptions in next tick\n        setTimeout(function () {\n          throw e;\n        }, 0);\n      }\n    } else {\n      if (splits.splitsArrived && segments.segmentsArrived) {\n        clearTimeout(readyTimeoutId);\n        isReady = true;\n        try {\n          gate.emit(SDK_READY);\n        } catch (e) {\n          // throws user callback exceptions in next tick\n          setTimeout(function () {\n            throw e;\n          }, 0);\n        }\n      }\n    }\n  }\n  var refCount = 1;\n  return {\n    splits: splits,\n    segments: segments,\n    gate: gate,\n    shared: function (readyTimeout) {\n      if (readyTimeout === void 0) {\n        readyTimeout = 0;\n      }\n      refCount++;\n      return readinessManagerFactory(EventEmitter, readyTimeout, splits);\n    },\n    destroy: function () {\n      isDestroyed = true;\n      segments.removeAllListeners();\n      gate.removeAllListeners();\n      clearTimeout(readyTimeoutId);\n      if (refCount > 0) refCount--;\n      if (refCount === 0) splits.removeAllListeners();\n    },\n    isReady: function () {\n      return isReady;\n    },\n    hasTimedout: function () {\n      return hasTimedout;\n    },\n    isReadyFromCache: function () {\n      return isReadyFromCache;\n    },\n    isDestroyed: function () {\n      return isDestroyed;\n    },\n    isOperational: function () {\n      return (isReady || isReadyFromCache) && !isDestroyed;\n    }\n  };\n}","map":{"version":3,"names":["objectAssign","SDK_SPLITS_ARRIVED","SDK_SPLITS_CACHE_LOADED","SDK_SEGMENTS_ARRIVED","SDK_READY_TIMED_OUT","SDK_READY_FROM_CACHE","SDK_UPDATE","SDK_READY","splitsEventEmitterFactory","EventEmitter","splitsEventEmitter","splitsArrived","splitsCacheLoaded","on","isSplitKill","once","segmentsEventEmitterFactory","segmentsEventEmitter","segmentsArrived","readinessManagerFactory","readyTimeout","splits","segments","gate","isReadyFromCache","checkIsReadyFromCache","hasTimedout","readyTimeoutId","setTimeout","emit","isReady","checkIsReadyOrUpdate","isDestroyed","e","diff","clearTimeout","refCount","shared","destroy","removeAllListeners","isOperational"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/readiness/readinessManager.js"],"sourcesContent":["import { objectAssign } from '../utils/lang/objectAssign';\nimport { SDK_SPLITS_ARRIVED, SDK_SPLITS_CACHE_LOADED, SDK_SEGMENTS_ARRIVED, SDK_READY_TIMED_OUT, SDK_READY_FROM_CACHE, SDK_UPDATE, SDK_READY } from './constants';\nfunction splitsEventEmitterFactory(EventEmitter) {\n    var splitsEventEmitter = objectAssign(new EventEmitter(), {\n        splitsArrived: false,\n        splitsCacheLoaded: false,\n    });\n    // `isSplitKill` condition avoids an edge-case of wrongly emitting SDK_READY if:\n    // - `/mySegments` fetch and SPLIT_KILL occurs before `/splitChanges` fetch, and\n    // - storage has cached splits (for which case `splitsStorage.killLocally` can return true)\n    splitsEventEmitter.on(SDK_SPLITS_ARRIVED, function (isSplitKill) { if (!isSplitKill)\n        splitsEventEmitter.splitsArrived = true; });\n    splitsEventEmitter.once(SDK_SPLITS_CACHE_LOADED, function () { splitsEventEmitter.splitsCacheLoaded = true; });\n    return splitsEventEmitter;\n}\nfunction segmentsEventEmitterFactory(EventEmitter) {\n    var segmentsEventEmitter = objectAssign(new EventEmitter(), {\n        segmentsArrived: false\n    });\n    segmentsEventEmitter.once(SDK_SEGMENTS_ARRIVED, function () { segmentsEventEmitter.segmentsArrived = true; });\n    return segmentsEventEmitter;\n}\n/**\n * Factory of readiness manager, which handles the ready / update event propagation.\n */\nexport function readinessManagerFactory(EventEmitter, readyTimeout, splits) {\n    if (readyTimeout === void 0) { readyTimeout = 0; }\n    if (splits === void 0) { splits = splitsEventEmitterFactory(EventEmitter); }\n    var segments = segmentsEventEmitterFactory(EventEmitter);\n    var gate = new EventEmitter();\n    // emit SDK_READY_FROM_CACHE\n    var isReadyFromCache = false;\n    if (splits.splitsCacheLoaded)\n        isReadyFromCache = true; // ready from cache, but doesn't emit SDK_READY_FROM_CACHE\n    else\n        splits.once(SDK_SPLITS_CACHE_LOADED, checkIsReadyFromCache);\n    // emit SDK_READY_TIMED_OUT\n    var hasTimedout = false;\n    var readyTimeoutId;\n    if (readyTimeout > 0) {\n        readyTimeoutId = setTimeout(function () {\n            hasTimedout = true;\n            gate.emit(SDK_READY_TIMED_OUT, 'Split SDK emitted SDK_READY_TIMED_OUT event.');\n        }, readyTimeout);\n    }\n    // emit SDK_READY and SDK_UPDATE\n    var isReady = false;\n    splits.on(SDK_SPLITS_ARRIVED, checkIsReadyOrUpdate);\n    segments.on(SDK_SEGMENTS_ARRIVED, checkIsReadyOrUpdate);\n    var isDestroyed = false;\n    function checkIsReadyFromCache() {\n        isReadyFromCache = true;\n        // Don't emit SDK_READY_FROM_CACHE if SDK_READY has been emitted\n        if (!isReady) {\n            try {\n                gate.emit(SDK_READY_FROM_CACHE);\n            }\n            catch (e) {\n                // throws user callback exceptions in next tick\n                setTimeout(function () { throw e; }, 0);\n            }\n        }\n    }\n    function checkIsReadyOrUpdate(diff) {\n        if (isReady) {\n            try {\n                gate.emit(SDK_UPDATE, diff);\n            }\n            catch (e) {\n                // throws user callback exceptions in next tick\n                setTimeout(function () { throw e; }, 0);\n            }\n        }\n        else {\n            if (splits.splitsArrived && segments.segmentsArrived) {\n                clearTimeout(readyTimeoutId);\n                isReady = true;\n                try {\n                    gate.emit(SDK_READY);\n                }\n                catch (e) {\n                    // throws user callback exceptions in next tick\n                    setTimeout(function () { throw e; }, 0);\n                }\n            }\n        }\n    }\n    var refCount = 1;\n    return {\n        splits: splits,\n        segments: segments,\n        gate: gate,\n        shared: function (readyTimeout) {\n            if (readyTimeout === void 0) { readyTimeout = 0; }\n            refCount++;\n            return readinessManagerFactory(EventEmitter, readyTimeout, splits);\n        },\n        destroy: function () {\n            isDestroyed = true;\n            segments.removeAllListeners();\n            gate.removeAllListeners();\n            clearTimeout(readyTimeoutId);\n            if (refCount > 0)\n                refCount--;\n            if (refCount === 0)\n                splits.removeAllListeners();\n        },\n        isReady: function () { return isReady; },\n        hasTimedout: function () { return hasTimedout; },\n        isReadyFromCache: function () { return isReadyFromCache; },\n        isDestroyed: function () { return isDestroyed; },\n        isOperational: function () { return (isReady || isReadyFromCache) && !isDestroyed; }\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}