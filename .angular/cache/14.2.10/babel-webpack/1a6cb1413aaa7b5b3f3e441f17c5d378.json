{"ast":null,"code":"/**\n * This class provides a skeletal implementation of the ISplitsCacheSync interface\n * to minimize the effort required to implement this interface.\n */\nvar AbstractSplitsCacheSync = /** @class */function () {\n  function AbstractSplitsCacheSync() {}\n  AbstractSplitsCacheSync.prototype.addSplits = function (entries) {\n    var _this = this;\n    return entries.map(function (keyValuePair) {\n      return _this.addSplit(keyValuePair[0], keyValuePair[1]);\n    });\n  };\n  AbstractSplitsCacheSync.prototype.removeSplits = function (names) {\n    var _this = this;\n    return names.map(function (name) {\n      return _this.removeSplit(name);\n    });\n  };\n  AbstractSplitsCacheSync.prototype.getSplits = function (names) {\n    var _this = this;\n    var splits = {};\n    names.forEach(function (name) {\n      splits[name] = _this.getSplit(name);\n    });\n    return splits;\n  };\n  AbstractSplitsCacheSync.prototype.getAll = function () {\n    var _this = this;\n    return this.getSplitNames().map(function (key) {\n      return _this.getSplit(key);\n    });\n  };\n  /**\n   * Check if the splits information is already stored in cache. This data can be preloaded.\n   * It is used as condition to emit SDK_SPLITS_CACHE_LOADED, and then SDK_READY_FROM_CACHE.\n   */\n  AbstractSplitsCacheSync.prototype.checkCache = function () {\n    return false;\n  };\n  /**\n   * Kill `name` split and set `defaultTreatment` and `changeNumber`.\n   * Used for SPLIT_KILL push notifications.\n   *\n   * @param {string} name\n   * @param {string} defaultTreatment\n   * @param {number} changeNumber\n   * @returns {Promise} a promise that is resolved once the split kill is performed. The fulfillment value is a boolean: `true` if the kill success updating the split or `false` if no split is updated,\n   * for instance, if the `changeNumber` is old, or if the split is not found (e.g., `/splitchanges` hasn't been fetched yet), or if the storage fails to apply the update.\n   */\n  AbstractSplitsCacheSync.prototype.killLocally = function (name, defaultTreatment, changeNumber) {\n    var split = this.getSplit(name);\n    if (split) {\n      var parsedSplit = JSON.parse(split);\n      if (!parsedSplit.changeNumber || parsedSplit.changeNumber < changeNumber) {\n        parsedSplit.killed = true;\n        parsedSplit.defaultTreatment = defaultTreatment;\n        parsedSplit.changeNumber = changeNumber;\n        var newSplit = JSON.stringify(parsedSplit);\n        return this.addSplit(name, newSplit);\n      }\n    }\n    return false;\n  };\n  return AbstractSplitsCacheSync;\n}();\nexport { AbstractSplitsCacheSync };\n/**\n * Given a parsed split, it returns a boolean flagging if its conditions use segments matchers (rules & whitelists).\n * This util is intended to simplify the implementation of `splitsCache::usesSegments` method\n */\nexport function usesSegments(split) {\n  var conditions = split.conditions || [];\n  for (var i = 0; i < conditions.length; i++) {\n    var matchers = conditions[i].matcherGroup.matchers;\n    for (var j = 0; j < matchers.length; j++) {\n      if (matchers[j].matcherType === 'IN_SEGMENT') return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["AbstractSplitsCacheSync","prototype","addSplits","entries","_this","map","keyValuePair","addSplit","removeSplits","names","name","removeSplit","getSplits","splits","forEach","getSplit","getAll","getSplitNames","key","checkCache","killLocally","defaultTreatment","changeNumber","split","parsedSplit","JSON","parse","killed","newSplit","stringify","usesSegments","conditions","i","length","matchers","matcherGroup","j","matcherType"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/AbstractSplitsCacheSync.js"],"sourcesContent":["/**\n * This class provides a skeletal implementation of the ISplitsCacheSync interface\n * to minimize the effort required to implement this interface.\n */\nvar AbstractSplitsCacheSync = /** @class */ (function () {\n    function AbstractSplitsCacheSync() {\n    }\n    AbstractSplitsCacheSync.prototype.addSplits = function (entries) {\n        var _this = this;\n        return entries.map(function (keyValuePair) { return _this.addSplit(keyValuePair[0], keyValuePair[1]); });\n    };\n    AbstractSplitsCacheSync.prototype.removeSplits = function (names) {\n        var _this = this;\n        return names.map(function (name) { return _this.removeSplit(name); });\n    };\n    AbstractSplitsCacheSync.prototype.getSplits = function (names) {\n        var _this = this;\n        var splits = {};\n        names.forEach(function (name) {\n            splits[name] = _this.getSplit(name);\n        });\n        return splits;\n    };\n    AbstractSplitsCacheSync.prototype.getAll = function () {\n        var _this = this;\n        return this.getSplitNames().map(function (key) { return _this.getSplit(key); });\n    };\n    /**\n     * Check if the splits information is already stored in cache. This data can be preloaded.\n     * It is used as condition to emit SDK_SPLITS_CACHE_LOADED, and then SDK_READY_FROM_CACHE.\n     */\n    AbstractSplitsCacheSync.prototype.checkCache = function () {\n        return false;\n    };\n    /**\n     * Kill `name` split and set `defaultTreatment` and `changeNumber`.\n     * Used for SPLIT_KILL push notifications.\n     *\n     * @param {string} name\n     * @param {string} defaultTreatment\n     * @param {number} changeNumber\n     * @returns {Promise} a promise that is resolved once the split kill is performed. The fulfillment value is a boolean: `true` if the kill success updating the split or `false` if no split is updated,\n     * for instance, if the `changeNumber` is old, or if the split is not found (e.g., `/splitchanges` hasn't been fetched yet), or if the storage fails to apply the update.\n     */\n    AbstractSplitsCacheSync.prototype.killLocally = function (name, defaultTreatment, changeNumber) {\n        var split = this.getSplit(name);\n        if (split) {\n            var parsedSplit = JSON.parse(split);\n            if (!parsedSplit.changeNumber || parsedSplit.changeNumber < changeNumber) {\n                parsedSplit.killed = true;\n                parsedSplit.defaultTreatment = defaultTreatment;\n                parsedSplit.changeNumber = changeNumber;\n                var newSplit = JSON.stringify(parsedSplit);\n                return this.addSplit(name, newSplit);\n            }\n        }\n        return false;\n    };\n    return AbstractSplitsCacheSync;\n}());\nexport { AbstractSplitsCacheSync };\n/**\n * Given a parsed split, it returns a boolean flagging if its conditions use segments matchers (rules & whitelists).\n * This util is intended to simplify the implementation of `splitsCache::usesSegments` method\n */\nexport function usesSegments(split) {\n    var conditions = split.conditions || [];\n    for (var i = 0; i < conditions.length; i++) {\n        var matchers = conditions[i].matcherGroup.matchers;\n        for (var j = 0; j < matchers.length; j++) {\n            if (matchers[j].matcherType === 'IN_SEGMENT')\n                return true;\n        }\n    }\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}