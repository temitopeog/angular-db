{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-unused-vars */\nimport { isNaNNumber } from '../../utils/lang';\nimport { LOG_PREFIX } from './constants';\n/**\n * ISegmentsCacheAsync implementation for pluggable storages.\n */\nvar SegmentsCachePluggable = /** @class */function () {\n  function SegmentsCachePluggable(log, keys, wrapper) {\n    this.log = log;\n    this.keys = keys;\n    this.wrapper = wrapper;\n  }\n  /**\n   * Add a list of `segmentKeys` to the given segment `name`.\n   * The returned promise is resolved when the operation success\n   * or rejected if wrapper operation fails.\n   */\n  SegmentsCachePluggable.prototype.addToSegment = function (name, segmentKeys) {\n    var segmentKey = this.keys.buildSegmentNameKey(name);\n    if (segmentKeys.length) {\n      return this.wrapper.addItems(segmentKey, segmentKeys);\n    } else {\n      return Promise.resolve();\n    }\n  };\n  /**\n   * Remove a list of `segmentKeys` from the given segment `name`.\n   * The returned promise is resolved when the operation success\n   * or rejected if wrapper operation fails.\n   */\n  SegmentsCachePluggable.prototype.removeFromSegment = function (name, segmentKeys) {\n    var segmentKey = this.keys.buildSegmentNameKey(name);\n    if (segmentKeys.length) {\n      return this.wrapper.removeItems(segmentKey, segmentKeys);\n    } else {\n      return Promise.resolve();\n    }\n  };\n  /**\n   * Returns a promise that resolves with a boolean value indicating if `key` is part of `name` segment.\n   * Promise can be rejected if wrapper operation fails.\n   */\n  SegmentsCachePluggable.prototype.isInSegment = function (name, key) {\n    return this.wrapper.itemContains(this.keys.buildSegmentNameKey(name), key);\n  };\n  /**\n   * Set till number for the given segment `name`.\n   * The returned promise is resolved when the operation success,\n   * or rejected if it fails (e.g., wrapper operation fails).\n   */\n  SegmentsCachePluggable.prototype.setChangeNumber = function (name, changeNumber) {\n    return this.wrapper.set(this.keys.buildSegmentTillKey(name), changeNumber + '');\n  };\n  /**\n   * Get till number or -1 if it's not defined.\n   * The returned promise is resolved with the changeNumber or -1 if it doesn't exist or a wrapper operation fails.\n   * The promise will never be rejected.\n   */\n  SegmentsCachePluggable.prototype.getChangeNumber = function (name) {\n    var _this = this;\n    return this.wrapper.get(this.keys.buildSegmentTillKey(name)).then(function (value) {\n      var i = parseInt(value, 10);\n      return isNaNNumber(i) ? -1 : i;\n    }).catch(function (e) {\n      _this.log.error(LOG_PREFIX + 'Could not retrieve changeNumber from segments storage. Error: ' + e);\n      return -1;\n    });\n  };\n  /**\n   * Add the given segment names to the set of registered segments.\n   * The returned promise is resolved when the operation success,\n   * or rejected if it fails (e.g., wrapper operation fails).\n   */\n  SegmentsCachePluggable.prototype.registerSegments = function (segments) {\n    if (segments.length) {\n      return this.wrapper.addItems(this.keys.buildRegisteredSegmentsKey(), segments);\n    } else {\n      return Promise.resolve();\n    }\n  };\n  /**\n   * Returns a promise that resolves with the set of registered segments in a list,\n   * or rejected if it fails (e.g., wrapper operation fails).\n   */\n  SegmentsCachePluggable.prototype.getRegisteredSegments = function () {\n    return this.wrapper.getItems(this.keys.buildRegisteredSegmentsKey());\n  };\n  /** @TODO implement if required by DataLoader or Producer mode  */\n  SegmentsCachePluggable.prototype.clear = function () {\n    return Promise.resolve(true);\n  };\n  return SegmentsCachePluggable;\n}();\nexport { SegmentsCachePluggable };","map":{"version":3,"names":["isNaNNumber","LOG_PREFIX","SegmentsCachePluggable","log","keys","wrapper","prototype","addToSegment","name","segmentKeys","segmentKey","buildSegmentNameKey","length","addItems","Promise","resolve","removeFromSegment","removeItems","isInSegment","key","itemContains","setChangeNumber","changeNumber","set","buildSegmentTillKey","getChangeNumber","_this","get","then","value","i","parseInt","catch","e","error","registerSegments","segments","buildRegisteredSegmentsKey","getRegisteredSegments","getItems","clear"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/pluggable/SegmentsCachePluggable.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-unused-vars */\nimport { isNaNNumber } from '../../utils/lang';\nimport { LOG_PREFIX } from './constants';\n/**\n * ISegmentsCacheAsync implementation for pluggable storages.\n */\nvar SegmentsCachePluggable = /** @class */ (function () {\n    function SegmentsCachePluggable(log, keys, wrapper) {\n        this.log = log;\n        this.keys = keys;\n        this.wrapper = wrapper;\n    }\n    /**\n     * Add a list of `segmentKeys` to the given segment `name`.\n     * The returned promise is resolved when the operation success\n     * or rejected if wrapper operation fails.\n     */\n    SegmentsCachePluggable.prototype.addToSegment = function (name, segmentKeys) {\n        var segmentKey = this.keys.buildSegmentNameKey(name);\n        if (segmentKeys.length) {\n            return this.wrapper.addItems(segmentKey, segmentKeys);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    /**\n     * Remove a list of `segmentKeys` from the given segment `name`.\n     * The returned promise is resolved when the operation success\n     * or rejected if wrapper operation fails.\n     */\n    SegmentsCachePluggable.prototype.removeFromSegment = function (name, segmentKeys) {\n        var segmentKey = this.keys.buildSegmentNameKey(name);\n        if (segmentKeys.length) {\n            return this.wrapper.removeItems(segmentKey, segmentKeys);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    /**\n     * Returns a promise that resolves with a boolean value indicating if `key` is part of `name` segment.\n     * Promise can be rejected if wrapper operation fails.\n     */\n    SegmentsCachePluggable.prototype.isInSegment = function (name, key) {\n        return this.wrapper.itemContains(this.keys.buildSegmentNameKey(name), key);\n    };\n    /**\n     * Set till number for the given segment `name`.\n     * The returned promise is resolved when the operation success,\n     * or rejected if it fails (e.g., wrapper operation fails).\n     */\n    SegmentsCachePluggable.prototype.setChangeNumber = function (name, changeNumber) {\n        return this.wrapper.set(this.keys.buildSegmentTillKey(name), changeNumber + '');\n    };\n    /**\n     * Get till number or -1 if it's not defined.\n     * The returned promise is resolved with the changeNumber or -1 if it doesn't exist or a wrapper operation fails.\n     * The promise will never be rejected.\n     */\n    SegmentsCachePluggable.prototype.getChangeNumber = function (name) {\n        var _this = this;\n        return this.wrapper.get(this.keys.buildSegmentTillKey(name)).then(function (value) {\n            var i = parseInt(value, 10);\n            return isNaNNumber(i) ? -1 : i;\n        }).catch(function (e) {\n            _this.log.error(LOG_PREFIX + 'Could not retrieve changeNumber from segments storage. Error: ' + e);\n            return -1;\n        });\n    };\n    /**\n     * Add the given segment names to the set of registered segments.\n     * The returned promise is resolved when the operation success,\n     * or rejected if it fails (e.g., wrapper operation fails).\n     */\n    SegmentsCachePluggable.prototype.registerSegments = function (segments) {\n        if (segments.length) {\n            return this.wrapper.addItems(this.keys.buildRegisteredSegmentsKey(), segments);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    /**\n     * Returns a promise that resolves with the set of registered segments in a list,\n     * or rejected if it fails (e.g., wrapper operation fails).\n     */\n    SegmentsCachePluggable.prototype.getRegisteredSegments = function () {\n        return this.wrapper.getItems(this.keys.buildRegisteredSegmentsKey());\n    };\n    /** @TODO implement if required by DataLoader or Producer mode  */\n    SegmentsCachePluggable.prototype.clear = function () {\n        return Promise.resolve(true);\n    };\n    return SegmentsCachePluggable;\n}());\nexport { SegmentsCachePluggable };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}