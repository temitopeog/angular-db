{"ast":null,"code":"import { startsWith } from '../utils/lang';\nvar everythingAtTheEnd = /[^.]+$/;\nvar DEFAULT_PREFIX = 'SPLITIO';\nexport function validatePrefix(prefix) {\n  return prefix ? prefix + '.SPLITIO' : 'SPLITIO';\n}\nvar KeyBuilder = /** @class */function () {\n  function KeyBuilder(prefix) {\n    if (prefix === void 0) {\n      prefix = DEFAULT_PREFIX;\n    }\n    this.prefix = prefix;\n  }\n  KeyBuilder.prototype.buildTrafficTypeKey = function (trafficType) {\n    return this.prefix + \".trafficType.\" + trafficType;\n  };\n  KeyBuilder.prototype.buildSplitKey = function (splitName) {\n    return this.prefix + \".split.\" + splitName;\n  };\n  KeyBuilder.prototype.buildSplitsTillKey = function () {\n    return this.prefix + \".splits.till\";\n  };\n  // NOT USED\n  // buildSplitsReady() {\n  //   return `${this.prefix}.splits.ready`;\n  // }\n  KeyBuilder.prototype.isSplitKey = function (key) {\n    return startsWith(key, this.prefix + \".split.\");\n  };\n  KeyBuilder.prototype.buildSplitKeyPrefix = function () {\n    return this.prefix + \".split.\";\n  };\n  // Only used by InLocalStorage.\n  KeyBuilder.prototype.buildSplitsWithSegmentCountKey = function () {\n    return this.prefix + \".splits.usingSegments\";\n  };\n  KeyBuilder.prototype.buildSegmentNameKey = function (segmentName) {\n    return this.prefix + \".segment.\" + segmentName;\n  };\n  KeyBuilder.prototype.buildSegmentTillKey = function (segmentName) {\n    return this.prefix + \".segment.\" + segmentName + \".till\";\n  };\n  // NOT USED\n  // buildSegmentsReady() {\n  //   return `${this.prefix}.segments.ready`;\n  // }\n  KeyBuilder.prototype.extractKey = function (builtKey) {\n    var s = builtKey.match(everythingAtTheEnd);\n    if (s && s.length) {\n      return s[0];\n    } else {\n      throw new Error('Invalid latency key provided');\n    }\n  };\n  return KeyBuilder;\n}();\nexport { KeyBuilder };","map":{"version":3,"names":["startsWith","everythingAtTheEnd","DEFAULT_PREFIX","validatePrefix","prefix","KeyBuilder","prototype","buildTrafficTypeKey","trafficType","buildSplitKey","splitName","buildSplitsTillKey","isSplitKey","key","buildSplitKeyPrefix","buildSplitsWithSegmentCountKey","buildSegmentNameKey","segmentName","buildSegmentTillKey","extractKey","builtKey","s","match","length","Error"],"sources":["/Users/temitopeogunrekun/Desktop/angular-db/node_modules/@splitsoftware/splitio-commons/esm/storages/KeyBuilder.js"],"sourcesContent":["import { startsWith } from '../utils/lang';\nvar everythingAtTheEnd = /[^.]+$/;\nvar DEFAULT_PREFIX = 'SPLITIO';\nexport function validatePrefix(prefix) {\n    return prefix ? prefix + '.SPLITIO' : 'SPLITIO';\n}\nvar KeyBuilder = /** @class */ (function () {\n    function KeyBuilder(prefix) {\n        if (prefix === void 0) { prefix = DEFAULT_PREFIX; }\n        this.prefix = prefix;\n    }\n    KeyBuilder.prototype.buildTrafficTypeKey = function (trafficType) {\n        return this.prefix + \".trafficType.\" + trafficType;\n    };\n    KeyBuilder.prototype.buildSplitKey = function (splitName) {\n        return this.prefix + \".split.\" + splitName;\n    };\n    KeyBuilder.prototype.buildSplitsTillKey = function () {\n        return this.prefix + \".splits.till\";\n    };\n    // NOT USED\n    // buildSplitsReady() {\n    //   return `${this.prefix}.splits.ready`;\n    // }\n    KeyBuilder.prototype.isSplitKey = function (key) {\n        return startsWith(key, this.prefix + \".split.\");\n    };\n    KeyBuilder.prototype.buildSplitKeyPrefix = function () {\n        return this.prefix + \".split.\";\n    };\n    // Only used by InLocalStorage.\n    KeyBuilder.prototype.buildSplitsWithSegmentCountKey = function () {\n        return this.prefix + \".splits.usingSegments\";\n    };\n    KeyBuilder.prototype.buildSegmentNameKey = function (segmentName) {\n        return this.prefix + \".segment.\" + segmentName;\n    };\n    KeyBuilder.prototype.buildSegmentTillKey = function (segmentName) {\n        return this.prefix + \".segment.\" + segmentName + \".till\";\n    };\n    // NOT USED\n    // buildSegmentsReady() {\n    //   return `${this.prefix}.segments.ready`;\n    // }\n    KeyBuilder.prototype.extractKey = function (builtKey) {\n        var s = builtKey.match(everythingAtTheEnd);\n        if (s && s.length) {\n            return s[0];\n        }\n        else {\n            throw new Error('Invalid latency key provided');\n        }\n    };\n    return KeyBuilder;\n}());\nexport { KeyBuilder };\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,eAAe;AAC1C,IAAIC,kBAAkB,GAAG,QAAQ;AACjC,IAAIC,cAAc,GAAG,SAAS;AAC9B,OAAO,SAASC,cAAc,CAACC,MAAM,EAAE;EACnC,OAAOA,MAAM,GAAGA,MAAM,GAAG,UAAU,GAAG,SAAS;AACnD;AACA,IAAIC,UAAU,GAAG,aAAe,YAAY;EACxC,SAASA,UAAU,CAACD,MAAM,EAAE;IACxB,IAAIA,MAAM,KAAK,KAAK,CAAC,EAAE;MAAEA,MAAM,GAAGF,cAAc;IAAE;IAClD,IAAI,CAACE,MAAM,GAAGA,MAAM;EACxB;EACAC,UAAU,CAACC,SAAS,CAACC,mBAAmB,GAAG,UAAUC,WAAW,EAAE;IAC9D,OAAO,IAAI,CAACJ,MAAM,GAAG,eAAe,GAAGI,WAAW;EACtD,CAAC;EACDH,UAAU,CAACC,SAAS,CAACG,aAAa,GAAG,UAAUC,SAAS,EAAE;IACtD,OAAO,IAAI,CAACN,MAAM,GAAG,SAAS,GAAGM,SAAS;EAC9C,CAAC;EACDL,UAAU,CAACC,SAAS,CAACK,kBAAkB,GAAG,YAAY;IAClD,OAAO,IAAI,CAACP,MAAM,GAAG,cAAc;EACvC,CAAC;EACD;EACA;EACA;EACA;EACAC,UAAU,CAACC,SAAS,CAACM,UAAU,GAAG,UAAUC,GAAG,EAAE;IAC7C,OAAOb,UAAU,CAACa,GAAG,EAAE,IAAI,CAACT,MAAM,GAAG,SAAS,CAAC;EACnD,CAAC;EACDC,UAAU,CAACC,SAAS,CAACQ,mBAAmB,GAAG,YAAY;IACnD,OAAO,IAAI,CAACV,MAAM,GAAG,SAAS;EAClC,CAAC;EACD;EACAC,UAAU,CAACC,SAAS,CAACS,8BAA8B,GAAG,YAAY;IAC9D,OAAO,IAAI,CAACX,MAAM,GAAG,uBAAuB;EAChD,CAAC;EACDC,UAAU,CAACC,SAAS,CAACU,mBAAmB,GAAG,UAAUC,WAAW,EAAE;IAC9D,OAAO,IAAI,CAACb,MAAM,GAAG,WAAW,GAAGa,WAAW;EAClD,CAAC;EACDZ,UAAU,CAACC,SAAS,CAACY,mBAAmB,GAAG,UAAUD,WAAW,EAAE;IAC9D,OAAO,IAAI,CAACb,MAAM,GAAG,WAAW,GAAGa,WAAW,GAAG,OAAO;EAC5D,CAAC;EACD;EACA;EACA;EACA;EACAZ,UAAU,CAACC,SAAS,CAACa,UAAU,GAAG,UAAUC,QAAQ,EAAE;IAClD,IAAIC,CAAC,GAAGD,QAAQ,CAACE,KAAK,CAACrB,kBAAkB,CAAC;IAC1C,IAAIoB,CAAC,IAAIA,CAAC,CAACE,MAAM,EAAE;MACf,OAAOF,CAAC,CAAC,CAAC,CAAC;IACf,CAAC,MACI;MACD,MAAM,IAAIG,KAAK,CAAC,8BAA8B,CAAC;IACnD;EACJ,CAAC;EACD,OAAOnB,UAAU;AACrB,CAAC,EAAG;AACJ,SAASA,UAAU"},"metadata":{},"sourceType":"module"}